import React, { useState, useEffect, useCallback, useRef, useMemo, createContext, useContext } from 'react';
import { Text, View, StyleSheet, FlatList, ActivityIndicator, TouchableOpacity, TextInput, SafeAreaView, Alert, Modal, Pressable, ScrollView, Dimensions, KeyboardAvoidingView, Platform, Switch, Image, RefreshControl } from 'react-native';
import { NavigationContainer, useFocusEffect, useNavigationState } from '@react-navigation/native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { createMaterialTopTabNavigator } from '@react-navigation/material-top-tabs';
import { createStackNavigator } from '@react-navigation/stack';
import Ionicons from 'react-native-vector-icons/Ionicons';
import { Calendar, LocaleConfig } from 'react-native-calendars';
import MapView, { Marker } from 'react-native-maps';
import DateTimePicker from '@react-native-community/datetimepicker';
import io from 'socket.io-client';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { RENDER_SERVER_URL } from './config';
import { getKoreanToday } from './components/common/Utils';
import RestaurantTab from './screens/RestaurantTab';
import ScheduleDetailModal from './components/schedule/ScheduleDetailModal';

import WriteReview from './screens/WriteReview';
import PhotoGallery from './screens/PhotoGallery';

import MyPageMain from './screens/MyPage/MyPageMain';
import PointsBadgesSection from './screens/MyPage/PointsBadgesSection';
import PointsStatus from './screens/PointsBadges/PointsStatus';
import PointsHistory from './screens/PointsBadges/PointsHistory';
import BadgeCollection from './screens/PointsBadges/BadgeCollection';
import AppointmentHistorySection from './screens/MyPage/AppointmentHistorySection';
import AppointmentDetail from './screens/MyPage/AppointmentDetail';
import ActivityStatsSection from './screens/MyPage/ActivityStatsSection';
import MissionModal from './components/MissionModal';
import ProfileSection from './screens/MyPage/ProfileSection';
import AppInfoSection from './screens/MyPage/AppInfoSection';
import AccountManagement from './screens/ProfileSettings/AccountManagement';
import PrivacySettings from './screens/ProfileSettings/PrivacySettings';
import NotificationSettings from './screens/ProfileSettings/NotificationSettings';

import { ThemeProvider, useTheme } from './contexts/ThemeContext';
import { UserProvider } from './contexts/UserContext';
import { PointsProvider, usePoints } from './contexts/PointsContext';
import { MissionProvider, useMission } from './contexts/MissionContext';
import { AppointmentProvider } from './contexts/AppointmentContext';
import { ScheduleProvider } from './contexts/ScheduleContext';
import dataCleanupManager from './utils/DataCleanupManager';

// ì¸ì¦ ê´€ë ¨
import { AuthProvider, useAuth, AUTH_STATES } from './auth/AuthContext';
import LoginScreen from './auth/LoginScreen';

// --- ì¶”ê°€ í™”ë©´ ì»´í¬ë„ŒíŠ¸ Import ---
import PartyDetailScreen from './screens/Party/PartyDetail/PartyDetailScreen';
import CreatePartyScreen from './screens/Party/CreateParty/CreatePartyScreen';
import CreatePersonalScheduleScreen from './screens/Schedule/CreatePersonalSchedule/CreatePersonalScheduleScreen';

import EditPersonalScheduleScreen from './screens/Schedule/EditPersonalSchedule/EditPersonalScheduleScreen';
import EditPartyScreen from './screens/Party/EditParty/EditPartyScreen';
import RandomLunchScreen from './screens/Party/RandomLunch/RandomLunchScreen';
import IntelligentSchedulingScreen from './screens/Voting/IntelligentScheduling/IntelligentSchedulingScreen';
import SuggestedDatesScreen from './screens/Voting/SuggestedDates/SuggestedDatesScreen';
import RestaurantSelectionScreen from './screens/Voting/RestaurantSelection/RestaurantSelectionScreen';
import TimeSelectionScreen from './screens/Voting/TimeSelection/TimeSelectionScreen';
import PartyConfirmationScreen from './screens/Voting/PartyConfirmation/PartyConfirmationScreen';
import VotingScreen from './screens/Voting/VotingScreen';
import VotingParticipateScreen from './screens/Voting/VotingParticipate/VotingParticipateScreen';
import VotingEditScreen from './screens/Voting/VotingEdit/VotingEditScreen';
import CreateChatRoomScreen from './screens/Chat/CreateChatRoom/CreateChatRoomScreen';
import NotificationScreen from './screens/Notification/NotificationScreen';
import ReviewDetailScreen from './screens/Review/ReviewDetail/ReviewDetailScreen';
import FriendMainScreen from './screens/Friend/FriendMain/FriendMainScreen';
import FriendListScreen from './screens/Friend/FriendList/FriendListScreen';
import SearchUsersScreen from './screens/Friend/SearchUsers/SearchUsersScreen';
import FriendProfileScreen from './screens/Friend/FriendProfile/FriendProfileScreen';
import UserProfileScreen from './screens/profile/UserProfileScreen';
import MyProfileScreen from './screens/MyPage/MyProfile/MyProfileScreen';
import ProfileEditScreen from './screens/MyPage/ProfileEdit/ProfileEditScreen';
import RankingScreen from './screens/RankingScreen';
import LevelSystemScreen from './screens/MyPage/LevelSystemScreen';
import ChallengesScreen from './screens/Challenges/ChallengesScreen';
import FriendInviteScreen from './screens/FriendInvite/FriendInviteScreen';

// API_BASE_URLê³¼ API í˜¸ì¶œ í•¨ìˆ˜ ì •ì˜
const API_BASE_URL = RENDER_SERVER_URL;

// íƒ­ ê°„ ì´ë™ ì‹œ ë„¤ë¹„ê²Œì´ì…˜ ìŠ¤íƒ ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•œ í•¨ìˆ˜
const safeNavigateToTab = (navigation, tabName, screenName, params = {}, skipDefaultScreen = false) => {
    try {
        // navigation ê°ì²´ê°€ ìœ íš¨í•œì§€ í™•ì¸
        if (!navigation || typeof navigation.navigate !== 'function') {
            console.warn('safeNavigateToTab: ìœ íš¨í•˜ì§€ ì•Šì€ navigation ê°ì²´ì…ë‹ˆë‹¤.');
            return false;
        }

        // í•„ìˆ˜ ë§¤ê°œë³€ìˆ˜ í™•ì¸
        if (!tabName) {
            console.warn('safeNavigateToTab: tabNameì´ í•„ìš”í•©ë‹ˆë‹¤.');
            return false;
        }

        // ê° íƒ­ì˜ ê¸°ë³¸ ìŠ¤í¬ë¦° ë§¤í•‘
        const tabDefaultScreens = {
            'í™ˆ': 'HomeScreen',
            'ë§›ì§‘': 'RestaurantsList',
            'íŒŒí‹°': 'PartiesScreen',
            'ì†Œí†µ': 'ChatList',
            'ì¹œêµ¬': 'FriendMain'
        };

        const defaultScreen = tabDefaultScreens[tabName];
        
        if (!defaultScreen || skipDefaultScreen) {
            // ê¸°ë³¸ ìŠ¤í¬ë¦°ì´ ì •ì˜ë˜ì§€ ì•Šê±°ë‚˜ ê±´ë„ˆë›°ê¸° ì˜µì…˜ì´ ìˆëŠ” ê²½ìš° ì§ì ‘ ì´ë™
            try {
                navigation.navigate(tabName, { screen: screenName, params });
                console.log(`âœ… ì§ì ‘ ë„¤ë¹„ê²Œì´ì…˜ ì„±ê³µ: ${tabName} -> ${screenName}`);
                return true;
            } catch (error) {
                console.warn('safeNavigateToTab: ì§ì ‘ ë„¤ë¹„ê²Œì´ì…˜ ì‹¤íŒ¨:', error);
                return false;
            }
        }

        // ì•ˆì „í•œ ë„¤ë¹„ê²Œì´ì…˜ì„ ìœ„í•œ ë‹¨ê³„ë³„ ì²˜ë¦¬
        try {
            // 1ë‹¨ê³„: í•´ë‹¹ íƒ­ì˜ ê¸°ë³¸ ìŠ¤í¬ë¦°ìœ¼ë¡œ ë¨¼ì € ì´ë™ (ìŠ¤íƒ ì´ˆê¸°í™”)
            navigation.navigate(tabName, { screen: defaultScreen });
            console.log(`âœ… 1ë‹¨ê³„ ë„¤ë¹„ê²Œì´ì…˜ ì„±ê³µ: ${tabName} -> ${defaultScreen}`);
            
            // 2ë‹¨ê³„: ì¦‰ì‹œ ì›í•˜ëŠ” ìŠ¤í¬ë¦°ìœ¼ë¡œ ì´ë™ (setTimeout ì œê±°)
            try {
                navigation.navigate(tabName, { screen: screenName, params });
                console.log(`âœ… 2ë‹¨ê³„ ë„¤ë¹„ê²Œì´ì…˜ ì„±ê³µ: ${tabName} -> ${screenName}`);
            } catch (error) {
                console.warn('safeNavigateToTab: 2ë‹¨ê³„ ë„¤ë¹„ê²Œì´ì…˜ ì‹¤íŒ¨:', error);
                // 2ë‹¨ê³„ ì‹¤íŒ¨ ì‹œ fallbackìœ¼ë¡œ ì§ì ‘ ì´ë™ ì‹œë„
                try {
                    navigation.navigate(tabName, { screen: screenName, params });
                    console.log(`âœ… fallback ë„¤ë¹„ê²Œì´ì…˜ ì„±ê³µ: ${tabName} -> ${screenName}`);
                } catch (fallbackError) {
                    console.error('safeNavigateToTab: ëª¨ë“  ë„¤ë¹„ê²Œì´ì…˜ ë°©ë²• ì‹¤íŒ¨:', fallbackError);
                }
            }
            
            return true;
        } catch (error) {
            console.warn('safeNavigateToTab: 1ë‹¨ê³„ ë„¤ë¹„ê²Œì´ì…˜ ì‹¤íŒ¨:', error);
            return false;
        }
    } catch (error) {
        console.error('safeNavigateToTab: ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜:', error);
        return false;
    }
};

// safeNavigateToTab í•¨ìˆ˜ë¥¼ ì „ì—­ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ì„¤ì •
if (typeof global !== 'undefined') {
    global.safeNavigateToTab = safeNavigateToTab;
}

// ìƒˆë¡œìš´ ì¼ì •ì„ ê³µìœ í•˜ê¸° ìœ„í•œ Context ìƒì„±
const NewScheduleContext = createContext();

// Context Provider ì»´í¬ë„ŒíŠ¸
const NewScheduleProvider = ({ children }) => {
    const [newSchedule, setNewSchedule] = useState(null);
    
    const addNewSchedule = useCallback((schedule) => {
        // console.log('ğŸ” [Context] ìƒˆë¡œìš´ ì¼ì • ì¶”ê°€:', schedule);
        setNewSchedule(schedule);
    }, []);
    
    const clearNewSchedule = useCallback(() => {
        // console.log('ğŸ” [Context] ìƒˆë¡œìš´ ì¼ì • ì´ˆê¸°í™”');
        setNewSchedule(null);
    }, []);
    
    return (
        <NewScheduleContext.Provider value={{ newSchedule, addNewSchedule, clearNewSchedule }}>
            {children}
        </NewScheduleContext.Provider>
    );
};

// Context ì‚¬ìš©ì„ ìœ„í•œ Hook
const useNewSchedule = () => {
    const context = useContext(NewScheduleContext);
    if (!context) {
        throw new Error('useNewSchedule must be used within a NewScheduleProvider');
    }
    return context;
};

// --- ì‹¤ì‹œê°„ ì•Œë¦¼ ê´€ë¦¬ í•¨ìˆ˜ë“¤ ---
const addNotification = (setNotifications, setUnreadCount, type, message, data = {}) => {
    const newNotification = {
        id: Date.now(),
        type,
        message,
        data,
        timestamp: new Date(),
        read: false
    };
    setNotifications(prev => [newNotification, ...prev]);
    setUnreadCount(prev => prev + 1);
};

const markNotificationAsRead = (setNotifications, setUnreadCount, notificationId) => {
    setNotifications(prev => 
        prev.map(notif => 
            notif.id === notificationId ? { ...notif, read: true } : notif
        )
    );
    setUnreadCount(prev => Math.max(0, prev - 1));
};

const Tab = createBottomTabNavigator();
const Stack = createStackNavigator();
const TopTab = createMaterialTopTabNavigator();
const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');

// --- ê¸°ë³¸ ìŠ¤íƒ€ì¼ (ì„ì‹œ) ---
const basicStyles = StyleSheet.create({
    centeredView: { 
        flex: 1, 
        justifyContent: 'center', 
        alignItems: 'center', 
        backgroundColor: 'rgba(0,0,0,0.6)' 
    },
    modalView: { 
        margin: 20, 
        backgroundColor: 'white', 
        borderRadius: 24, 
        padding: 30, 
        alignItems: 'center', 
        width: '90%', 
        maxWidth: 400,
        shadowColor: '#000', 
        shadowOffset: { width: 0, height: 8 }, 
        shadowOpacity: 0.3, 
        shadowRadius: 12, 
        elevation: 8 
    },
    modalTitle: { 
        fontSize: 24, 
        fontWeight: 'bold', 
        marginBottom: 28, 
        textAlign: 'center', 
        color: '#3B82F6', 
        letterSpacing: 0.5,
        lineHeight: 32
    },
    button: { 
        borderRadius: 16, 
        padding: 16, 
        elevation: 3, 
        width: '100%', 
        marginTop: 12,
        shadowColor: '#3B82F6',
        shadowOffset: { width: 0, height: 2 }, 
        shadowOpacity: 0.2, 
        shadowRadius: 4
    },
    buttonClose: { backgroundColor: '#E2E8F0' },
    textStyle: { color: 'white', fontWeight: 'bold', textAlign: 'center', fontSize: 16 },
    textStyleBlack: { color: 'black', fontWeight: 'bold', textAlign: 'center', fontSize: 16 },
    optionButton: { padding: 12, marginVertical: 4, borderRadius: 8, backgroundColor: '#F1F5F9' },
    optionButtonSelected: { backgroundColor: '#3B82F6' },
    optionButtonText: { fontSize: 16, color: '#1E293B' },
    optionButtonTextSelected: { color: 'white' },
    scrollerContainer: { height: 200, alignItems: 'center' },
    scroller: { width: 100 },
    scrollerItem: { height: 50, justifyContent: 'center', alignItems: 'center' },
    scrollerItemText: { fontSize: 18, fontWeight: 'bold' },
    scrollerIndicator: { position: 'absolute', top: 75, left: 0, right: 0, height: 50, backgroundColor: 'rgba(59, 130, 246, 0.1)', borderRadius: 8 }
});

// --- í™ˆ íƒ­ ì§ì ‘ ì—…ë°ì´íŠ¸ í•¨ìˆ˜ (ì»´í¬ë„ŒíŠ¸ ë‚´ë¶€ë¡œ ì´ë™ë¨) ---

// --- í…Œë§ˆ ê´€ë¦¬ í•¨ìˆ˜ ---

const COLORS = {
    // ë¼ì´íŠ¸ ëª¨ë“œ
    light: {
        primary: '#3B82F6',      // íŒŒë€ìƒ‰ (ë©”ì¸ ì»¬ëŸ¬)
        primaryLight: 'rgba(59, 130, 246, 0.1)',
        secondary: '#10B981',    // ì—ë©”ë„ë“œ (ê°•ì¡°/íŒŒí‹°ìƒì„±)
        accent: '#8B5CF6',       // ë³´ë¼ (ì„±ê³µ/í™•ì¸)
        background: '#F1F5F9',   // ì—°í•œ ë¸”ë£¨ ê·¸ë ˆì´
        surface: '#FFFFFF',
        text: '#1E293B',
        textSecondary: '#64748B',
        border: '#E2E8F0',
        gray: '#64748B',
        lightGray: '#E2E8F0',
        red: '#EF4444',
        disabled: '#CBD5E0',
        blue: '#3B82F6',         // íŒŒë€ìƒ‰ (ë©”ì¸)
        indigo: '#6366F1',       // ì¸ë””ê³  (ë‹¨ê³¨íŒŒí‹°)
        cyan: '#06B6D4',         // ì‹œì•ˆ (ë§›ì§‘)
        deepBlue: '#1D5D9B',      // ì§„í•œ íŒŒë€ìƒ‰
        skyBlue: '#75C2F6',       // ì—°í•œ íŒŒë€ìƒ‰
        yellow: '#F4D160',        // ë°ì€ ë…¸ë€ìƒ‰
        paleYellow: '#FBEEAC',     // ì—°í•œ ë…¸ë€ìƒ‰
        white: '#FFFFFF',         // í°ìƒ‰
    },
    // ë‹¤í¬ ëª¨ë“œ
    dark: {
        primary: '#60A5FA',      // ë°ì€ íŒŒë€ìƒ‰
        primaryLight: 'rgba(96, 165, 250, 0.1)',
        secondary: '#34D399',    // ë°ì€ ì—ë©”ë„ë“œ
        accent: '#A78BFA',       // ë°ì€ ë³´ë¼
        background: '#0F172A',   // ì§„í•œ ë„¤ì´ë¹„
        surface: '#1E293B',      // ì–´ë‘ìš´ ê·¸ë ˆì´
        text: '#F8FAFC',         // ë°ì€ í…ìŠ¤íŠ¸
        textSecondary: '#94A3B8', // íšŒìƒ‰ í…ìŠ¤íŠ¸
        border: '#334155',       // ì–´ë‘ìš´ ë³´ë”
        gray: '#94A3B8',
        lightGray: '#334155',
        red: '#F87171',
        disabled: '#475569',
        blue: '#60A5FA',
        indigo: '#818CF8',
        cyan: '#22D3EE',
        deepBlue: '#3B82F6',
        skyBlue: '#7DD3FC',
        yellow: '#FCD34D',
        paleYellow: '#FEF3C7',
        white: '#FFFFFF',         // í°ìƒ‰
    }
};



LocaleConfig.locales['ko'] = { monthNames: ['1ì›”', '2ì›”', '3ì›”', '4ì›”', '5ì›”', '6ì›”', '7ì›”', '8ì›”', '9ì›”', '10ì›”', '11ì›”', '12ì›”'], monthNamesShort: ['1.', '2.', '3.', '4.', '5.', '6.', '7.', '8.', '9.', '10.', '11.', '12.'], dayNames: ['ì¼ìš”ì¼', 'ì›”ìš”ì¼', 'í™”ìš”ì¼', 'ìˆ˜ìš”ì¼', 'ëª©ìš”ì¼', 'ê¸ˆìš”ì¼', 'í† ìš”ì¼'], dayNamesShort: ['ì¼', 'ì›”', 'í™”', 'ìˆ˜', 'ëª©', 'ê¸ˆ', 'í† '], today: 'ì˜¤ëŠ˜' };
LocaleConfig.defaultLocale = 'ko';

// --- ì¬ì‚¬ìš© ì»´í¬ë„ŒíŠ¸ ---
const SelectionModal = ({ visible, title, options, selected, onSelect, onClose, isMultiSelect = false, styles = basicStyles, colors }) => {
    const handleSelect = (item) => {
        if (isMultiSelect) {
            let newSelected = [...selected];
            if (newSelected.includes(item)) {
                newSelected = newSelected.filter(i => i !== item);
            } else if (newSelected.length < 3) {
                newSelected.push(item);
            } else {
                Alert.alert("ì„ íƒ ì œí•œ", "ìµœëŒ€ 3ê°œê¹Œì§€ ì„ íƒí•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
            }
            onSelect(newSelected);
        } else {
            onSelect(item);
            onClose();
        }
    };
    return (
        <Modal visible={visible} transparent={true} animationType="fade" onRequestClose={onClose}>
            <Pressable style={styles.centeredView} onPress={onClose}>
                <Pressable style={styles.modalView}>
                    <Text style={styles.modalTitle}>{title}</Text>
                    <ScrollView 
                        style={{width: '100%', maxHeight: 300}}
                        showsVerticalScrollIndicator={false}
                        contentContainerStyle={{paddingBottom: 10}}
                    >
                        {options.map(item => (
                            <TouchableOpacity key={item} style={[styles.optionButton, (isMultiSelect ? selected.includes(item) : selected === item) && styles.optionButtonSelected]} onPress={() => handleSelect(item)}>
                                <Text style={[styles.optionButtonText, (isMultiSelect ? selected.includes(item) : selected === item) && styles.optionButtonTextSelected]}>{item}</Text>
                            </TouchableOpacity>
                        ))}
                    </ScrollView>
                    {isMultiSelect && <Pressable style={[styles.button, styles.buttonClose]} onPress={onClose}><Text style={styles.textStyleBlack}>ì„ íƒ ì™„ë£Œ</Text></Pressable>}
                </Pressable>
            </Pressable>
        </Modal>
    );
};

const NumberScroller = ({ onSelect, initialValue = 4, styles = basicStyles }) => {
    const numbers = Array.from({ length: 9 }, (_, i) => i + 2); // 2 to 10
    const scrollViewRef = useRef(null);

    useEffect(() => {
        const initialIndex = numbers.indexOf(initialValue);
        if (initialIndex !== -1 && scrollViewRef.current) {
            setTimeout(() => scrollViewRef.current.scrollTo({ y: initialIndex * 50, animated: false }), 100);
        }
    }, [initialValue]);

    return (
        <View style={styles.scrollerContainer}>
            <ScrollView
                ref={scrollViewRef}
                style={styles.scroller}
                onMomentumScrollEnd={(event) => {
                    const index = Math.round(event.nativeEvent.contentOffset.y / 50);
                    onSelect(numbers[index]);
                }}
                snapToInterval={50}
                showsVerticalScrollIndicator={false}
                decelerationRate="fast"
            >
                {numbers.map(num => (
                    <View key={num} style={styles.scrollerItem}>
                        <Text style={styles.scrollerItemText}>{num}ëª…</Text>
                    </View>
                ))}
            </ScrollView>
            <View style={styles.scrollerIndicator} />
        </View>
    );
};

function parseRecipientIds(recipientIds) {
  // ë¹ˆ ë¬¸ìì—´ì´ë©´ ë¹ˆ ë°°ì—´ ë°˜í™˜
  if (!recipientIds || recipientIds.trim() === '') {
    return [];
  }
  
  // ì—°ì†ëœ ì‰¼í‘œë¥¼ í•˜ë‚˜ë¡œ ì¹˜í™˜í•˜ê³ , ì•ë’¤ ê³µë°± ì œê±°
  const cleanedIds = recipientIds.replace(/,,+/g, ',').trim();
  
  // ì‰¼í‘œë¡œ ë¶„ë¦¬í•˜ê³  ë¹ˆ ë¬¸ìì—´ ì œê±°
  const ids = cleanedIds
    .split(',')
    .map(id => id.trim())
    .filter(id => id.length > 0);
  
  // ë§Œì•½ ê° IDê°€ í•œ ê¸€ìì”©ì´ë¼ë©´ (ì˜ˆ: "K,O,I,C,A,0,0,2"), ì˜¬ë°”ë¥¸ í˜•íƒœë¡œ ì¡°í•©
  if (ids.length > 0 && ids[0].length === 1) {
    const combinedIds = [];
    let currentId = '';
    
    for (let i = 0; i < ids.length; i++) {
      currentId += ids[i];
      // 8ê¸€ìê°€ ë˜ë©´ í•˜ë‚˜ì˜ IDë¡œ ê°„ì£¼ (KOICA002 í˜•íƒœ)
      if (currentId.length === 8) {
        combinedIds.push(currentId);
        currentId = '';
      }
    }
    
    // ë‚¨ì€ ê¸€ìë“¤ë„ IDë¡œ ì¶”ê°€ (8ê¸€ìê°€ ì•ˆ ë˜ë”ë¼ë„)
    if (currentId.length > 0) {
      combinedIds.push(currentId);
    }
    
    return combinedIds;
  }
  
  return ids;
}
// ë‚ ì§œë¥¼ YYYY-MM-DD(ë¡œì»¬)ë¡œ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜
function toLocalDateString(date) {
  const pad = n => n.toString().padStart(2, '0');
  const result = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;
  

  return result;
}

// ê°€ì¥ ê°€ê¹Œìš´ í‰ì¼ì„ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜
function getNextWeekday(date) {
  const day = date.getDay();
  if (day === 0) { // ì¼ìš”ì¼
    date.setDate(date.getDate() + 1); // ì›”ìš”ì¼ë¡œ
  } else if (day === 6) { // í† ìš”ì¼
    date.setDate(date.getDate() + 2); // ì›”ìš”ì¼ë¡œ
  }
  return date;
}

// í•œêµ­ ì‹œê°„ ê¸°ì¤€ìœ¼ë¡œ ë‚ ì§œë¥¼ YYYY-MM-DD í˜•ì‹ìœ¼ë¡œ ë³€í™˜í•˜ëŠ” í•¨ìˆ˜
function toKoreanDateString(date) {
  // í•œêµ­ ì‹œê°„ëŒ€ (UTC+9) ê³ ë ¤
  const koreanTime = new Date(date.getTime() + (9 * 60 * 60 * 1000));
  const year = koreanTime.getFullYear();
  const month = String(koreanTime.getMonth() + 1).padStart(2, '0');
  const day = String(koreanTime.getDate()).padStart(2, '0');
  const result = `${year}-${month}-${day}`;
  

  return result;
}


// --- í™ˆ íƒ­ ---
function HomeScreen({ navigation, route }) {
    const [todayMenu, setTodayMenu] = useState([]);
    const [appointments, setAppointments] = useState([]);
    const [markedDates, setMarkedDates] = useState({});
    const [allEvents, setAllEvents] = useState(() => {
        // console.log('ğŸ” [App] allEvents ìƒíƒœ ì´ˆê¸°í™”');
        return {};
    });
    
    // ğŸš¨ ì¤‘ìš”: allEvents ìƒíƒœì— ì•ˆì „í•˜ê²Œ ì ‘ê·¼í•˜ëŠ” í—¬í¼ í•¨ìˆ˜
    const getSafeAllEvents = useCallback(() => {
        if (!allEvents || typeof allEvents !== 'object') {
            // console.log('ğŸ” [App] allEvents ìƒíƒœ ì•ˆì „ ì ‘ê·¼ - ì´ˆê¸°í™” ì¤‘:', allEvents);
            return {};
        }
        return allEvents;
    }, [allEvents]);
    
    // ğŸš¨ ì¤‘ìš”: íŠ¹ì • ë‚ ì§œì˜ ì´ë²¤íŠ¸ë¥¼ ì•ˆì „í•˜ê²Œ ê°€ì ¸ì˜¤ëŠ” í—¬í¼ í•¨ìˆ˜
    const getSafeEventsForDate = useCallback((dateString) => {
        const safeAllEvents = getSafeAllEvents();
        const events = safeAllEvents[dateString] || [];
        return Array.isArray(events) ? events.filter(event => event && typeof event === 'object') : [];
    }, [getSafeAllEvents]);
    
    // ğŸš¨ ì¤‘ìš”: ê¸°ì¡´ ì´ë²¤íŠ¸ ë°°ì—´ì„ ì•ˆì „í•˜ê²Œ ê²€ì¦í•˜ëŠ” í—¬í¼ í•¨ìˆ˜
    const getSafeValidEvents = useCallback((existingEvents) => {
        if (!existingEvents || !Array.isArray(existingEvents)) {
            return [];
        }
        
        const filteredEvents = existingEvents.filter(event => event && typeof event === 'object');
        return filteredEvents;
    }, []);
    const [modalData, setModalData] = useState({ visible: false, events: [] });
    
    // ğŸš¨ ì¤‘ìš”: ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€ë¥¼ ìœ„í•œ ref
    const isProcessingSchedule = useRef(false);
    
    // ğŸš¨ ì¤‘ìš”: Context APIì™€ ì—°ë™í•˜ëŠ” updateHomeSchedule í•¨ìˆ˜
    const { updateScheduleUnified, schedules } = useSchedule();
    
    // Context ìƒíƒœì™€ ë¡œì»¬ ìƒíƒœ ë™ê¸°í™”
    useEffect(() => {
        console.log('ğŸ” [HomeScreen] Context ìƒíƒœ ë™ê¸°í™” ì‹œì‘');
        
        // appointments ë™ê¸°í™”
        if (schedules.appointments && schedules.appointments.length > 0) {
            setAppointments(schedules.appointments);
            console.log('ğŸ” [HomeScreen] appointments Context ë™ê¸°í™”:', schedules.appointments.length, 'ê°œ');
        }
        
        // markedDates ë™ê¸°í™”
        if (schedules.markedDates && Object.keys(schedules.markedDates).length > 0) {
            setMarkedDates(schedules.markedDates);
            console.log('ğŸ” [HomeScreen] markedDates Context ë™ê¸°í™”:', Object.keys(schedules.markedDates).length, 'ê°œ');
        }
        
        // allEvents ë™ê¸°í™”
        if (schedules.allEvents && Object.keys(schedules.allEvents).length > 0) {
            setAllEvents(schedules.allEvents);
            console.log('ğŸ” [HomeScreen] allEvents Context ë™ê¸°í™”:', Object.keys(schedules.allEvents).length, 'ê°œ');
        }
    }, [schedules]);
    
    const updateHomeSchedule = useCallback((eventData, action) => {
        console.log('ğŸ”„ [í™ˆíƒ­] ì¼ì • ë™ê¸°í™”:', action, eventData);
        
        // Context APIë¥¼ í†µí•œ í†µí•© ì—…ë°ì´íŠ¸
        updateScheduleUnified(eventData, action, 'personal');
        
        // ğŸš¨ ë””ë²„ê¹…: í˜„ì¬ ìƒíƒœ ë¡œê¹…
        console.log('ğŸ” [updateHomeSchedule] í˜„ì¬ ìƒíƒœ:', {
            appointmentsCount: appointments.length,
            markedDatesKeys: Object.keys(markedDates),
            allEventsKeys: Object.keys(allEvents)
        });
        
        // ë¡œì»¬ ìƒíƒœë„ ë™ê¸°í™” (ê¸°ì¡´ ë¡œì§ ìœ ì§€)
        if (action === 'add' || action === 'update') {
            // ìƒˆë¡œìš´ ì¼ì • ì¶”ê°€ ë˜ëŠ” ê¸°ì¡´ ì¼ì • ì—…ë°ì´íŠ¸
            const eventDate = eventData.party_date || eventData.date;
            
            // allEvents ìƒíƒœ ì—…ë°ì´íŠ¸
            setAllEvents(prev => {
                const newAllEvents = { ...prev };
                
                if (!newAllEvents[eventDate]) {
                    newAllEvents[eventDate] = [];
                }
                
                // ê¸°ì¡´ ì¼ì •ì´ ìˆëŠ”ì§€ í™•ì¸í•˜ê³  ì—…ë°ì´íŠ¸
                const existingIndex = newAllEvents[eventDate].findIndex(
                    event => event.id === eventData.id || event._id === eventData.id
                );
                
                if (existingIndex >= 0) {
                    newAllEvents[eventDate][existingIndex] = eventData;
                    console.log('ğŸ” [updateHomeSchedule] allEvents ì—…ë°ì´íŠ¸:', eventDate, 'ì´ë²¤íŠ¸ ìˆ˜:', newAllEvents[eventDate].length);
                } else {
                    newAllEvents[eventDate].push(eventData);
                    console.log('ğŸ” [updateHomeSchedule] allEvents ìƒˆ ì¼ì • ì¶”ê°€:', eventDate, 'ì´ë²¤íŠ¸ ìˆ˜:', newAllEvents[eventDate].length);
                }
                
                return newAllEvents;
            });
            
            // appointments ìƒíƒœ ì—…ë°ì´íŠ¸
            setAppointments(prev => {
                const existingIndex = prev.findIndex(app => app.id === eventData.id || app._id === eventData.id);
                if (existingIndex >= 0) {
                    const newAppointments = [...prev];
                    newAppointments[existingIndex] = eventData;
                    console.log('ğŸ” [updateHomeSchedule] appointments ì—…ë°ì´íŠ¸:', eventDate);
                    return newAppointments;
                } else {
                    console.log('ğŸ” [updateHomeSchedule] appointments ìƒˆ ì¼ì • ì¶”ê°€:', eventDate);
                    return [...prev, eventData];
                }
            });
            
            // markedDates ìƒíƒœ ì—…ë°ì´íŠ¸
            setMarkedDates(prev => {
                const newMarkedDates = { ...prev };
                newMarkedDates[eventDate] = {
                    selected: true,
                    selectedColor: '#64748B' // ê¸°íƒ€ ì¼ì • ìƒ‰ìƒ
                };
                console.log('ğŸ” [updateHomeSchedule] markedDates ì—…ë°ì´íŠ¸:', eventDate);
                return newMarkedDates;
            });
            
        } else if (action === 'remove' || action === 'delete') {
            // ì¼ì • ì œê±°
            const eventDate = eventData.party_date || eventData.date;
            const eventId = eventData.id || eventData._id;
            
            console.log('ğŸ” [updateHomeSchedule] ì¼ì • ì‚­ì œ ì‹œì‘:', { eventId, eventDate });
            
            // allEvents ìƒíƒœì—ì„œ ì œê±°
            setAllEvents(prev => {
                const newAllEvents = { ...prev };
                
                if (newAllEvents[eventDate]) {
                    const oldEventCount = newAllEvents[eventDate].length;
                    newAllEvents[eventDate] = newAllEvents[eventDate].filter(
                        event => event.id !== eventId && event._id !== eventId
                    );
                    
                    console.log('ğŸ” [updateHomeSchedule] allEvents ì‚­ì œ:', eventDate, 'ì´ë²¤íŠ¸ ìˆ˜:', oldEventCount, '->', newAllEvents[eventDate].length);
                    
                    // í•´ë‹¹ ë‚ ì§œì— ì¼ì •ì´ ì—†ìœ¼ë©´ ë‚ ì§œ ìì²´ë„ ì œê±°
                    if (newAllEvents[eventDate].length === 0) {
                        delete newAllEvents[eventDate];
                        console.log('ğŸ” [updateHomeSchedule] allEventsì—ì„œ ë¹ˆ ë‚ ì§œ ì œê±°:', eventDate);
                    }
                }
                
                return newAllEvents;
            });
            
            // appointments ìƒíƒœì—ì„œë„ ì œê±°
            setAppointments(prev => {
                const newAppointments = prev.filter(app => app.id !== eventId && app._id !== eventId);
                console.log('ğŸ” [updateHomeSchedule] appointments ì‚­ì œ:', 'ì´ë²¤íŠ¸ ìˆ˜:', prev.length, '->', newAppointments.length);
                return newAppointments;
            });
            
            // markedDatesì—ì„œë„ ì œê±° (í•´ë‹¹ ë‚ ì§œì— ë‹¤ë¥¸ ì¼ì •ì´ ì—†ëŠ” ê²½ìš°)
            setMarkedDates(prev => {
                const newMarkedDates = { ...prev };
                
                // í•´ë‹¹ ë‚ ì§œì— ë‹¤ë¥¸ ì¼ì •ì´ ìˆëŠ”ì§€ í™•ì¸
                const hasOtherEvents = appointments.some(app => 
                    app.date === eventDate && app.id !== eventId && app._id !== eventId
                );
                
                if (!hasOtherEvents) {
                    delete newMarkedDates[eventDate];
                    console.log('ğŸ” [updateHomeSchedule] markedDatesì—ì„œ ë‚ ì§œ ì œê±°:', eventDate);
                }
                
                return newMarkedDates;
            });
        }
        
        // ğŸš¨ ë””ë²„ê¹…: ìƒíƒœ ë³€ê²½ í›„ ìµœì¢… í™•ì¸
        setTimeout(() => {
            console.log('ğŸ” [updateHomeSchedule] ìƒíƒœ ë³€ê²½ í›„ ìµœì¢… í™•ì¸:', {
                action,
                eventId: eventData.id || eventData._id,
                eventDate: eventData.party_date || eventData.date
            });
        }, 100);
        
        console.log('âœ… [updateHomeSchedule]', action, 'ì™„ë£Œ');
    }, [appointments, markedDates, allEvents, updateScheduleUnified]);
    
    // ì „ì—­ í•¨ìˆ˜ ë“±ë¡ (ë‹¤ë¥¸ í™”ë©´ì—ì„œ ì‚¬ìš©)
    useEffect(() => {
        global.updateHomeSchedule = updateHomeSchedule;
        return () => {
            global.updateHomeSchedule = undefined;
        };
    }, [updateHomeSchedule]);
    
    // ğŸš¨ ë””ë²„ê¹…: ìƒíƒœ ë³€ê²½ ëª¨ë‹ˆí„°ë§
    useEffect(() => {
        console.log('ğŸ” [HomeScreen] appointments ìƒíƒœ ë³€ê²½:', {
            count: appointments.length,
            dates: appointments.map(item => ({ date: item.date, eventCount: item.events?.length || 0 }))
        });
    }, [appointments]);
    
    useEffect(() => {
        console.log('ğŸ” [HomeScreen] markedDates ìƒíƒœ ë³€ê²½:', {
            count: Object.keys(markedDates).length,
            dates: Object.keys(markedDates)
        });
    }, [markedDates]);
    
    useEffect(() => {
        console.log('ğŸ” [HomeScreen] allEvents ìƒíƒœ ë³€ê²½:', {
            count: Object.keys(allEvents).length,
            dates: Object.keys(allEvents),
            totalEvents: Object.values(allEvents).reduce((sum, events) => sum + events.length, 0)
        });
    }, [allEvents]);
    
    // ğŸš¨ ë””ë²„ê¹…: ìƒíƒœ ì¼ê´€ì„± ê²€ì¦ í•¨ìˆ˜
    const validateStateConsistency = useCallback(() => {
        console.log('ğŸ” [HomeScreen] ìƒíƒœ ì¼ê´€ì„± ê²€ì¦ ì‹œì‘');
        
        const appointmentsDates = appointments.map(item => item.date);
        const markedDatesKeys = Object.keys(markedDates);
        const allEventsKeys = Object.keys(allEvents);
        
        // 1. appointmentsì™€ markedDates ì¼ì¹˜ í™•ì¸
        const appointmentsMarkedMismatch = appointmentsDates.filter(date => !markedDatesKeys.includes(date));
        const markedAppointmentsMismatch = markedDatesKeys.filter(date => !appointmentsDates.includes(date));
        
        if (appointmentsMarkedMismatch.length > 0) {
            console.warn('âš ï¸ [HomeScreen] appointmentsì—ëŠ” ìˆì§€ë§Œ markedDatesì—ëŠ” ì—†ëŠ” ë‚ ì§œ:', appointmentsMarkedMismatch);
        }
        if (markedAppointmentsMismatch.length > 0) {
            console.warn('âš ï¸ [HomeScreen] markedDatesì—ëŠ” ìˆì§€ë§Œ appointmentsì—ëŠ” ì—†ëŠ” ë‚ ì§œ:', markedAppointmentsMismatch);
        }
        
        // 2. appointmentsì™€ allEvents ì¼ì¹˜ í™•ì¸
        const appointmentsAllEventsMismatch = appointmentsDates.filter(date => !allEventsKeys.includes(date));
        const allEventsAppointmentsMismatch = allEventsKeys.filter(date => !appointmentsDates.includes(date));
        
        if (appointmentsAllEventsMismatch.length > 0) {
            console.warn('âš ï¸ [HomeScreen] appointmentsì—ëŠ” ìˆì§€ë§Œ allEventsì—ëŠ” ì—†ëŠ” ë‚ ì§œ:', appointmentsAllEventsMismatch);
        }
        if (allEventsAppointmentsMismatch.length > 0) {
            console.warn('âš ï¸ [HomeScreen] allEventsì—ëŠ” ìˆì§€ë§Œ appointmentsì—ëŠ” ì—†ëŠ” ë‚ ì§œ:', allEventsAppointmentsMismatch);
        }
        
        // 3. ê° ë‚ ì§œë³„ ì´ë²¤íŠ¸ ìˆ˜ ì¼ì¹˜ í™•ì¸
        appointments.forEach(item => {
            const allEventsCount = allEvents[item.date]?.length || 0;
            const itemEventsCount = item.events?.length || 0;
            if (itemEventsCount !== allEventsCount) {
                console.warn('âš ï¸ [HomeScreen] ë‚ ì§œë³„ ì´ë²¤íŠ¸ ìˆ˜ ë¶ˆì¼ì¹˜:', {
                    date: item.date,
                    appointmentsEvents: itemEventsCount,
                    allEventsCount: allEventsCount
                });
            }
        });
        
        console.log('ğŸ” [HomeScreen] ìƒíƒœ ì¼ê´€ì„± ê²€ì¦ ì™„ë£Œ');
    }, [appointments, markedDates, allEvents]);
    
    // ğŸš¨ ë””ë²„ê¹…: ì£¼ê¸°ì  ìƒíƒœ ê²€ì¦ (ê°œë°œ ëª¨ë“œì—ì„œë§Œ)
    useEffect(() => {
        if (__DEV__) {
            const interval = setInterval(validateStateConsistency, 5000); // 5ì´ˆë§ˆë‹¤ ê²€ì¦
            return () => clearInterval(interval);
        }
    }, [validateStateConsistency]);
    
    // ğŸš¨ ì¤‘ìš”: AsyncStorageë¥¼ ì‚¬ìš©í•œ ì¼ì • ë°ì´í„° ì˜êµ¬ ì €ì¥ ì‹œìŠ¤í…œ
    const saveAppointmentsToStorage = async (appointmentsData, markedDatesData, allEventsData) => {
        try {
            await AsyncStorage.setItem('@home_appointments', JSON.stringify(appointmentsData));
            await AsyncStorage.setItem('@home_markedDates', JSON.stringify(markedDatesData));
            await AsyncStorage.setItem('@home_allEvents', JSON.stringify(allEventsData));
    
        } catch (error) {
            console.error('ğŸ” [ë¡œì»¬ì €ì¥] ì¼ì • ë°ì´í„° ì €ì¥ ì‹¤íŒ¨:', error);
        }
    };
    
    const loadAppointmentsFromStorage = async () => {
        try {
            const appointmentsData = await AsyncStorage.getItem('@home_appointments');
            const markedDatesData = await AsyncStorage.getItem('@home_markedDates');
            const allEventsData = await AsyncStorage.getItem('@home_allEvents');
            
            if (appointmentsData && markedDatesData && allEventsData) {
                const parsedAppointments = JSON.parse(appointmentsData);
                const parsedMarkedDates = JSON.parse(markedDatesData);
                const parsedAllEvents = JSON.parse(allEventsData);
                
                setAppointments(parsedAppointments);
                setMarkedDates(parsedMarkedDates);
                setAllEvents(parsedAllEvents);
                
                // Contextì—ë„ ì´ˆê¸° ë°ì´í„° ì„¤ì •
                if (setInitialData) {
                    setInitialData({
                        appointments: parsedAppointments,
                        markedDates: parsedMarkedDates,
                        allEvents: parsedAllEvents,
                        parties: [],
                        randomLunches: []
                    });
                    console.log('ğŸ” [fetchHomeData] Context ì´ˆê¸° ë°ì´í„° ì„¤ì • ì™„ë£Œ');
                }
                
                // ì „ì—­ ë°±ì—…ì—ë„ ì €ì¥
                global.backupAppointments = parsedAppointments;
                global.backupMarkedDates = parsedMarkedDates;
                global.backupAllEvents = parsedAllEvents;
                
                return true;
            }
            return false;
        } catch (error) {
            console.error('ğŸ” [ë¡œì»¬ì €ì¥] ì¼ì • ë°ì´í„° ë³µì› ì‹¤íŒ¨:', error);
            return false;
        }
    };
    

    const [unreadCount, setUnreadCount] = useState(0);
    const [currentUser, setCurrentUser] = useState(null);
    const [missionModalVisible, setMissionModalVisible] = useState(false);

    
    // MissionContextì—ì„œ ë¯¸ì…˜ ìƒíƒœë¥¼ ì§ì ‘ í™•ì¸í•˜ì—¬ í—¤ë”ì˜ ë¹¨ê°„ ì  í‘œì‹œ
    const { getTabMissionProgress, missionProgress } = useMission();
    
    // ë¯¸ì…˜ ì§„í–‰ë„ ë³€í™”ì— ë”°ë¼ í—¤ë”ì˜ ë¹¨ê°„ ì  ìƒíƒœ ê³„ì‚° (route.params ì‚¬ìš©í•˜ì§€ ì•ŠìŒ)
    const hasUnclaimedMissions = useMemo(() => {
        if (!missionProgress) return false;
        
        const dailyProgress = getTabMissionProgress('daily');
        const weeklyProgress = getTabMissionProgress('weekly');
        const monthlyProgress = getTabMissionProgress('monthly');
        
        return (
            Object.values(dailyProgress || {}).some(m => m.completed && !m.claimed) ||
            Object.values(weeklyProgress || {}).some(m => m.completed && !m.claimed) ||
            Object.values(monthlyProgress || {}).some(m => m.completed && !m.claimed)
        );
    }, [missionProgress, getTabMissionProgress]);
    

    
        // ì‚¬ìš©ì ì •ë³´ ì´ˆê¸°í™”
    useEffect(() => {
        const initUser = async () => {
            await userManager.initialize();
            setCurrentUser(userManager.getCurrentUser());
        };
        initUser();
    }, []);
    
    // hasUnclaimedMissions ìƒíƒœë¥¼ route.paramsì— ì„¤ì •í•˜ì—¬ í—¤ë”ì˜ ë¹¨ê°„ ì  í‘œì‹œ
    useEffect(() => {
        navigation.setParams({ hasUnclaimedMissions });
    }, [hasUnclaimedMissions, navigation]);
    
    // hasUnclaimedMissions ìƒíƒœë¥¼ route.paramsì— ì„¤ì •í•˜ì—¬ í—¤ë”ì˜ ë¹¨ê°„ ì  í‘œì‹œ
    useEffect(() => {
        navigation.setParams({ hasUnclaimedMissions });
    }, [hasUnclaimedMissions, navigation]);



    // route.paramsì—ì„œ ë¯¸ì…˜ ëª¨ë‹¬ ì—´ê¸° ìš”ì²­ í™•ì¸
    useEffect(() => {
        if (route.params?.openMissionModal) {
            setMissionModalVisible(true);
            // íŒŒë¼ë¯¸í„° ì´ˆê¸°í™”
            navigation.setParams({ openMissionModal: undefined });
        }
    }, [route.params?.openMissionModal]);
    

    
    // route.paramsì—ì„œ ì¹œêµ¬ì™€ í•¨ê»˜ ì‹ì‚¬í•˜ê¸° íŒì—… ì—´ê¸° ìš”ì²­ í™•ì¸
    useEffect(() => {
        if (route.params?.showFriendLunchModal) {
            // ì¹œêµ¬ì™€ í•¨ê»˜ ì‹ì‚¬í•˜ê¸° íŒì—…ì„ ë³´ì—¬ì£¼ëŠ” ë¡œì§
            // í”Œë¡œíŒ…ë²„íŠ¼ì„ ëˆ„ë¥¸ ê²ƒì²˜ëŸ¼ ì ì‹¬ ì•½ì† ì¶”ê°€ ëª¨ë‹¬ì„ ì—´ê¸°
            const today = toLocalDateString(new Date());
            setModalData({ visible: true, events: [], date: today });
            // íŒŒë¼ë¯¸í„° ì´ˆê¸°í™”
            navigation.setParams({ showFriendLunchModal: undefined });
        }
    }, [route.params?.showFriendLunchModal, navigation]);

    // ğŸš¨ ì¤‘ìš”: route.paramsì—ì„œ ì¼ì • ëª¨ë‹¬ í‘œì‹œ ìš”ì²­ í™•ì¸
    useEffect(() => {
        if (route.params?.showScheduleModal && route.params?.scheduleDate && route.params?.scheduleEvent) {

            
            // í•´ë‹¹ ë‚ ì§œì˜ ì¼ì •ì„ ì°¾ì•„ì„œ ëª¨ë‹¬ì— í‘œì‹œ
            const targetDate = route.params.scheduleDate;
            const targetEvent = route.params.scheduleEvent;
            
            // allEventsì—ì„œ í•´ë‹¹ ë‚ ì§œì˜ ì¼ì •ë“¤ì„ ì°¾ê¸°
            const eventsForDate = getSafeEventsForDate(targetDate);
            
            if (eventsForDate.length > 0) {
                // í•´ë‹¹ ì¼ì •ì´ í¬í•¨ëœ ë‚ ì§œì˜ ëª¨ë“  ì¼ì •ì„ ëª¨ë‹¬ì— í‘œì‹œ
                setModalData({ 
                    visible: true, 
                    events: eventsForDate, 
                    date: targetDate 
                });
            } else {
                // í•´ë‹¹ ë‚ ì§œì— ì¼ì •ì´ ì—†ìœ¼ë©´ ë‹¨ì¼ ì¼ì •ìœ¼ë¡œ ëª¨ë‹¬ í‘œì‹œ
                setModalData({ 
                    visible: true, 
                    events: [targetEvent], 
                    date: targetDate 
                });
            }
            
            // ëª¨ë‹¬ì„ ì—´ê³  ë‚˜ë©´ route.params ì´ˆê¸°í™”
            navigation.setParams({ 
                showScheduleModal: undefined, 
                scheduleDate: undefined, 
                scheduleEvent: undefined 
            });
        }
    }, [route.params?.showScheduleModal, route.params?.scheduleDate, route.params?.scheduleEvent, navigation]);

    const fetchHomeData = useCallback((backupAppointments = null, backupMarkedDates = null, backupAllEvents = null) => {
        // ë””ë²„ê·¸ ë¡œê·¸ ì œê±°
        // ë””ë²„ê·¸ ë¡œê·¸ ì œê±°
        // ë””ë²„ê·¸ ë¡œê·¸ ì œê±°
        
        // ğŸš¨ ì¤‘ìš”: API í˜¸ì¶œê³¼ ê´€ê³„ì—†ì´ í•­ìƒ 7ì¼ê°„ ì¹´ë“œ ìƒì„± ë³´ì¥!
        const today = getKoreanToday(); // í•œêµ­ ì‹œê°„ ê¸°ì¤€ìœ¼ë¡œ ì˜¤ëŠ˜ ë‚ ì§œ ê°€ì ¸ì˜¤ê¸°
        
        // Context ì´ˆê¸° ë°ì´í„° ì„¤ì •
        const { setInitialData } = useSchedule();
        
        // ğŸ¯ ì „ì—­ ë³€ìˆ˜ì— ì •í™•í•œ ì˜¤ëŠ˜ ë‚ ì§œ ì €ì¥ (í”Œë¡œíŒ… ë²„íŠ¼ì—ì„œ ì‚¬ìš©)
        // toLocalDateString() ì‚¬ìš©í•˜ì§€ ì•Šê³  ì§ì ‘ ë‚ ì§œ ë¬¸ìì—´ ìƒì„±
        const year = today.getUTCFullYear();
        const month = String(today.getUTCMonth() + 1).padStart(2, '0');
        const date = String(today.getUTCDate()).padStart(2, '0');
        global.homeTodayDate = `${year}-${month}-${date}`;
        
        // ğŸ¯ ê°•ì œë¡œ 7ì¼ê°„ ì¹´ë“œ ìƒì„± (API ì‘ë‹µê³¼ ë…ë¦½ì )
        const forceUpcoming = [];
        for (let i = 0; i < 7; i++) {
            // UTC ê¸°ì¤€ìœ¼ë¡œ ë‚ ì§œ ê³„ì‚° (ë¡œì»¬ ì‹œê°„ëŒ€ ë³€í™˜ ë¬¸ì œ í•´ê²°)
            const utcYear = today.getUTCFullYear();
            const utcMonth = today.getUTCMonth();
            const utcDate = today.getUTCDate() + i;
            
            // UTC ê¸°ì¤€ìœ¼ë¡œ ë‚ ì§œ ë¬¸ìì—´ ìƒì„±
            const dateString = `${utcYear}-${String(utcMonth + 1).padStart(2, '0')}-${String(utcDate).padStart(2, '0')}`;
            forceUpcoming.push({
                date: dateString,
                events: []
            });
                    // ê°•ì œ ìƒì„± ë‚ ì§œ
        }
    // ê°•ì œ ìƒì„± ìµœì¢… upcoming ë°°ì—´
        
        // ğŸš¨ ì¦‰ì‹œ ìƒíƒœ ì—…ë°ì´íŠ¸ (API ì‘ë‹µê³¼ ê´€ê³„ì—†ì´)
        // ë‹¨, ê¸°ì¡´ì— ìˆëŠ” ì¼ì •ì€ ë³´ì¡´
        setAppointments(prev => {
            const newAppointments = [...forceUpcoming];
            
            // ê¸°ì¡´ appointmentsì—ì„œ ì´ë²¤íŠ¸ê°€ ìˆëŠ” ë‚ ì§œëŠ” ë³´ì¡´
            if (prev && prev.length > 0) {
                prev.forEach(existingAppointment => {
                    if (existingAppointment.events && Array.isArray(existingAppointment.events) && existingAppointment.events.length > 0) {
                        const existingIndex = newAppointments.findIndex(item => item.date === existingAppointment.date);
                        if (existingIndex >= 0) {
                            newAppointments[existingIndex] = existingAppointment;
                        }
                    }
                });
            }
            
                                    // console.log('ğŸ” [fetchHomeData] ê¸°ì¡´ ì¼ì • ë³´ì¡´ í›„ appointments:', newAppointments);
            return newAppointments;
        });
        
        fetch(`${RENDER_SERVER_URL}/cafeteria/today`).then(res => res.json()).then(data => { 
            if (data && Array.isArray(data.menu)) {
                setTodayMenu(data.menu);
                // ë©”ë‰´ ê¸°ë¡ ë¯¸ì…˜ ì™„ë£Œ ì²˜ë¦¬ (ì„ì‹œ ë¹„í™œì„±í™”)
                // if (data.menu && data.menu.length > 0) {
                //     handleActionCompletion('menu_record');
                // }
            }
        }).catch(console.error);

        if (!currentUser) {
            // ë””ë²„ê·¸ ë¡œê·¸ ì œê±°
            
            // ì „ì—­ ë³€ìˆ˜ì— ì‚¬ìš©ì IDê°€ ìˆìœ¼ë©´ ì‚¬ìš©
            if (global.myEmployeeId) {
                // ë””ë²„ê·¸ ë¡œê·¸ ì œê±°
            } else {
                // ë””ë²„ê·¸ ë¡œê·¸ ì œê±°
                return;
            }
        }
        
        const userId = currentUser?.employee_id || global.myEmployeeId;
        // ë””ë²„ê·¸ ë¡œê·¸ ì œê±°
        fetch(`${RENDER_SERVER_URL}/events/${userId}`).then(res => {
            // ë””ë²„ê·¸ ë¡œê·¸ ì œê±°
            
            // ğŸš¨ ì¤‘ìš”: ì„œë²„ ì˜¤ë¥˜ ì‹œ ì „ì—­ ë°±ì—… ìƒíƒœ ë³´ì¡´!
            if (!res.ok) {
                // ë””ë²„ê·¸ ë¡œê·¸ ì œê±°
                
                // ì „ì—­ ë°±ì—… ìƒíƒœê°€ ìˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ë³µì›
                if (global.backupAppointments && global.backupAppointments.length > 0) {
                    // ë””ë²„ê·¸ ë¡œê·¸ ì œê±°
                    setAppointments(global.backupAppointments);
                    setMarkedDates(global.backupMarkedDates || {});
                    setAllEvents(global.backupAllEvents || {});
                    return Promise.reject(new Error('ì „ì—­ ë°±ì—… ìƒíƒœ ë³µì› ì™„ë£Œ'));
                } else {
                    // ë””ë²„ê·¸ ë¡œê·¸ ì œê±°
                    // ê¸°ë³¸ê°’ ì„¤ì •
                    const upcoming = [];
                    for (let i = 0; i < 7; i++) {
                        const date = new Date(today);
                        date.setUTCDate(today.getUTCDate() + i);
                        const dateString = toLocalDateString(date);
                        upcoming.push({
                            date: dateString,
                            events: []
                        });
                    }
                    setAppointments(upcoming);
                    setMarkedDates({});
                    setAllEvents({});
                    return Promise.reject(new Error('ê¸°ë³¸ê°’ ì„¤ì • ì™„ë£Œ'));
                }
            }
            
            return res.json();
        }).then(data => {
                    // ë””ë²„ê·¸ ë¡œê·¸ ì œê±°
        
        if (!data || typeof data !== 'object') {
            // ë””ë²„ê·¸ ë¡œê·¸ ì œê±°
            return;
        }
        
        // ë°ì´í„° êµ¬ì¡° ìƒì„¸ ë¶„ì„
        // ë””ë²„ê·¸ ë¡œê·¸ ì œê±°
        
    const upcoming = [];

    // 1. ì˜¤ëŠ˜ë¶€í„° 7ì¼ê°„ì˜ 'ë‚˜ì˜ ì ì‹¬ ì•½ì†'ë§Œ upcomingì— ë„£ê¸° (UIìš©)
        // ë””ë²„ê·¸ ë¡œê·¸ ì œê±°
                // ë°˜ë³µ ì¼ì •ì„ ëª¨ë“  ë‚ ì§œì— í™•ì¥í•˜ëŠ” í•¨ìˆ˜
            const expandRecurringEvents = (events, startDate) => {
                const expandedEvents = [];
                
                events.forEach(event => {
                    if (event.is_recurring && event.recurrence_type) {
                        // ë°˜ë³µ ì¼ì •ì¸ ê²½ìš° ëª¨ë“  ë°˜ë³µ ë‚ ì§œ ê³„ì‚°
                        const eventStartDate = new Date(startDate);
                        
                        // 7ì¼ê°„ì˜ ë°˜ë³µ ì¼ì • ê³„ì‚°
                        for (let i = 0; i < 7; i++) {
                            const checkDate = new Date(today);
                            checkDate.setUTCDate(today.getUTCDate() + i);
                            const checkDateString = toLocalDateString(checkDate);
                            
                            // í•´ë‹¹ ë‚ ì§œì— ë°˜ë³µ ì¼ì •ì´ ì ìš©ë˜ëŠ”ì§€ í™•ì¸
                            let shouldInclude = false;
                            
                            if (event.recurrence_type === 'daily') {
                                // ë§¤ì¼ ë°˜ë³µ: ì‹œì‘ì¼ë¡œë¶€í„° 1ì¼ ê°„ê²©
                                const daysDiff = Math.floor((checkDate - eventStartDate) / (1000 * 60 * 60 * 24));
                                shouldInclude = daysDiff >= 0 && daysDiff % 1 === 0;
                            } else if (event.recurrence_type === 'weekly') {
                                // ë§¤ì£¼ ë°˜ë³µ: ì‹œì‘ì¼ë¡œë¶€í„° 7ì¼ ê°„ê²©
                                const daysDiff = Math.floor((checkDate - eventStartDate) / (1000 * 60 * 60 * 24));
                                shouldInclude = daysDiff >= 0 && daysDiff % 7 === 0;
                            } else if (event.recurrence_type === 'yearly') {
                                // ë§¤ë…„ ë°˜ë³µ: ì‹œì‘ì¼ë¡œë¶€í„° 365ì¼ ê°„ê²©
                                const daysDiff = Math.floor((checkDate - eventStartDate) / (1000 * 60 * 60 * 24));
                                shouldInclude = daysDiff >= 0 && daysDiff % 365 === 0;
                            }
                            
                            if (shouldInclude) {
                                // í•´ë‹¹ ë‚ ì§œì— ë°˜ë³µ ì¼ì • ì¶”ê°€
                                const existingDateIndex = expandedEvents.findIndex(item => item.date === checkDateString);
                                if (existingDateIndex >= 0) {
                                    expandedEvents[existingDateIndex].events.push(event);
                                } else {
                                    expandedEvents.push({
                                        date: checkDateString,
                                        events: [event]
                                    });
                                }
                            }
                        }
                    } else {
                        // ì¼ë°˜ ì¼ì •ì¸ ê²½ìš° í•´ë‹¹ ë‚ ì§œì—ë§Œ ì¶”ê°€
                        const existingDateIndex = expandedEvents.findIndex(item => item.date === startDate);
                        if (existingDateIndex >= 0) {
                            expandedEvents[existingDateIndex].events.push(event);
                        } else {
                            expandedEvents.push({
                                date: startDate,
                                events: [event]
                            });
                        }
                    }
                });
                
                return expandedEvents;
            };
            
            // ëª¨ë“  ë°˜ë³µ ì¼ì •ì„ ë¨¼ì € í™•ì¥í•˜ì—¬ ì „ì²´ ë‚ ì§œì— ë°°ì¹˜
            const allExpandedEvents = {};
            
            // ë°±ì—”ë“œ ë°ì´í„°ê°€ ë¹„ì–´ìˆì„ ë•Œ ì „ì—­ ë³€ìˆ˜ ë°ì´í„°ë¥¼ ìš°ì„ ì ìœ¼ë¡œ ì‚¬ìš©
            if (Object.keys(data).length === 0 && global.allEvents && Object.keys(global.allEvents).length > 0) {
                // ë°±ì—”ë“œ ë°ì´í„°ê°€ ë¹„ì–´ìˆì–´ ì „ì—­ ë³€ìˆ˜ ë°ì´í„° ì‚¬ìš©
                Object.keys(global.allEvents).forEach(dateString => {
                    const globalEventsOnDate = Array.isArray(global.allEvents[dateString]) ? global.allEvents[dateString] : [];
                    if (globalEventsOnDate.length > 0) {
                        if (!allExpandedEvents[dateString]) {
                            allExpandedEvents[dateString] = [];
                        }
                        // ì „ì—­ ë³€ìˆ˜ì˜ ì¼ì •ì„ ì¶”ê°€
                        globalEventsOnDate.forEach(event => {
                            allExpandedEvents[dateString].push(event);
                        });
                    }
                });
            }
            
            // ë°±ì—”ë“œ ë°ì´í„°ê°€ ìˆì„ ë•ŒëŠ” ì „ì—­ ë³€ìˆ˜ ë°ì´í„°ë¥¼ ì™„ì „íˆ ë¬´ì‹œ
            if (Object.keys(data).length > 0) {
                // ë””ë²„ê·¸ ë¡œê·¸ ì œê±°
                // ğŸš¨ ì¤‘ìš”: ì „ì—­ ë³€ìˆ˜ ë°ì´í„°ë¥¼ ì™„ì „íˆ ì´ˆê¸°í™”í•˜ì§€ ì•ŠìŒ
                // ìƒˆë¡œ ìƒì„±ëœ ì¼ì •ì„ ë³´ì¡´í•˜ê¸° ìœ„í•´ ê¸°ì¡´ ì „ì—­ ë³€ìˆ˜ ë°ì´í„° ìœ ì§€
                
                // ë°±ì—”ë“œ ë°ì´í„°ë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš© (ë°˜ë³µ ì¼ì • ê³„ì‚° ì œê±°)
                Object.keys(data).forEach(dateString => {
                    const eventsOnDate = Array.isArray(data[dateString]) ? data[dateString] : [];
                    
                    if (!allExpandedEvents[dateString]) {
                        allExpandedEvents[dateString] = [];
                    }
                    
                    // ğŸš¨ ì¤‘ìš”: "[ì‚­ì œë¨]" ì¼ì •ì´ ìˆëŠ” ë‚ ì§œì—ì„œëŠ” ë°˜ë³µ ì¼ì • ìˆ¨ê¹€ ì²˜ë¦¬
                    const hasDeletedEvent = eventsOnDate.some(event => 
                        (event.title && event.title.startsWith('[ì‚­ì œë¨]'))
                    );
                    
                    if (hasDeletedEvent) {
                        // "[ì‚­ì œë¨]" ì¼ì •ì´ ìˆëŠ” ê²½ìš°, í•´ë‹¹ ë‚ ì§œì—ëŠ” ì•„ë¬´ ì¼ì •ë„ í‘œì‹œí•˜ì§€ ì•ŠìŒ
                        // ì™„ì „íˆ ë¹ˆ ë‚ ì§œë¡œ ë§Œë“¤ì–´ì„œ "ì¼ì • ì—†ìŒ" ìƒíƒœë¡œ í‘œì‹œ
                        allExpandedEvents[dateString] = [];
                    } else {
                        // ì¼ë°˜ì ì¸ ê²½ìš°: ëª¨ë“  ì¼ì • í‘œì‹œ
                        eventsOnDate.forEach(event => {
                            allExpandedEvents[dateString].push(event);
                        });
                    }
                });
                
                // ğŸš¨ ì¤‘ìš”: ë°±ì—”ë“œ ë°ì´í„° ì²˜ë¦¬ í›„ ì „ì—­ ë³€ìˆ˜ì˜ ìƒˆë¡œ ìƒì„±ëœ ì¼ì • ì¶”ê°€
                if (global.allEvents && Object.keys(global.allEvents).length > 0) {
                    Object.keys(global.allEvents).forEach(dateString => {
                        const globalEventsOnDate = Array.isArray(global.allEvents[dateString]) ? global.allEvents[dateString] : [];
                        if (globalEventsOnDate.length > 0) {
                            if (!allExpandedEvents[dateString]) {
                                allExpandedEvents[dateString] = [];
                            }
                            // ì „ì—­ ë³€ìˆ˜ì˜ ì¼ì •ì„ ì¤‘ë³µ ì—†ì´ ì¶”ê°€
                            globalEventsOnDate.forEach(event => {
                                const isDuplicate = allExpandedEvents[dateString].some(existingEvent => 
                                    existingEvent.id === event.id
                                );
                                if (!isDuplicate) {
                                    allExpandedEvents[dateString].push(event);
                                }
                            });
                        }
                    });
                }
            }
            
            // ë°±ì—”ë“œ ë°ì´í„°ê°€ ìˆìœ¼ë©´ ì „ì—­ ë³€ìˆ˜ ë°ì´í„°ëŠ” ì‚¬ìš©í•˜ì§€ ì•ŠìŒ (ë‹¨ìˆœí™”)
            if (Object.keys(data).length === 0 && global.allEvents && Object.keys(global.allEvents).length > 0) {
                // ë°±ì—”ë“œ ë°ì´í„°ê°€ ì—†ì–´ ì „ì—­ ë³€ìˆ˜ ë°ì´í„° ì‚¬ìš©
                Object.keys(global.allEvents).forEach(dateString => {
                    if (!allExpandedEvents[dateString]) {
                        allExpandedEvents[dateString] = [];
                    }
                    allExpandedEvents[dateString].push(...global.allEvents[dateString]);
                });
            }
            
            // ì „ì—­ ë³€ìˆ˜ì— ìƒˆë¡œ ì¶”ê°€ëœ ì¼ì •ì´ ìˆìœ¼ë©´ ì¦‰ì‹œ í‘œì‹œ
            if (global.newScheduleData) {
                // ì „ì—­ ë³€ìˆ˜ ìƒˆ ì¼ì • ì²˜ë¦¬
                const newSchedule = global.newScheduleData;
                const scheduleDate = newSchedule.date;
                
                if (!allExpandedEvents[scheduleDate]) {
                    allExpandedEvents[scheduleDate] = [];
                }
                
                // ì¤‘ë³µ í™•ì¸ í›„ ì¶”ê°€
                const isDuplicate = allExpandedEvents[scheduleDate].some(existingEvent => 
                    existingEvent.id === newSchedule.id && 
                    existingEvent.date === newSchedule.date &&
                    existingEvent.title === newSchedule.title
                );
                
                if (!isDuplicate) {
                    allExpandedEvents[scheduleDate].push(newSchedule);
                    // ìƒˆ ì¼ì • ì¶”ê°€
                }
                
                // ì „ì—­ ë³€ìˆ˜ ì •ë¦¬
                global.newScheduleData = undefined;
            }
            
            // ì¤‘ë³µ ì¼ì • ì •ë¦¬ í•¨ìˆ˜ (ë””ë²„ê¹…ìš©)
            const cleanupDuplicateSchedules = async () => {
                try {
                    const response = await fetch(`${RENDER_SERVER_URL}/personal_schedules/cleanup`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            employee_id: global.myEmployeeId || 'KOICA001'
                        })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log('ğŸ”§ ì¤‘ë³µ ì¼ì • ì •ë¦¬ ê²°ê³¼:', result);
                        return result;
                        } else {
                        console.error('ğŸ”§ ì¤‘ë³µ ì¼ì • ì •ë¦¬ ì‹¤íŒ¨:', response.status);
                    }
                } catch (error) {
                    console.error('ğŸ”§ ì¤‘ë³µ ì¼ì • ì •ë¦¬ ì˜¤ë¥˜:', error);
                }
            };
            
            // ì „ì—­ ë³€ìˆ˜ì— ì •ë¦¬ í•¨ìˆ˜ ì¶”ê°€ (ë””ë²„ê¹…ìš©)
            if (typeof global !== 'undefined') {
                global.cleanupDuplicateSchedules = cleanupDuplicateSchedules;
            }
            

            
            // ğŸ¯ API ì‘ë‹µì´ ì„±ê³µì ìœ¼ë¡œ ì²˜ë¦¬ëœ ê²½ìš°ì—ë§Œ ê¸°ì¡´ 7ì¼ê°„ ì¹´ë“œ ìƒì„± ë¡œì§ ì‹¤í–‰
            // API ì‘ë‹µ ì²˜ë¦¬ ì™„ë£Œ, ê¸°ì¡´ 7ì¼ê°„ ì¹´ë“œ ìƒì„± ë¡œì§ ì‹¤í–‰
            
            // ê° ë‚ ì§œë³„ë¡œ ì´ë²¤íŠ¸ ì²˜ë¦¬ (ì˜¤ëŠ˜ë¶€í„° 7ì¼)
            for (let i = 0; i < 7; i++) {
                // UTC ê¸°ì¤€ìœ¼ë¡œ ë‚ ì§œ ê³„ì‚° (ë¡œì»¬ ì‹œê°„ëŒ€ ë³€í™˜ ë¬¸ì œ í•´ê²°)
                const utcYear = today.getUTCFullYear();
                const utcMonth = today.getUTCMonth();
                const utcDate = today.getUTCDate() + i;
                
                // UTC ê¸°ì¤€ìœ¼ë¡œ ë‚ ì§œ ë¬¸ìì—´ ìƒì„±
                const dateString = `${utcYear}-${String(utcMonth + 1).padStart(2, '0')}-${String(utcDate).padStart(2, '0')}`;
                const eventsOnDate = allExpandedEvents[dateString] || [];
                
                // ê° ë‚ ì§œë³„ ì´ë²¤íŠ¸ ì²˜ë¦¬
                upcoming.push({ date: dateString, events: eventsOnDate });
            }
            

        // ìµœì¢… upcoming ë°°ì—´

            // 2. allExpandedEventsë¥¼ ì‚¬ìš©í•˜ì—¬ markedDates ì—…ë°ì´íŠ¸ (ë‹¬ë ¥ í‘œì‹œìš© - ë°˜ë³µ ì¼ì • í¬í•¨)
        const newMarkedDates = {};
        const newAllEvents = {};
        
        // allExpandedEventsì˜ ëª¨ë“  ë‚ ì§œë¥¼ markedDatesì— ì¶”ê°€
        Object.keys(allExpandedEvents).forEach(dateString => {
            if (allExpandedEvents[dateString].length > 0) {
                let hasRandomLunch = false;
                let hasPersonalSchedule = false;
                let hasOtherEvents = false;

                allExpandedEvents[dateString].forEach(event => {
                    if (event.type === 'ëœë¤ ëŸ°ì¹˜') {
                        hasRandomLunch = true;
                    } else if (event.type === 'ê¸°íƒ€ ì¼ì •') {
                        hasPersonalSchedule = true;
                    } else {
                        hasOtherEvents = true;
                    }
                });

                let dotColor;
                if (hasRandomLunch) {
                    dotColor = '#F4D160';
                } else if (hasPersonalSchedule) {
                    dotColor = currentColors.gray;
                } else {
                    dotColor = currentColors.primary;
                }

                newMarkedDates[dateString] = {
                    selected: true,
                    selectedColor: dotColor
                };
                
                newAllEvents[dateString] = allExpandedEvents[dateString];
            }
        });
        
        // ì „ì—­ ë³€ìˆ˜ë„ ì—…ë°ì´íŠ¸ (ê³¼ê±° ì¼ì • í‘œì‹œìš©)
        if (typeof global !== 'undefined') {
            global.allEvents = newAllEvents;
        }

        // ğŸš¨ ì¤‘ìš”: ê¸°ì¡´ ìƒíƒœì™€ ë³‘í•©í•˜ì—¬ ì—…ë°ì´íŠ¸ (ìƒˆë¡œ ìƒì„±ëœ ì¼ì • ë³´ì¡´)
        setAppointments(prev => {
            const mergedAppointments = [...upcoming];
            
            // ê¸°ì¡´ appointmentsì—ì„œ ì´ë²¤íŠ¸ê°€ ìˆëŠ” ë‚ ì§œëŠ” ë³´ì¡´
            if (prev && prev.length > 0) {
                prev.forEach(existingAppointment => {
                    if (existingAppointment.events && Array.isArray(existingAppointment.events) && existingAppointment.events.length > 0) {
                        const existingIndex = mergedAppointments.findIndex(item => item.date === existingAppointment.date);
                        if (existingIndex >= 0) {
                            // ê¸°ì¡´ ì¼ì •ê³¼ ìƒˆ ì¼ì •ì„ ë³‘í•©
                            const existingEvents = existingAppointment.events;
                            const newEvents = mergedAppointments[existingIndex].events;
                            
                            // ì¤‘ë³µ ì œê±°í•˜ì—¬ ë³‘í•©
                            const mergedEvents = [...existingEvents];
                            newEvents.forEach(newEvent => {
                                const isDuplicate = mergedEvents.some(existingEvent => 
                                    existingEvent.id === newEvent.id
                                );
                                if (!isDuplicate) {
                                    mergedEvents.push(newEvent);
                                }
                            });
                            
                            mergedAppointments[existingIndex] = {
                                ...mergedAppointments[existingIndex],
                                events: mergedEvents
                            };
                        }
                    }
                });
            }
            
                                    // console.log('ğŸ” [fetchHomeData] ìµœì¢… ë³‘í•©ëœ appointments:', mergedAppointments);
            return mergedAppointments;
        });
        
        setMarkedDates(prev => {
            const mergedMarkedDates = { ...prev, ...newMarkedDates };
                                    // console.log('ğŸ” [fetchHomeData] ìµœì¢… ë³‘í•©ëœ markedDates:', mergedMarkedDates);
            return mergedMarkedDates;
        });
        
        // ì „ì²´ ì´ë²¤íŠ¸ ë°ì´í„°ë¥¼ ì €ì¥ (ë‹¬ë ¥ í´ë¦­ ì‹œ ì‚¬ìš©)
        setAllEvents(prev => {
            const mergedAllEvents = { ...prev, ...newAllEvents };
                                    // console.log('ğŸ” [fetchHomeData] ìµœì¢… ë³‘í•©ëœ allEvents:', mergedAllEvents);
            return mergedAllEvents;
        });
        
        // ğŸš¨ ì¤‘ìš”: API ì‘ë‹µê³¼ ê´€ê³„ì—†ì´ í•­ìƒ 7ì¼ê°„ ì¹´ë“œ ìƒì„± ë³´ì¥
                            // console.log('ğŸ” [í™ˆíƒ­] API ì‘ë‹µ ì²˜ë¦¬ ì™„ë£Œ, 7ì¼ê°„ ì¹´ë“œ ìƒì„± í™•ì¸');
        }).catch(error => {
            console.error('ğŸ” [í™ˆíƒ­] events API ì˜¤ë¥˜:', error);
            
            // ğŸš¨ ì¤‘ìš”: ì„œë²„ ì˜¤ë¥˜ ì‹œ ì „ì—­ ë°±ì—… ìƒíƒœ í™•ì¸ ë° ë³µì›!
            // ì„œë²„ ì˜¤ë¥˜ ë°œìƒ, ì „ì—­ ë°±ì—… ìƒíƒœ í™•ì¸
            
            // ì „ì—­ ë°±ì—… ìƒíƒœê°€ ìˆìœ¼ë©´ ê·¸ëŒ€ë¡œ ë³µì›
            if (global.backupAppointments && global.backupAppointments.length > 0) {
                // catch ë¸”ë¡ì—ì„œ ì „ì—­ ë°±ì—… ìƒíƒœ ë³µì›
                setAppointments(global.backupAppointments);
                setMarkedDates(global.backupMarkedDates || {});
                setAllEvents(global.backupAllEvents || {});
            } else {
                // ì „ì—­ ë°±ì—… ìƒíƒœê°€ ì—†ì–´ ê¸°ë³¸ê°’ ì„¤ì •
                const upcoming = [];
                for (let i = 0; i < 7; i++) {
                    // UTC ê¸°ì¤€ìœ¼ë¡œ ë‚ ì§œ ê³„ì‚° (ë¡œì»¬ ì‹œê°„ëŒ€ ë³€í™˜ ë¬¸ì œ í•´ê²°)
                    const utcYear = today.getUTCFullYear();
                    const utcMonth = today.getUTCMonth();
                    const utcDate = today.getUTCDate() + i;
                    
                    // UTC ê¸°ì¤€ìœ¼ë¡œ ë‚ ì§œ ë¬¸ìì—´ ìƒì„±
                    const dateString = `${utcYear}-${String(utcMonth + 1).padStart(2, '0')}-${String(utcDate).padStart(2, '0')}`;
                    upcoming.push({
                        date: dateString,
                        events: []
                    });
                    // catch ë¸”ë¡ ë‚ ì§œ
                }
                // catch ë¸”ë¡ ìµœì¢… upcoming ë°°ì—´
                
                setAppointments(upcoming);
                setMarkedDates({});
                setAllEvents({});
            }
        });

    }, []);

    const fetchNotifications = useCallback(async () => {
        try {
            if (!currentUser) return;
        const response = await fetch(`${API_BASE_URL}/notifications/${currentUser.employee_id}`);
            if (response.ok) {
                const data = await response.json();
                setUnreadCount(data.unread_count || 0);
            }
        } catch (error) {
            console.error('ì•Œë¦¼ ì¡°íšŒ ì‹¤íŒ¨:', error);
        }
    }, []);

    useFocusEffect(useCallback(() => {
        // ğŸš¨ ì¤‘ìš”: í˜„ì¬ ìƒíƒœë¥¼ ë°±ì—…í•˜ì—¬ ë³´ì¡´!
        const currentAppointments = appointments;
        const currentMarkedDates = markedDates;
        const currentAllEvents = allEvents;
        

        
        // ì „ì—­ ë³€ìˆ˜ í™•ì¸ í›„ ì²˜ë¦¬
        if (global.newPersonalSchedule && !isProcessingSchedule.current) {
            // ğŸš¨ ì¤‘ìš”: ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
            isProcessingSchedule.current = true;
            
            const newSchedule = global.newPersonalSchedule;
            const dateString = newSchedule.date;
            
            // appointments ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
            setAppointments(prev => {
                const newAppointments = [...prev];
                const existingDateIndex = newAppointments.findIndex(item => item.date === dateString);
                
                if (existingDateIndex >= 0) {
                    // ğŸš¨ ì¤‘ìš”: ë°ì´í„° ë¬´ê²°ì„± ê²€ì¦
                    const existingEvents = newAppointments[existingDateIndex].events || [];
                    const validEvents = getSafeValidEvents(existingEvents);
                    
                    newAppointments[existingDateIndex] = {
                        ...newAppointments[existingDateIndex],
                        events: [...validEvents, newSchedule]
                    };
                    // ê¸°ì¡´ ë‚ ì§œì— ì¼ì • ì¶”ê°€
                } else {
                    newAppointments.push({
                        date: dateString,
                        events: [newSchedule]
                    });
                    // ìƒˆë¡œìš´ ë‚ ì§œì— ì¼ì • ì¶”ê°€
                }
                
                // ğŸš¨ ì¤‘ìš”: ë°˜ë³µ ì¼ì • ì²˜ë¦¬
                if (newSchedule.isRecurring) {
                    // ë°˜ë³µì¼ì • ì²˜ë¦¬ ì‹œì‘
                    
                    if (newSchedule.recurrenceType === 'daily') {
                        // ì¼ê°„ ë°˜ë³µ ì²˜ë¦¬ ì‹œì‘ - 3650ì¼
                        // 3650ì¼ê°„ ë°˜ë³µ ì¼ì • ìƒì„± (10ë…„)
                        for (let day = 1; day <= 3650; day++) {
                            const nextDate = new Date(dateString);
                            nextDate.setDate(nextDate.getDate() + day);
                            const nextDateString = nextDate.toISOString().split('T')[0];
                            
                            // ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë‚ ì§œì¸ì§€ í™•ì¸
                            const nextDateIndex = newAppointments.findIndex(item => item.date === nextDateString);
                            
                            if (nextDateIndex >= 0) {
                                // ê¸°ì¡´ ë‚ ì§œì— ë°˜ë³µ ì¼ì • ì¶”ê°€
                                // ê¸°ì¡´ ë‚ ì§œì— ë°˜ë³µì¼ì • ì¶”ê°€
                                const existingEvents = newAppointments[nextDateIndex].events || [];
                                const validEvents = getSafeValidEvents(existingEvents);
                                
                                newAppointments[nextDateIndex] = {
                                    ...newAppointments[nextDateIndex],
                                    events: [...validEvents, { ...newSchedule, date: nextDateString }]
                                };
                            } else {
                                // ìƒˆë¡œìš´ ë‚ ì§œì— ë°˜ë³µ ì¼ì • ì¶”ê°€
                                newAppointments.push({
                                    date: nextDateString,
                                    events: [{ ...newSchedule, date: nextDateString }]
                                });
                            }
                        }
                    } else if (newSchedule.recurrenceType === 'weekly') {
                        // ì£¼ê°„ ë°˜ë³µ ì²˜ë¦¬ ì‹œì‘ - 800ì£¼
                        // 800ì£¼ê°„ ë°˜ë³µ ì¼ì • ìƒì„± (ì•½ 15ë…„)
                        for (let week = 1; week <= 800; week++) {
                            const nextDate = new Date(dateString);
                            nextDate.setDate(nextDate.getDate() + (week * 7));
                            const nextDateString = nextDate.toISOString().split('T')[0];
                            
                            // ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë‚ ì§œì¸ì§€ í™•ì¸
                            const nextDateIndex = newAppointments.findIndex(item => item.date === nextDateString);
                            
                            if (nextDateIndex >= 0) {
                                // ê¸°ì¡´ ë‚ ì§œì— ë°˜ë³µ ì¼ì • ì¶”ê°€
                                const existingEvents = newAppointments[nextDateIndex].events || [];
                                const validEvents = getSafeValidEvents(existingEvents);
                                
                                newAppointments[nextDateIndex] = {
                                    ...newAppointments[nextDateIndex],
                                    events: [...validEvents, { ...newSchedule, date: nextDateString }]
                                };
                            } else {
                                // ìƒˆë¡œìš´ ë‚ ì§œì— ë°˜ë³µ ì¼ì • ì¶”ê°€
                                newAppointments.push({
                                    date: nextDateString,
                                    events: [{ ...newSchedule, date: nextDateString }]
                                });
                            }
                        }
                    } else if (newSchedule.recurrenceType === 'monthly') {
                        // ì›”ê°„ ë°˜ë³µ ì²˜ë¦¬ ì‹œì‘ - 120ê°œì›”
                        // 120ê°œì›”ê°„ ë°˜ë³µ ì¼ì • ìƒì„± (10ë…„)
                        for (let month = 1; month <= 120; month++) {
                            const nextDate = new Date(dateString);
                            nextDate.setMonth(nextDate.getMonth() + month);
                            const nextDateString = nextDate.toISOString().split('T')[0];
                            
                            // ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë‚ ì§œì¸ì§€ í™•ì¸
                            const nextDateIndex = newAppointments.findIndex(item => item.date === nextDateString);
                            
                            if (nextDateIndex >= 0) {
                                // ê¸°ì¡´ ë‚ ì§œì— ë°˜ë³µ ì¼ì • ì¶”ê°€
                                const existingEvents = newAppointments[nextDateIndex].events || [];
                                const validEvents = getSafeValidEvents(existingEvents);
                                
                                newAppointments[nextDateIndex] = {
                                    ...newAppointments[nextDateIndex],
                                    events: [...validEvents, { ...newSchedule, date: nextDateString }] 
                                };
                            } else {
                                // ìƒˆë¡œìš´ ë‚ ì§œì— ë°˜ë³µ ì¼ì • ì¶”ê°€
                                newAppointments.push({
                                    date: nextDateString,
                                    events: [{ ...newSchedule, date: nextDateString }]
                                });
                            }
                        }
                    }
                }
                
                // ğŸš¨ ì¤‘ìš”: ìµœì¢… ë°ì´í„° ë¬´ê²°ì„± ê²€ì¦
                const validatedAppointments = newAppointments.map(item => ({
                    ...item,
                    events: (item.events || []).filter(event => event && typeof event === 'object')
                }));
                
                // ì—…ë°ì´íŠ¸ëœ appointments
                return validatedAppointments;
            });
            
            // markedDates ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
            setMarkedDates(prev => {
                const newMarkedDates = { ...prev };
                newMarkedDates[dateString] = {
                    selected: true,
                    selectedColor: currentColors.gray
                };
                
                // ğŸš¨ ì¤‘ìš”: ë°˜ë³µ ì¼ì • markedDates ì¶”ê°€
                if (newSchedule.isRecurring) {
                    if (newSchedule.recurrenceType === 'daily') {
                                    // 3650ì¼ê°„ ë°˜ë³µ ì¼ì • markedDates ì¶”ê°€ (10ë…„)
            for (let day = 1; day <= 3650; day++) {
                            const nextDate = new Date(dateString);
                            nextDate.setDate(nextDate.getDate() + day);
                            const nextDateString = nextDate.toISOString().split('T')[0];
                            
                            newMarkedDates[nextDateString] = {
                                selected: true,
                                selectedColor: currentColors.gray
                            };
                            // ì¼ê°„ ë°˜ë³µ ì¼ì • markedDates ì¶”ê°€
                        }
                    } else if (newSchedule.recurrenceType === 'weekly') {
                        // 800ì£¼ê°„ ë°˜ë³µ ì¼ì • markedDates ì¶”ê°€
                        for (let week = 1; week <= 800; week++) {
                            const nextDate = new Date(dateString);
                            nextDate.setDate(nextDate.getDate() + (week * 7));
                            const nextDateString = nextDate.toISOString().split('T')[0];
                            
                            newMarkedDates[nextDateString] = {
                                selected: true,
                                selectedColor: currentColors.gray
                            };
                            // ì£¼ê°„ ë°˜ë³µ ì¼ì • markedDates ì¶”ê°€
                        }
                    } else if (newSchedule.recurrenceType === 'monthly') {
                        // 120ê°œì›”ê°„ ë°˜ë³µ ì¼ì • markedDates ì¶”ê°€
                        for (let month = 1; month <= 120; month++) {
                            const nextDate = new Date(dateString);
                            nextDate.setMonth(nextDate.getMonth() + month);
                            const nextDateString = nextDate.toISOString().split('T')[0];
                            
                            newMarkedDates[nextDateString] = {
                                selected: true,
                                selectedColor: currentColors.gray
                            };
                            // ì›”ê°„ ë°˜ë³µ ì¼ì • markedDates ì¶”ê°€
                        }
                    }
                }
                
                // ì—…ë°ì´íŠ¸ëœ markedDates
                return newMarkedDates;
            });
            
            // allEvents ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
            setAllEvents(prev => {
                const newAllEvents = { ...prev };
                
                if (newAllEvents[dateString]) {
                    // ğŸš¨ ì¤‘ìš”: ë°ì´í„° ë¬´ê²°ì„± ê²€ì¦
                    const existingEvents = newAllEvents[dateString] || [];
                    const validEvents = getSafeValidEvents(existingEvents);
                    newAllEvents[dateString] = [...validEvents, newSchedule];
                } else {
                    newAllEvents[dateString] = [newSchedule];
                }
                
                // ğŸš¨ ì¤‘ìš”: ë°˜ë³µ ì¼ì • allEvents ì¶”ê°€ (endDate ê³ ë ¤)
                if (newSchedule.isRecurring) {
                    // ì¢…ë£Œ ë‚ ì§œ í™•ì¸
                    const endDate = newSchedule.endDate ? new Date(newSchedule.endDate) : null;
                    const startDate = new Date(dateString);
                    
                    // endDate ì²˜ë¦¬ ì‹œì‘
                    
                    // endDate ì •ë³´ í™•ì¸
                    
                    if (newSchedule.recurrenceType === 'daily') {
                        // ì¼ê°„ ë°˜ë³µ ì¼ì • allEvents ì¶”ê°€ (endDateê¹Œì§€)
                        let day = 1;
                        let generatedCount = 0;
                        
                        // ğŸš¨ ì¤‘ìš”: endDateê°€ ì„¤ì •ëœ ê²½ìš° ì •í™•í•œ ì¼ìˆ˜ ê³„ì‚°
                        let maxDays = 3650; // ê¸°ë³¸ê°’: 10ë…„
                        if (endDate) {
                            // endDateê¹Œì§€ì˜ ì •í™•í•œ ì¼ìˆ˜ ê³„ì‚° (endDate í¬í•¨)
                            const endDateOnly = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
                            const startDateOnly = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
                            maxDays = Math.ceil((endDateOnly - startDateOnly) / (1000 * 60 * 60 * 24)) + 1;
                            // endDate ê¸°ë°˜ ì¼ìˆ˜ ê³„ì‚°
                        }
                        
                        for (let day = 1; day <= maxDays; day++) {
                            const nextDate = new Date(startDate);
                            nextDate.setDate(startDate.getDate() + day);
                            const nextDateString = nextDate.toISOString().split('T')[0];
                            
                            // ğŸš¨ ì¤‘ìš”: endDateê°€ ì„¤ì •ëœ ê²½ìš° í•´ë‹¹ ë‚ ì§œê¹Œì§€ë§Œ ìƒì„± (endDate í¬í•¨)
                            if (endDate && nextDate > endDate) {
                                // endDate ì´ˆê³¼, ìƒì„± ì¤‘ë‹¨
                                break;
                            }
                            
                            if (newAllEvents[nextDateString]) {
                                const existingEvents = newAllEvents[nextDateString] || [];
                                const validEvents = getSafeValidEvents(existingEvents);
                                newAllEvents[nextDateString] = [...validEvents, { ...newSchedule, date: nextDateString }];
                            } else {
                                newAllEvents[nextDateString] = [{ ...newSchedule, date: nextDateString }];
                            }
                            
                            generatedCount++;
                        }
                        
                        // ì¼ê°„ ë°˜ë³µ ì™„ë£Œ
                    } else if (newSchedule.recurrenceType === 'weekly') {
                        // ì£¼ê°„ ë°˜ë³µ ì¼ì • allEvents ì¶”ê°€ (endDateê¹Œì§€)
                        let generatedCount = 0;
                        
                        // ğŸš¨ ì¤‘ìš”: endDateê°€ ì„¤ì •ëœ ê²½ìš° ì •í™•í•œ ì£¼ìˆ˜ ê³„ì‚°
                        let maxWeeks = 800; // ê¸°ë³¸ê°’: 800ì£¼
                        if (endDate) {
                            // endDateê¹Œì§€ì˜ ì •í™•í•œ ì£¼ìˆ˜ ê³„ì‚° (endDate í¬í•¨)
                            const endDateOnly = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
                            const startDateOnly = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
                            const daysDiff = Math.ceil((endDateOnly - startDateOnly) / (1000 * 60 * 60 * 24));
                            maxWeeks = Math.ceil(daysDiff / 7) + 1;
                            console.log('ï¿½ï¿½ [ë°˜ë³µì¼ì •] ì£¼ê°„ ë°˜ë³µ - endDate ê¸°ë°˜ ì£¼ìˆ˜ ê³„ì‚°:', {
                                startDate: startDateOnly.toISOString().split('T')[0],
                                endDate: endDateOnly.toISOString().split('T')[0],
                                daysDiff: daysDiff,
                                calculatedWeeks: maxWeeks
                            });
                        }
                        
                        for (let week = 1; week <= maxWeeks; week++) {
                            const nextDate = new Date(startDate);
                            nextDate.setDate(startDate.getDate() + (week * 7));
                            const nextDateString = nextDate.toISOString().split('T')[0];
                            
                            // ğŸš¨ ì¤‘ìš”: endDateê°€ ì„¤ì •ëœ ê²½ìš° í•´ë‹¹ ë‚ ì§œê¹Œì§€ë§Œ ìƒì„± (endDate í¬í•¨)
                            if (endDate && nextDate > endDate) {
                                console.log('ï¿½ï¿½ [ë°˜ë³µì¼ì •] ì£¼ê°„ ë°˜ë³µ - endDate ì´ˆê³¼, ìƒì„± ì¤‘ë‹¨:', {
                                    nextDate: nextDateString,
                                    endDate: endDate.toISOString().split('T')[0],
                                    generatedCount
                                });
                                break;
                            }
                            
                            if (newAllEvents[nextDateString]) {
                                const existingEvents = newAllEvents[nextDateString] || [];
                                const validEvents = getSafeValidEvents(existingEvents);
                                newAllEvents[nextDateString] = [...validEvents, { ...newSchedule, date: nextDateString }];
                            } else {
                                newAllEvents[nextDateString] = [{ ...newSchedule, date: nextDateString }];
                            }
                            
                            generatedCount++;
                        }
                        
                        // console.log('ğŸ” [ë°˜ë³µì¼ì •] ì£¼ê°„ ë°˜ë³µ ì™„ë£Œ - ì´ ìƒì„±ëœ ì¼ì • ìˆ˜:', generatedCount);
                    } else if (newSchedule.recurrenceType === 'monthly') {
                        // ì›”ê°„ ë°˜ë³µ ì¼ì • allEvents ì¶”ê°€ (endDateê¹Œì§€)
                        let generatedCount = 0;
                        
                        // ğŸš¨ ì¤‘ìš”: endDateê°€ ì„¤ì •ëœ ê²½ìš° ì •í™•í•œ ê°œì›”ìˆ˜ ê³„ì‚°
                        let maxMonths = 120; // ê¸°ë³¸ê°’: 120ê°œì›”
                        if (endDate) {
                            // endDateê¹Œì§€ì˜ ì •í™•í•œ ê°œì›”ìˆ˜ ê³„ì‚° (endDate í¬í•¨)
                            const endDateOnly = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
                            const startDateOnly = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
                            const monthsDiff = (endDateOnly.getFullYear() - startDateOnly.getFullYear()) * 12 + (endDateOnly.getMonth() - startDateOnly.getMonth());
                            maxMonths = monthsDiff + 1;
                            console.log('ï¿½ï¿½ [ë°˜ë³µì¼ì •] ì›”ê°„ ë°˜ë³µ - endDate ê¸°ë°˜ ê°œì›”ìˆ˜ ê³„ì‚°:', {
                                startDate: startDateOnly.toISOString().split('T')[0],
                                endDate: endDateOnly.toISOString().split('T')[0],
                                monthsDiff: monthsDiff,
                                calculatedMonths: maxMonths
                            });
                        }
                        
                        for (let month = 1; month <= maxMonths; month++) {
                            const nextDate = new Date(startDate);
                            nextDate.setMonth(startDate.getMonth() + month);
                            const nextDateString = nextDate.toISOString().split('T')[0];
                            
                            // ğŸš¨ ì¤‘ìš”: endDateê°€ ì„¤ì •ëœ ê²½ìš° í•´ë‹¹ ë‚ ì§œê¹Œì§€ë§Œ ìƒì„± (endDate í¬í•¨)
                            if (endDate && nextDate > endDate) {
                                console.log('ï¿½ï¿½ [ë°˜ë³µì¼ì •] ì›”ê°„ ë°˜ë³µ - endDate ì´ˆê³¼, ìƒì„± ì¤‘ë‹¨:', {
                                    nextDate: nextDateString,
                                    endDate: endDate.toISOString().split('T')[0],
                                    generatedCount
                                });
                                break;
                            }
                            
                            if (newAllEvents[nextDateString]) {
                                const existingEvents = newAllEvents[nextDateString] || [];
                                const validEvents = getSafeValidEvents(existingEvents);
                                newAllEvents[nextDateString] = [...validEvents, { ...newSchedule, date: nextDateString }];
                            } else {
                                newAllEvents[nextDateString] = [{ ...newSchedule, date: nextDateString }];
                            }
                            
                            generatedCount++;
                        }
                        
                        // console.log('ğŸ” [ë°˜ë³µì¼ì •] ì›”ê°„ ë°˜ë³µ ì™„ë£Œ - ì´ ìƒì„±ëœ ì¼ì • ìˆ˜:', generatedCount);
                    }
                }
                
                // ì—…ë°ì´íŠ¸ëœ allEvents
                return newAllEvents;
            });
            
            // ğŸš¨ ì¤‘ìš”: allEvents ìƒíƒœ ì—…ë°ì´íŠ¸ ì™„ë£Œ í›„ markedDates ë™ê¸°í™”
            // useEffectì—ì„œ ìë™ìœ¼ë¡œ ì²˜ë¦¬ë¨
            
            // ì „ì—­ ë³€ìˆ˜ ì´ˆê¸°í™” (ì „ì—­ë³€ìˆ˜ ì‹œìŠ¤í…œ ì œê±°ë¨)
            // global.newPersonalSchedule = undefined;
                            // console.log('ğŸ” [í™ˆíƒ­] useFocusEffect ì „ì—­ ë³€ìˆ˜ ì¼ì • ì²˜ë¦¬ ì™„ë£Œ');
            
            // ğŸš¨ ì¤‘ìš”: ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€ í•´ì œ
            isProcessingSchedule.current = false;
            
            // ğŸš¨ ì¤‘ìš”: ë°˜ë³µ ì¼ì • ì²˜ë¦¬ ì™„ë£Œ í›„ ìƒíƒœ í™•ì¸
            if (newSchedule.isRecurring) {
                // ë°˜ë³µ ì¼ì • ì²˜ë¦¬ ì™„ë£Œ
            }
            
            // ìƒíƒœ ì—…ë°ì´íŠ¸ í›„ ìµœì¢… í™•ì¸
            setTimeout(() => {
                // ìƒíƒœ ì—…ë°ì´íŠ¸ í›„ ìµœì¢… í™•ì¸
                
                // ë°˜ë³µ ì¼ì • ë°ì´í„° ìƒì„¸ í™•ì¸
                if (newSchedule.isRecurring) {
                    // ë°˜ë³µ ì¼ì • ìƒì„¸ ì •ë³´
                    
                    // markedDatesì—ì„œ ë°˜ë³µ ì¼ì • ë‚ ì§œë“¤ í™•ì¸
                    const recurringDates = Object.keys(markedDates).filter(date => 
                        date !== dateString && markedDates[date]?.selected
                    );
                    
                    // allEventsì—ì„œ ë°˜ë³µ ì¼ì • ì´ë²¤íŠ¸ë“¤ í™•ì¸
                    const recurringEvents = Object.keys(allEvents).filter(date => 
                        date !== dateString && allEvents[date]?.length > 0
                    );
                }
            }, 100);
        }
        
        // ğŸš¨ ì¤‘ìš”: ìƒˆ íŒŒí‹° ì²˜ë¦¬ (ì „ì—­ë³€ìˆ˜ ì‹œìŠ¤í…œ ì œê±°ë¨)
        // if (global.newPartySchedule) {
        //     const newParty = global.newPartySchedule;
        //     const dateString = newParty.date;
        //     
        //     // appointments ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
        //     setAppointments(prev => {
        //         const newAppointments = [...prev];
        //         const existingDateIndex = newAppointments.findIndex(item => item.date === dateString);
        //         
        //         if (existingDateIndex >= 0) {
        //             // ğŸš¨ ì¤‘ìš”: ë°ì´í„° ë¬´ê²°ì„± ê²€ì¦
        //             const existingEvents = newAppointments[existingDateIndex].events || [];
        //             const validEvents = getSafeValidEvents(existingEvents);
        //             
        //             newAppointments[existingDateIndex] = {
        //                 ...newAppointments[existingDateIndex],
        //                 events: [...validEvents, newParty]
        //             };
        //             // ê¸°ì¡´ ë‚ ì§œì— ìƒˆ íŒŒí‹° ì¶”ê°€
        //         } else {
        //             newAppointments.push({
        //                 date: dateString,
        //                 events: [newParty]
        //             });
        //             // ìƒˆë¡œìš´ ë‚ ì§œì— ìƒˆ íŒŒí‹° ì¶”ê°€
        //         }
        //         
        //         // ğŸš¨ ì¤‘ìš”: ìµœì¢… ë°ì´í„° ë¬´ê²°ì„± ê²€ì¦
        //         const validatedAppointments = newAppointments.map(item => ({
        //             ...item,
        //             events: (item.events || []).filter(event => event && typeof event === 'object')
        //         }));
        //         
        //         // ì—…ë°ì´íŠ¸ëœ appointments
        //         return validatedAppointments;
        //     });
        //     
        //     // markedDates ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
        //     setMarkedDates(prev => {
        //         const newMarkedDates = { ...prev };
        //         // ëœë¤ëŸ°ì¹˜ íŒŒí‹°ì¸ì§€ í™•ì¸í•˜ì—¬ ìƒ‰ìƒ ê²°ì •
        //         const isRandomLunch = newParty && newParty.is_from_match === true;
        //         const selectedColor = isRandomLunch ? '#F4D160' : currentColors.primary; // ëœë¤ëŸ°ì¹˜ëŠ” ë…¸ë€ìƒ‰, ì¼ë°˜ íŒŒí‹°ëŠ” íŒŒë€ìƒ‰
        //         
        //         newMarkedDates[dateString] = {
        //             selected: true,
        //             selectedColor: selectedColor
        //         };
        //         return newMarkedDates;
        //     });
        //     
        //     // allEvents ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
        //     setAllEvents(prev => {
        //         const newAllEvents = { ...prev };
        //         if (newAllEvents[dateString]) {
        //             // ğŸš¨ ì¤‘ìš”: ë°ì´í„° ë¬´ê²°ì„± ê²€ì¦
        //             const existingEvents = newAllEvents[dateString] || [];
        //             const validEvents = getSafeValidEvents(existingEvents);
        //             newAllEvents[dateString] = [...validEvents, newParty];
        //         } else {
        //             newAllEvents[dateString] = [newParty];
        //         }
        //         // console.log('ğŸ” [í™ˆíƒ­] useFocusEffect: allEvents ì—…ë°ì´íŠ¸ ì™„ë£Œ, ë‚ ì§œ:', dateString);
        //         return newAllEvents;
        //     });
        //     
        //     // ì „ì—­ ë³€ìˆ˜ ì´ˆê¸°í™” (ì „ì—­ë³€ìˆ˜ ì‹œìŠ¤í…œ ì œê±°ë¨)
        //     // global.newPartySchedule = undefined;
        //     // ì „ì—­ ë³€ìˆ˜ ìƒˆ íŒŒí‹° ì²˜ë¦¬ ì™„ë£Œ
        // } else {
        //     // fetchHomeData ì‹¤í–‰
        //     // ğŸš¨ ì¤‘ìš”: ë°±ì—…ëœ ìƒíƒœë¥¼ ì „ë‹¬í•˜ì—¬ fetchHomeDataì—ì„œ ë³´ì¡´!
        //     fetchHomeData(currentAppointments, currentMarkedDates, currentAllEvents);
        // }
    }, [currentColors.gray]));
    
    useFocusEffect(useCallback(() => {
        fetchNotifications();
    }, []));

    // unreadCountê°€ ë³€ê²½ë  ë•Œë§ˆë‹¤ route params ì—…ë°ì´íŠ¸
    useEffect(() => {
        navigation.setParams({ unreadCount });
    }, [unreadCount, navigation]);

    const handleMatchPress = async () => {
        // ì œì•ˆ ê¸°ë°˜ ëœë¤ ëŸ°ì¹˜ í™”ë©´ìœ¼ë¡œ ì´ë™
        safeNavigateToTab(navigation, 'íŒŒí‹°', 'RandomLunch');
    };

    const goToAddPersonalSchedule = (date) => {
        // console.log('ğŸ” goToAddPersonalSchedule í˜¸ì¶œ, date:', date);
        setModalData({ visible: false, events: [] });
        safeNavigateToTab(navigation, "íŒŒí‹°", "CreatePersonalSchedule", { date });
    };

    // ê¸°íƒ€ ì¼ì • ì¶”ê°€ í›„ í™ˆ ë°ì´í„° ìƒˆë¡œê³ ì¹¨ì„ ìœ„í•œ ë¦¬ìŠ¤ë„ˆ
    useFocusEffect(useCallback(() => {
        const unsubscribe = navigation.addListener('focus', () => {
            // í¬ì»¤ìŠ¤ ì´ë²¤íŠ¸ ë°œìƒ, í™ˆ ë°ì´í„° ìƒˆë¡œê³ ì¹¨
            // console.log('ğŸ” [ë‘ë²ˆì§¸ useFocusEffect] í¬ì»¤ìŠ¤ ì´ë²¤íŠ¸ ë°œìƒ');
            
            // ì „ì—­ ë³€ìˆ˜ì—ì„œ ìƒˆë¡œìš´ ì¼ì • í™•ì¸
        if (global.newPersonalSchedule && !isProcessingSchedule.current) {
            // console.log('ğŸ” [ë‘ë²ˆì§¸ useFocusEffect] ì „ì—­ ë³€ìˆ˜ ì¼ì • ê°ì§€:', global.newPersonalSchedule);
            // í¬ì»¤ìŠ¤ ì‹œ ì „ì—­ ë³€ìˆ˜ ì¼ì • ê°ì§€
            
            // ğŸš¨ ì¤‘ìš”: ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
            isProcessingSchedule.current = true;
                
                const newSchedule = global.newPersonalSchedule;
                const dateString = newSchedule.date;
                
                // appointments ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                setAppointments(prev => {
                    const newAppointments = [...prev];
                    const existingDateIndex = newAppointments.findIndex(item => item.date === dateString);
                    
                    if (existingDateIndex >= 0) {
                        newAppointments[existingDateIndex] = {
                            ...newAppointments[existingDateIndex],
                            events: [...newAppointments[existingDateIndex].events, newSchedule]
                        };
                    } else {
                        newAppointments.push({
                            date: dateString,
                            events: [newSchedule]
                        });
                    }
                    
                    return newAppointments;
                });
                
                // markedDates ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                setMarkedDates(prev => {
                    const newMarkedDates = { ...prev };
                    newMarkedDates[dateString] = {
                        selected: true,
                        selectedColor: '#64748B' // ê¸°íƒ€ ì¼ì • ìƒ‰ìƒ
                    };
                    return newMarkedDates;
                });
                
                // allEvents ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                setAllEvents(prev => {
                    const newAllEvents = { ...prev };
                    if (newAllEvents[dateString]) {
                        newAllEvents[dateString] = [...newAllEvents[dateString], newSchedule];
                    } else {
                        newAllEvents[dateString] = [newSchedule];
                    }
                    // allEvents ì—…ë°ì´íŠ¸ ì™„ë£Œ, ë‚ ì§œ
                    return newAllEvents;
                });
                
                // ğŸš¨ ì¤‘ìš”: ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€ í•´ì œ
                isProcessingSchedule.current = false;
                
                // ìƒíƒœ ì—…ë°ì´íŠ¸ ì™„ë£Œ í™•ì¸
                // ëª¨ë“  ìƒíƒœ ì—…ë°ì´íŠ¸ ì™„ë£Œ - appointments, markedDates, allEvents
                
                // ì „ì—­ ë³€ìˆ˜ ì´ˆê¸°í™”
                global.newPersonalSchedule = undefined;
                // í¬ì»¤ìŠ¤ ì‹œ ì „ì—­ ë³€ìˆ˜ ì¼ì • ì²˜ë¦¬ ì™„ë£Œ
                
                // ğŸš¨ ì¤‘ìš”: ì „ì—­ ë³€ìˆ˜ ì²˜ë¦¬ ì™„ë£Œ í›„ fetchHomeData ê±´ë„ˆë›°ê¸°
                // ìƒˆë¡œ ìƒì„±ëœ ì¼ì •ì´ ì„œë²„ API í˜¸ì¶œë¡œ ë®ì–´ì¨ì§€ëŠ” ê²ƒì„ ë°©ì§€
                // console.log('ğŸ” [useFocusEffect] ì „ì—­ ë³€ìˆ˜ ì¼ì • ì²˜ë¦¬ ì™„ë£Œ, fetchHomeData ê±´ë„ˆë›°ê¸°');
                return;
            }
            
            // ì „ì—­ ë³€ìˆ˜ì—ì„œ ìˆ˜ì •ëœ ì¼ì • í™•ì¸
            if (global.updatedPersonalSchedule && !isProcessingSchedule.current) {
                // ğŸš¨ ë””ë²„ê¹…: ì „ì—­ ë³€ìˆ˜ ì¡´ì¬ í™•ì¸
                console.log('ğŸ” [App.js] useFocusEffectì—ì„œ ì „ì—­ ë³€ìˆ˜ ì¡´ì¬ í™•ì¸:', {
                    hasGlobalVar: !!global.updatedPersonalSchedule,
                    isProcessing: isProcessingSchedule.current,
                    globalVarContent: global.updatedPersonalSchedule
                });
                
                // ğŸš¨ ì¤‘ìš”: ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
                isProcessingSchedule.current = true;
                
                const updatedSchedule = global.updatedPersonalSchedule;
                const originalDate = updatedSchedule.originalDate;
                const newDate = updatedSchedule.newDate;
                const scheduleData = updatedSchedule.schedule;
                const editMode = updatedSchedule.editMode;
                
                // ğŸš¨ ë””ë²„ê¹…: ì „ì—­ ë³€ìˆ˜ ê°ì§€ ë¡œê·¸
                console.log('ğŸ” [App.js] useFocusEffectì—ì„œ ì „ì—­ ë³€ìˆ˜ ê°ì§€:', {
                    originalDate,
                    newDate,
                    scheduleId: scheduleData.id || scheduleData._id,
                    editMode,
                    timestamp: updatedSchedule.timestamp
                });
                
                // ğŸš¨ ì¤‘ìš”: ì „ì²´ ë°˜ë³µ ì¼ì • ìˆ˜ì •ì¸ì§€ í™•ì¸
                if (editMode === 'recurring_all') {
                    console.log('ğŸ” [App.js] ì „ì²´ ë°˜ë³µ ì¼ì • ìˆ˜ì • ëª¨ë“œ ê°ì§€');
                    console.log('ğŸ” [App.js] ë‚ ì§œ ë³€ê²½ ì •ë³´:', {
                        originalDate: scheduleData.originalDate,
                        newDate: scheduleData.newDate,
                        hasDateChange: scheduleData.originalDate !== scheduleData.newDate
                    });
                    
                    // ğŸš¨ ì¤‘ìš”: ì „ì²´ ë°˜ë³µ ì¼ì • ìˆ˜ì •ì—ì„œëŠ” ëª¨ë“  ë°˜ë³µ ì¼ì •ì„ ìƒˆ ë‚ ì§œë¡œ ì´ë™
                    if (scheduleData.originalDate && scheduleData.newDate && scheduleData.originalDate !== scheduleData.newDate) {
                        console.log('ğŸ” [App.js] ì „ì²´ ë°˜ë³µ ì¼ì • ìˆ˜ì • - ëª¨ë“  ë°˜ë³µ ì¼ì •ì„ ìƒˆ ë‚ ì§œë¡œ ì´ë™');
                        
                        // 1. ê¸°ì¡´ ë‚ ì§œì—ì„œ ëª¨ë“  ë°˜ë³µ ì¼ì • ì œê±°í•˜ê³  ìƒˆ ë‚ ì§œì— ì¶”ê°€ (í•œ ë²ˆì— ì²˜ë¦¬)
                        setAppointments(prev => {
                            console.log('ğŸ” [App.js] appointments ìƒíƒœ ì—…ë°ì´íŠ¸ ì‹œì‘');
                            
                            // ê¸°ì¡´ ë‚ ì§œì—ì„œ ë°˜ë³µ ì¼ì • ì œê±°
                            let newAppointments = prev.map(appointment => {
                                if (appointment.date === scheduleData.originalDate) {
                                    return {
                                        ...appointment,
                                        events: (appointment.events || []).filter(event => {
                                            // scheduleData.schedule.idì™€ ì¼ì¹˜í•˜ëŠ” ì¼ì • ì œê±°
                                            const scheduleId = scheduleData.schedule?.id || scheduleData.schedule?._id;
                                            return event.id !== scheduleId && event._id !== scheduleId;
                                        })
                                    };
                                }
                                return appointment;
                            }).filter(appointment => appointment.events && Array.isArray(appointment.events) && appointment.events.length > 0); // ë¹ˆ ë‚ ì§œ ì œê±°
                            
                            // ë°˜ë³µ ì¼ì • ìƒì„± í•¨ìˆ˜
                            const generateRecurringEvents = () => {
                                const events = [];
                                const schedule = scheduleData.schedule;
                                
                                if (!schedule.isRecurring) return events;
                                
                                let currentDate = new Date(scheduleData.newDate);
                                const endDate = schedule.endType === 'never' ? new Date('2030-12-31') : new Date(schedule.endDate);
                                
                                console.log('ğŸ” [App.js] ë°˜ë³µ ì¼ì • ìƒì„± ì‹œì‘:', {
                                    startDate: scheduleData.newDate,
                                    endDate: schedule.endDate,
                                    recurrenceType: schedule.recurrenceType,
                                    recurrenceInterval: schedule.recurrenceInterval
                                });
                                
                                while (currentDate <= endDate) {
                                    const dateStr = currentDate.toISOString().split('T')[0];
                                    events.push({
                                        ...schedule,
                                        id: `${schedule.id}_${dateStr}`,
                                        date: dateStr,
                                        title: schedule.title,
                                        restaurant: schedule.restaurant,
                                        time: schedule.time,
                                        location: schedule.location,
                                        description: schedule.description,
                                        attendees: schedule.attendees,
                                        isRecurring: schedule.isRecurring,
                                        recurrenceType: schedule.recurrenceType,
                                        recurrenceInterval: schedule.recurrenceInterval,
                                        endType: schedule.endType,
                                        endDate: schedule.endDate
                                    });
                                    
                                    // ë‹¤ìŒ ë°˜ë³µ ë‚ ì§œ ê³„ì‚°
                                    if (schedule.recurrenceType === 'daily') {
                                        currentDate.setDate(currentDate.getDate() + schedule.recurrenceInterval);
                                    } else if (schedule.recurrenceType === 'weekly') {
                                        currentDate.setDate(currentDate.getDate() + (7 * schedule.recurrenceInterval));
                                    } else if (schedule.recurrenceType === 'monthly') {
                                        currentDate.setMonth(currentDate.getMonth() + schedule.recurrenceInterval);
                                    }
                                }
                                
                                console.log('ğŸ” [App.js] ìƒì„±ëœ ë°˜ë³µ ì¼ì •:', events.length, 'ê°œ');
                                return events;
                            };
                            
                            const recurringEvents = generateRecurringEvents();
                            
                            // ìƒˆ ë‚ ì§œì— ë°˜ë³µ ì¼ì •ë“¤ ì¶”ê°€
                            const existingDateIndex = newAppointments.findIndex(item => item.date === scheduleData.newDate);
                            
                            if (existingDateIndex >= 0) {
                                // ê¸°ì¡´ ë‚ ì§œì— ë°˜ë³µ ì¼ì •ë“¤ ì¶”ê°€
                                newAppointments[existingDateIndex].events.push(...recurringEvents);
                                console.log('ğŸ” [App.js] ê¸°ì¡´ ë‚ ì§œì— ë°˜ë³µ ì¼ì • ì¶”ê°€:', scheduleData.newDate, recurringEvents.length, 'ê°œ');
                            } else {
                                // ìƒˆë¡œìš´ ë‚ ì§œì— ë°˜ë³µ ì¼ì •ë“¤ ì¶”ê°€
                                newAppointments.push({
                                    date: scheduleData.newDate,
                                    events: recurringEvents
                                });
                                console.log('ğŸ” [App.js] ìƒˆ ë‚ ì§œì— ë°˜ë³µ ì¼ì • ì¶”ê°€:', scheduleData.newDate, recurringEvents.length, 'ê°œ');
                            }
                            
                            // ë‚ ì§œë³„ë¡œ ì •ë ¬
                            newAppointments.sort((a, b) => new Date(a.date) - new Date(b.date));
                            
                            console.log('ğŸ” [App.js] appointments ì—…ë°ì´íŠ¸ ì™„ë£Œ:', newAppointments.length, 'ê°œ ë‚ ì§œ');
                            return newAppointments;
                        });
                        
                        // 3. allEvents ìƒíƒœë„ ë™ì¼í•˜ê²Œ ì—…ë°ì´íŠ¸
                        setAllEvents(prev => {
                            const newAllEvents = { ...prev };
                            
                            // ê¸°ì¡´ ë‚ ì§œì—ì„œ ì¼ì • ì œê±°
                            if (newAllEvents[scheduleData.originalDate] && Array.isArray(newAllEvents[scheduleData.originalDate])) {
                                newAllEvents[scheduleData.originalDate] = newAllEvents[scheduleData.originalDate].filter(event => {
                                    // scheduleData.schedule.idì™€ ì¼ì¹˜í•˜ëŠ” ì¼ì • ì œê±°
                                    const scheduleId = scheduleData.schedule?.id || scheduleData.schedule?._id;
                                    return event.id !== scheduleId && event._id !== scheduleId;
                                });
                                
                                // ë¹ˆ ë°°ì—´ì´ë©´ í•´ë‹¹ ë‚ ì§œ í‚¤ ì œê±°
                                if (newAllEvents[scheduleData.originalDate].length === 0) {
                                    delete newAllEvents[scheduleData.originalDate];
                                }
                            }
                            
                            // ìƒˆ ë‚ ì§œì— ë°˜ë³µ ì¼ì •ë“¤ ì¶”ê°€
                            const schedule = scheduleData.schedule;
                            if (schedule.isRecurring) {
                                let currentDate = new Date(scheduleData.newDate);
                                const endDate = schedule.endType === 'never' ? new Date('2030-12-31') : new Date(schedule.endDate);
                                
                                while (currentDate <= endDate) {
                                    const dateStr = currentDate.toISOString().split('T')[0];
                                    
                                    if (newAllEvents[dateStr]) {
                                        newAllEvents[dateStr].push({
                                            ...schedule,
                                            id: `${schedule.id}_${dateStr}`,
                                            date: dateStr,
                                            title: schedule.title,
                                            restaurant: schedule.restaurant,
                                            time: schedule.time,
                                            location: schedule.location,
                                            description: schedule.description,
                                            attendees: schedule.attendees,
                                            isRecurring: schedule.isRecurring,
                                            recurrenceType: schedule.recurrenceType,
                                            recurrenceInterval: schedule.recurrenceInterval,
                                            endType: schedule.endType,
                                            endDate: schedule.endDate
                                });
                            } else {
                                        newAllEvents[dateStr] = [{
                                            ...schedule,
                                            id: `${schedule.id}_${dateStr}`,
                                            date: dateStr,
                                            title: schedule.title,
                                            restaurant: schedule.restaurant,
                                            time: schedule.time,
                                            location: schedule.location,
                                            description: schedule.description,
                                            attendees: schedule.attendees,
                                            isRecurring: schedule.isRecurring,
                                            recurrenceType: schedule.recurrenceType,
                                            recurrenceInterval: schedule.recurrenceInterval,
                                            endType: schedule.endType,
                                            endDate: schedule.endDate
                                        }];
                                    }
                                    
                                    // ë‹¤ìŒ ë°˜ë³µ ë‚ ì§œ ê³„ì‚°
                                    if (schedule.recurrenceType === 'daily') {
                                        currentDate.setDate(currentDate.getDate() + schedule.recurrenceInterval);
                                    } else if (schedule.recurrenceType === 'weekly') {
                                        currentDate.setDate(currentDate.getDate() + (7 * schedule.recurrenceInterval));
                                    } else if (schedule.recurrenceType === 'monthly') {
                                        currentDate.setMonth(currentDate.getMonth() + schedule.recurrenceInterval);
                                    }
                                }
                            }
                            
                            return newAllEvents;
                        });
                        
                        // 4. markedDates ì—…ë°ì´íŠ¸
                        setMarkedDates(prev => {
                            const newMarkedDates = { ...prev };
                            
                            // ğŸš¨ ì¤‘ìš”: ë°˜ë³µ ì¼ì •ì˜ ëª¨ë“  ê¸°ì¡´ ë‚ ì§œ ë§ˆí‚¹ ì œê±°
                            const schedule = scheduleData.schedule;
                            if (schedule.isRecurring) {
                                // ê¸°ì¡´ ë°˜ë³µ íŒ¨í„´ì˜ ëª¨ë“  ë‚ ì§œ ê³„ì‚°
                                let oldCurrentDate = new Date(scheduleData.originalDate);
                                const oldEndDate = schedule.endType === 'never' ? new Date('2030-12-31') : new Date(schedule.endDate);
                                
                                console.log('ğŸ” [App.js] markedDates ì—…ë°ì´íŠ¸ - ê¸°ì¡´ ë°˜ë³µ ì¼ì • ë§ˆí‚¹ ì œê±° ì‹œì‘:', {
                                    startDate: scheduleData.originalDate,
                                    endDate: schedule.endDate,
                                    recurrenceType: schedule.recurrenceType,
                                    recurrenceInterval: schedule.recurrenceInterval
                                });
                                
                                while (oldCurrentDate <= oldEndDate) {
                                    const oldDateStr = oldCurrentDate.toISOString().split('T')[0];
                                    
                                    // ê¸°ì¡´ ë°˜ë³µ ë‚ ì§œì˜ ë§ˆí‚¹ ì œê±°
                                    if (newMarkedDates[oldDateStr]) {
                                        delete newMarkedDates[oldDateStr];
                                        console.log('ğŸ” [App.js] ê¸°ì¡´ ë°˜ë³µ ì¼ì • ë‚ ì§œ ë§ˆí‚¹ ì œê±°:', oldDateStr);
                                    }
                                    
                                    // ë‹¤ìŒ ë°˜ë³µ ë‚ ì§œ ê³„ì‚°
                                    if (schedule.recurrenceType === 'daily') {
                                        oldCurrentDate.setDate(oldCurrentDate.getDate() + schedule.recurrenceInterval);
                                    } else if (schedule.recurrenceType === 'weekly') {
                                        oldCurrentDate.setDate(oldCurrentDate.getDate() + (7 * schedule.recurrenceInterval));
                                    } else if (schedule.recurrenceType === 'monthly') {
                                        oldCurrentDate.setMonth(oldCurrentDate.getMonth() + schedule.recurrenceInterval);
                                    }
                                }
                                
                                console.log('ğŸ” [App.js] ê¸°ì¡´ ë°˜ë³µ ì¼ì • ë§ˆí‚¹ ì œê±° ì™„ë£Œ');
                            } else {
                                // ë‹¨ì¼ ì¼ì •ì¸ ê²½ìš° ê¸°ì¡´ ë‚ ì§œ ë§ˆí‚¹ë§Œ ì œê±°
                                if (newMarkedDates[scheduleData.originalDate]) {
                                    delete newMarkedDates[scheduleData.originalDate];
                                    console.log('ğŸ” [App.js] ë‹¨ì¼ ì¼ì • ê¸°ì¡´ ë‚ ì§œ ë§ˆí‚¹ ì œê±°:', scheduleData.originalDate);
                                }
                            }
                            
                            // ğŸš¨ ì¤‘ìš”: ë°˜ë³µ ì¼ì •ì˜ ëª¨ë“  ìƒˆ ë‚ ì§œì— ë§ˆí‚¹ ì¶”ê°€
                            if (schedule.isRecurring) {
                                let newCurrentDate = new Date(scheduleData.newDate);
                                const newEndDate = schedule.endType === 'never' ? new Date('2030-12-31') : new Date(schedule.endDate);
                                
                                console.log('ğŸ” [App.js] markedDates ì—…ë°ì´íŠ¸ - ìƒˆ ë°˜ë³µ ì¼ì • ë§ˆí‚¹ ì‹œì‘:', {
                                    startDate: scheduleData.newDate,
                                    endDate: schedule.endDate,
                                    recurrenceType: schedule.recurrenceType,
                                    recurrenceInterval: schedule.recurrenceInterval
                                });
                                
                                while (newCurrentDate <= newEndDate) {
                                    const newDateStr = newCurrentDate.toISOString().split('T')[0];
                                    
                                    // ê° ë°˜ë³µ ë‚ ì§œì— ë§ˆí‚¹ ì¶”ê°€
                                    newMarkedDates[newDateStr] = {
                                        selected: true,
                                        selectedColor: '#64748B' // ê¸°íƒ€ ì¼ì • ìƒ‰ìƒ
                                    };
                                    
                                    console.log('ğŸ” [App.js] ìƒˆ ë°˜ë³µ ì¼ì • ë‚ ì§œ ë§ˆí‚¹ ì¶”ê°€:', newDateStr);
                                    
                                    // ë‹¤ìŒ ë°˜ë³µ ë‚ ì§œ ê³„ì‚°
                                    if (schedule.recurrenceType === 'daily') {
                                        newCurrentDate.setDate(newCurrentDate.getDate() + schedule.recurrenceInterval);
                                    } else if (schedule.recurrenceType === 'weekly') {
                                        newCurrentDate.setDate(newCurrentDate.getDate() + (7 * schedule.recurrenceInterval));
                                    } else if (schedule.recurrenceType === 'monthly') {
                                        newCurrentDate.setMonth(newCurrentDate.getMonth() + schedule.recurrenceInterval);
                                    }
                                }
                                
                                console.log('ğŸ” [App.js] ìƒˆ ë°˜ë³µ ì¼ì • ë§ˆí‚¹ ì¶”ê°€ ì™„ë£Œ');
                            } else {
                                // ë‹¨ì¼ ì¼ì •ì¸ ê²½ìš° ìƒˆ ë‚ ì§œì—ë§Œ ë§ˆí‚¹ ì¶”ê°€
                            newMarkedDates[scheduleData.newDate] = {
                                selected: true,
                                selectedColor: '#64748B' // ê¸°íƒ€ ì¼ì • ìƒ‰ìƒ
                            };
                                
                                console.log('ğŸ” [App.js] ë‹¨ì¼ ì¼ì • ìƒˆ ë‚ ì§œ ë§ˆí‚¹ ì¶”ê°€:', scheduleData.newDate);
                            }
                            
                            return newMarkedDates;
                        });
                        
                        console.log('ğŸ” [App.js] ì „ì²´ ë°˜ë³µ ì¼ì • ìˆ˜ì • ì™„ë£Œ:', {
                            from: scheduleData.originalDate,
                            to: scheduleData.newDate,
                            totalEvents: scheduleData.schedule.isRecurring ? 'ë°˜ë³µ ì¼ì • ìƒì„±ë¨' : 'ë‹¨ì¼ ì¼ì •'
                        });
                    } else {
                        // ë‚ ì§œ ë³€ê²½ì´ ì—†ëŠ” ê²½ìš° - ê¸°ì¡´ ë¡œì§ (ë‚´ìš©ë§Œ ì—…ë°ì´íŠ¸)
                        console.log('ğŸ” [App.js] ë‚ ì§œ ë³€ê²½ ì—†ìŒ - ë‚´ìš©ë§Œ ì—…ë°ì´íŠ¸');
                        console.log('ğŸ” [App.js] ìˆ˜ì •í•  ì¼ì • ID:', scheduleData.schedule?.id || scheduleData.schedule?._id);
                        console.log('ğŸ” [App.js] ìˆ˜ì •ëœ ë‚´ìš©:', {
                            title: scheduleData.title,
                            restaurant: scheduleData.restaurant,
                            time: scheduleData.time,
                            location: scheduleData.location,
                            description: scheduleData.description
                        });
                        
                        // ğŸš¨ ë””ë²„ê¹…: í˜„ì¬ appointments ìƒíƒœ í™•ì¸
                        console.log('ğŸ” [App.js] ìˆ˜ì • ì „ appointments ìƒíƒœ:', appointments);
                        
                        setAppointments(prev => {
                            const newAppointments = [...prev];
                            let updateCount = 0;
                            
                            // ëª¨ë“  ë°˜ë³µ ì¼ì •ì„ ì°¾ì•„ì„œ ë‚´ìš© ì—…ë°ì´íŠ¸
                            newAppointments.forEach(appointment => {
                                appointment.events = appointment.events.map(event => {
                                    // scheduleData.schedule.idì™€ ì¼ì¹˜í•˜ëŠ” ì¼ì • ì°¾ê¸°
                                    const scheduleId = scheduleData.schedule?.id || scheduleData.schedule?._id;
                                    if (event.id === scheduleId || event._id === scheduleId) {
                                        updateCount++;
                                        console.log('ğŸ” [App.js] ì¼ì • ì—…ë°ì´íŠ¸ë¨:', {
                                            date: appointment.date,
                                            eventId: event.id || event._id,
                                            oldTitle: event.title,
                                            newTitle: scheduleData.title
                                        });
                                        
                                        // ë°˜ë³µ ì¼ì •ì˜ ë‚´ìš©ë§Œ ì—…ë°ì´íŠ¸ (ë‚ ì§œëŠ” ìœ ì§€)
                                        return {
                                            ...event,
                                            title: scheduleData.title,
                                            restaurant: scheduleData.restaurant,
                                            time: scheduleData.time,
                                            location: scheduleData.location,
                                            description: scheduleData.description,
                                            attendees: scheduleData.attendees,
                                            // ë°˜ë³µ ì„¤ì •ë„ ì—…ë°ì´íŠ¸
                                            isRecurring: scheduleData.isRecurring,
                                            recurrenceType: scheduleData.recurrenceType,
                                            recurrenceInterval: scheduleData.recurrenceInterval,
                                            endType: scheduleData.endType,
                                            endDate: scheduleData.endDate
                                        };
                                    }
                                    return event;
                                });
                            });
                            
                            console.log('ğŸ” [App.js] appointments ì—…ë°ì´íŠ¸ ì™„ë£Œ, ì´', updateCount, 'ê°œ ì¼ì • ìˆ˜ì •ë¨');
                            return newAppointments;
                        });
                        
                        // allEvents ìƒíƒœë„ ë™ì¼í•˜ê²Œ ì—…ë°ì´íŠ¸
                        setAllEvents(prev => {
                            const newAllEvents = { ...prev };
                            let updateCount = 0;
                            
                            Object.keys(newAllEvents).forEach(date => {
                                newAllEvents[date] = newAllEvents[date].map(event => {
                                    // scheduleData.schedule.idì™€ ì¼ì¹˜í•˜ëŠ” ì¼ì • ì°¾ê¸°
                                    const scheduleId = scheduleData.schedule?.id || scheduleData.schedule?._id;
                                    if (event.id === scheduleId || event._id === scheduleId) {
                                        updateCount++;
                                        console.log('ğŸ” [App.js] allEvents ì—…ë°ì´íŠ¸ë¨:', {
                                            date,
                                            eventId: event.id || event._id,
                                            oldTitle: event.title,
                                            newTitle: scheduleData.title
                                        });
                                        
                                        // ë°˜ë³µ ì¼ì •ì˜ ë‚´ìš©ë§Œ ì—…ë°ì´íŠ¸ (ë‚ ì§œëŠ” ìœ ì§€)
                                        return {
                                            ...event,
                                            title: scheduleData.title,
                                            restaurant: scheduleData.restaurant,
                                            time: scheduleData.time,
                                            location: scheduleData.location,
                                            description: scheduleData.description,
                                            attendees: scheduleData.attendees,
                                            // ë°˜ë³µ ì„¤ì •ë„ ì—…ë°ì´íŠ¸
                                            isRecurring: scheduleData.isRecurring,
                                            recurrenceType: scheduleData.recurrenceType,
                                            recurrenceInterval: scheduleData.recurrenceInterval,
                                            endType: scheduleData.endType,
                                            endDate: scheduleData.endDate
                                        };
                                    }
                                    return event;
                                });
                            });
                            
                            console.log('ğŸ” [App.js] allEvents ì—…ë°ì´íŠ¸ ì™„ë£Œ, ì´', updateCount, 'ê°œ ì¼ì • ìˆ˜ì •ë¨');
                            return newAllEvents;
                        });
                    }
                    
                    // ğŸš¨ ë””ë²„ê¹…: ìƒíƒœ ì—…ë°ì´íŠ¸ í›„ í™•ì¸
                    setTimeout(() => {
                        console.log('ğŸ” [App.js] ìƒíƒœ ì—…ë°ì´íŠ¸ í›„ appointments í™•ì¸:', appointments);
                        console.log('ğŸ” [App.js] ìƒíƒœ ì—…ë°ì´íŠ¸ í›„ allEvents í™•ì¸:', allEvents);
                        
                        // ğŸš¨ ê°•ì œ ë¦¬ë Œë”ë§ì„ ìœ„í•œ ìƒíƒœ ì—…ë°ì´íŠ¸
                        setAppointments(prev => [...prev]);
                        setAllEvents(prev => ({ ...prev }));
                        
                        console.log('ğŸ” [App.js] ê°•ì œ ë¦¬ë Œë”ë§ ì‹¤í–‰ë¨');
                    }, 100);
                    
                    // ì „ì—­ ë³€ìˆ˜ ì´ˆê¸°í™” ë° ì²˜ë¦¬ ì™„ë£Œ
                    global.updatedPersonalSchedule = undefined;
                    isProcessingSchedule.current = false;
                    
                    // ì „ì—­ ë³€ìˆ˜ ì´ˆê¸°í™”
                    global.updatedPersonalSchedule = undefined;
                    
                    return;
                }
                
                // ì¼ë°˜ ìˆ˜ì • ë˜ëŠ” ë‹¨ì¼ ë°˜ë³µ ì¼ì • ìˆ˜ì •: ë‚ ì§œ ë³€ê²½ ì²˜ë¦¬
                console.log('ğŸ” [App.js] ì¼ë°˜ ìˆ˜ì • ë˜ëŠ” ë‹¨ì¼ ë°˜ë³µ ì¼ì • ìˆ˜ì • ëª¨ë“œ - ë‚ ì§œ ë³€ê²½ ìˆìŒ');
                
                // appointments ìƒíƒœ ì—…ë°ì´íŠ¸
                setAppointments(prev => {
                    const newAppointments = [...prev];
                    
                    // ì›ë˜ ë‚ ì§œì—ì„œ ì¼ì • ì œê±°
                    const originalDateIndex = newAppointments.findIndex(item => item.date === originalDate);
                    if (originalDateIndex >= 0) {
                        newAppointments[originalDateIndex] = {
                            ...newAppointments[originalDateIndex],
                            events: (newAppointments[originalDateIndex].events || []).filter(event => 
                                event.id !== scheduleData.id && event._id !== scheduleData.id
                            )
                        };
                        
                        // ì´ë²¤íŠ¸ê°€ ì—†ì–´ì§„ ë‚ ì§œëŠ” ì œê±°
                        if (newAppointments[originalDateIndex].events && Array.isArray(newAppointments[originalDateIndex].events) && newAppointments[originalDateIndex].events.length === 0) {
                            newAppointments.splice(originalDateIndex, 1);
                        }
                    }
                    
                    // ìƒˆ ë‚ ì§œì— ì¼ì • ì¶”ê°€
                    const newDateIndex = newAppointments.findIndex(item => item.date === newDate);
                    if (newDateIndex >= 0) {
                        newAppointments[newDateIndex] = {
                            ...newAppointments[newDateIndex],
                            events: [...(newAppointments[newDateIndex].events || []), scheduleData]
                        };
                    } else {
                        newAppointments.push({
                            date: newDate,
                            events: [scheduleData]
                        });
                    }
                    
                    return newAppointments;
                });
                
                // markedDates ìƒíƒœ ì—…ë°ì´íŠ¸
                setMarkedDates(prev => {
                    const newMarkedDates = { ...prev };
                    
                    // ì›ë˜ ë‚ ì§œ ë§ˆí‚¹ ì œê±°
                    if (newMarkedDates[originalDate]) {
                        delete newMarkedDates[originalDate];
                    }
                    
                    // ìƒˆ ë‚ ì§œ ë§ˆí‚¹ ì¶”ê°€
                    newMarkedDates[newDate] = {
                        selected: true,
                        selectedColor: '#64748B' // ê¸°íƒ€ ì¼ì • ìƒ‰ìƒ
                    };
                    
                    return newMarkedDates;
                });
                
                // allEvents ìƒíƒœ ì—…ë°ì´íŠ¸
                setAllEvents(prev => {
                    const newAllEvents = { ...prev };
                    
                    // ì›ë˜ ë‚ ì§œì—ì„œ ì¼ì • ì œê±°
                    if (newAllEvents[originalDate]) {
                        newAllEvents[originalDate] = newAllEvents[originalDate].filter(event => 
                            event.id !== scheduleData.id && event._id !== scheduleData.id
                        );
                        
                        // ì´ë²¤íŠ¸ê°€ ì—†ì–´ì§„ ë‚ ì§œëŠ” ì œê±°
                        if (newAllEvents[originalDate].length === 0) {
                            delete newAllEvents[originalDate];
                        }
                    }
                    
                    // ìƒˆ ë‚ ì§œì— ì¼ì • ì¶”ê°€
                    if (newAllEvents[newDate]) {
                        newAllEvents[newDate] = [...newAllEvents[newDate], scheduleData];
                    } else {
                        newAllEvents[newDate] = [scheduleData];
                    }
                    
                    return newAllEvents;
                });
                
                // ğŸš¨ ì¤‘ìš”: ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€ í•´ì œ
                isProcessingSchedule.current = false;
                
                // ğŸš¨ ë””ë²„ê¹…: ìƒíƒœ ì—…ë°ì´íŠ¸ ì™„ë£Œ ë¡œê·¸
                console.log('ğŸ” [App.js] useFocusEffectì—ì„œ ìƒíƒœ ì—…ë°ì´íŠ¸ ì™„ë£Œ:', {
                    appointmentsLength: appointments.length,
                    markedDatesKeys: Object.keys(markedDates),
                    allEventsKeys: Object.keys(allEvents)
                });
                
                // ğŸš¨ ë””ë²„ê¹…: ë§ˆìš´íŠ¸ ì‹œ ìƒíƒœ ì—…ë°ì´íŠ¸ ì™„ë£Œ ë¡œê·¸
                console.log('ğŸ” [App.js] ë§ˆìš´íŠ¸ ì‹œ ìƒíƒœ ì—…ë°ì´íŠ¸ ì™„ë£Œ:', {
                    appointmentsLength: appointments.length,
                    markedDatesKeys: Object.keys(markedDates),
                    allEventsKeys: Object.keys(allEvents)
                });
                
                // ì „ì—­ ë³€ìˆ˜ ì´ˆê¸°í™”
                global.updatedPersonalSchedule = undefined;
                
                // ğŸš¨ ë””ë²„ê¹…: ë§ˆìš´íŠ¸ ì‹œ ìƒíƒœ ì—…ë°ì´íŠ¸ ì™„ë£Œ ë¡œê·¸
                console.log('ğŸ” [App.js] ë§ˆìš´íŠ¸ ì‹œ ìƒíƒœ ì—…ë°ì´íŠ¸ ì™„ë£Œ:', {
                    appointmentsLength: appointments.length,
                    markedDatesKeys: Object.keys(markedDates),
                    allEventsKeys: Object.keys(allEvents)
                });
                
                // ìˆ˜ì •ëœ ì¼ì • ì²˜ë¦¬ ì™„ë£Œ í›„ fetchHomeData ê±´ë„ˆë›°ê¸°
                return;
            }
            
            // ê°•ì œ ìƒˆë¡œê³ ì¹¨ í”Œë˜ê·¸ í™•ì¸
            if (global.forceRefreshHome && global.forceRefreshTimestamp) {
                console.log('ğŸ” [App.js] ê°•ì œ ìƒˆë¡œê³ ì¹¨ í”Œë˜ê·¸ ê°ì§€:', {
                    forceRefresh: global.forceRefreshHome,
                    timestamp: global.forceRefreshTimestamp
                });
                
                // ê°•ì œ ìƒˆë¡œê³ ì¹¨ ì‹¤í–‰
                console.log('ğŸ” [App.js] ê°•ì œ ìƒˆë¡œê³ ì¹¨ ì‹¤í–‰ ì¤‘...');
                fetchHomeData();
                
                // í”Œë˜ê·¸ ì´ˆê¸°í™”
                global.forceRefreshHome = false;
                global.forceRefreshTimestamp = undefined;
                
                return;
            }
            
            // ì „ì—­ ë³€ìˆ˜ê°€ ì—†ì„ ë•Œë§Œ ì„œë²„ API í˜¸ì¶œ
            if (!global.newPersonalSchedule && !global.newPartySchedule && !global.updatedPersonalSchedule) {
                // ì „ì—­ ë³€ìˆ˜ ì¼ì •ì´ ì—†ì„ ë•Œë§Œ fetchHomeData ì‹¤í–‰
                fetchHomeData();
            }
        });
        return unsubscribe;
    }, [navigation]));
    
    // ğŸš¨ ì¤‘ìš”: ìƒíƒœ ë³€ê²½ì„ ê°ì§€í•˜ì—¬ ë°±ì—…í•˜ëŠ” useEffect
    useEffect(() => {
        // appointmentsê°€ ë³€ê²½ë  ë•Œë§ˆë‹¤ ë°±ì—…
        if (appointments.length > 0) {
            global.backupAppointments = [...appointments];
            global.backupMarkedDates = { ...markedDates };
            global.backupAllEvents = { ...allEvents };
            
            // ğŸš¨ ì¤‘ìš”: ë¡œì»¬ ì €ì¥ì†Œì—ë„ ì˜êµ¬ ì €ì¥
            saveAppointmentsToStorage(appointments, markedDates, allEvents);
        }
    }, [appointments, markedDates, allEvents]);

    // ğŸš¨ ì¤‘ìš”: ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ ì‹œ ë¡œì»¬ ì €ì¥ì†Œì—ì„œ ë°ì´í„° ë³µì›
    useEffect(() => {
        const initializeData = async () => {
            await loadAppointmentsFromStorage();
        };
        
        initializeData();
    }, []); // ë§ˆìš´íŠ¸ ì‹œì—ë§Œ ì‹¤í–‰
    
    // ğŸš¨ ì¤‘ìš”: ì£¼ê¸°ì ìœ¼ë¡œ ì „ì—­ ë³€ìˆ˜ í™•ì¸ (updatedPersonalSchedule ê°ì§€ìš©)
    useEffect(() => {
        const interval = setInterval(() => {
            if (global.updatedPersonalSchedule && !isProcessingSchedule.current) {
                console.log('ğŸ” [App.js] ì£¼ê¸°ì  í™•ì¸ì—ì„œ ì „ì—­ ë³€ìˆ˜ ê°ì§€:', global.updatedPersonalSchedule);
                
                // ğŸš¨ ì¤‘ìš”: ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€
                isProcessingSchedule.current = true;
                
                const updatedSchedule = global.updatedPersonalSchedule;
                const originalDate = updatedSchedule.originalDate;
                const newDate = updatedSchedule.newDate;
                const scheduleData = updatedSchedule.schedule;
                const editMode = updatedSchedule.editMode;
                
                console.log('ğŸ” [App.js] ì£¼ê¸°ì  í™•ì¸ì—ì„œ ì²˜ë¦¬ ì‹œì‘:', {
                    originalDate,
                    newDate,
                    editMode,
                    scheduleId: scheduleData.id || scheduleData._id
                });
                
                // ğŸš¨ ì¤‘ìš”: ì „ì²´ ë°˜ë³µ ì¼ì • ìˆ˜ì •ì¸ì§€ í™•ì¸
                if (editMode === 'recurring_all') {
                    console.log('ğŸ” [App.js] ì£¼ê¸°ì  í™•ì¸ì—ì„œ ì „ì²´ ë°˜ë³µ ì¼ì • ìˆ˜ì • ê°ì§€');
                    console.log('ğŸ” [App.js] ë‚ ì§œ ë³€ê²½ ì •ë³´:', {
                        originalDate: originalDate,
                        newDate: newDate,
                        hasDateChange: originalDate !== newDate
                    });
                    
                    // ğŸš¨ ì¤‘ìš”: ë‚ ì§œê°€ ë³€ê²½ëœ ê²½ìš° ê¸°ì¡´ ë‚ ì§œì˜ ì¼ì •ì„ ìƒˆ ë‚ ì§œë¡œ ì´ë™
                    if (originalDate && newDate && originalDate !== newDate) {
                        console.log('ğŸ” [App.js] ì£¼ê¸°ì  í™•ì¸ì—ì„œ ë‚ ì§œ ë³€ê²½ ê°ì§€ - ê¸°ì¡´ ì¼ì •ì„ ìƒˆ ë‚ ì§œë¡œ ì´ë™');
                        
                        // 1. ê¸°ì¡´ ë‚ ì§œì—ì„œ ì¼ì • ì œê±°
                        setAppointments(prev => {
                            const newAppointments = prev.map(appointment => {
                                if (appointment.date === originalDate) {
                                    return {
                                        ...appointment,
                                        events: (appointment.events || []).filter(event => 
                                            event.id !== scheduleData.id && event._id !== scheduleData.id
                                        )
                                    };
                                }
                                return appointment;
                            }).filter(appointment => appointment.events && Array.isArray(appointment.events) && appointment.events.length > 0); // ë¹ˆ ë‚ ì§œ ì œê±°
                            
                            return newAppointments;
                        });
                        
                        // 2. ìƒˆ ë‚ ì§œì— ì¼ì • ì¶”ê°€
                        setAppointments(prev => {
                            const newAppointments = [...prev];
                            const existingDateIndex = newAppointments.findIndex(item => item.date === newDate);
                            
                            if (existingDateIndex >= 0) {
                                // ê¸°ì¡´ ë‚ ì§œì— ì¼ì • ì¶”ê°€
                                newAppointments[existingDateIndex].events.push({
                                    ...scheduleData,
                                    date: newDate
                                });
                            } else {
                                // ìƒˆë¡œìš´ ë‚ ì§œì— ì¼ì • ì¶”ê°€
                                newAppointments.push({
                                    date: newDate,
                                    events: [{
                                        ...scheduleData,
                                        date: newDate
                                    }]
                                });
                            }
                            
                            return newAppointments;
                        });
                        
                        // 3. allEvents ìƒíƒœë„ ë™ì¼í•˜ê²Œ ì—…ë°ì´íŠ¸
                        setAllEvents(prev => {
                            const newAllEvents = { ...prev };
                            
                            // ê¸°ì¡´ ë‚ ì§œì—ì„œ ì¼ì • ì œê±°
                            if (newAllEvents[originalDate] && Array.isArray(newAllEvents[originalDate])) {
                                newAllEvents[originalDate] = newAllEvents[originalDate].filter(event => 
                                    event.id !== scheduleData.id && event._id !== scheduleData.id
                                );
                                
                                // ë¹ˆ ë°°ì—´ì´ë©´ í•´ë‹¹ ë‚ ì§œ í‚¤ ì œê±°
                                if (newAllEvents[originalDate].length === 0) {
                                    delete newAllEvents[originalDate];
                                }
                            }
                            
                            // ìƒˆ ë‚ ì§œì— ì¼ì • ì¶”ê°€
                            if (newAllEvents[newDate]) {
                                newAllEvents[newDate].push({
                                    ...scheduleData,
                                    date: newDate
                                });
                            } else {
                                newAllEvents[newDate] = [{
                                    ...scheduleData,
                                    date: newDate
                                }];
                            }
                            
                            return newAllEvents;
                        });
                        
                        // 4. markedDates ì—…ë°ì´íŠ¸
                        setMarkedDates(prev => {
                            const newMarkedDates = { ...prev };
                            
                            // ê¸°ì¡´ ë‚ ì§œ ë§ˆí‚¹ ì œê±° (í•´ë‹¹ ë‚ ì§œì— ë‹¤ë¥¸ ì¼ì •ì´ ì—†ìœ¼ë©´)
                            if (newMarkedDates[originalDate]) {
                                // í•´ë‹¹ ë‚ ì§œì— ë‹¤ë¥¸ ì¼ì •ì´ ìˆëŠ”ì§€ í™•ì¸
                                const hasOtherEvents = appointments.some(appointment => 
                                    appointment.date === originalDate && 
                                    appointment.events.some(event => 
                                        event.id !== scheduleData.id && event._id !== scheduleData.id
                                    )
                                );
                                
                                if (!hasOtherEvents) {
                                    delete newMarkedDates[originalDate];
                                }
                            }
                            
                            // ìƒˆ ë‚ ì§œ ë§ˆí‚¹ ì¶”ê°€
                            newMarkedDates[newDate] = {
                                selected: true,
                                selectedColor: '#64748B' // ê¸°íƒ€ ì¼ì • ìƒ‰ìƒ
                            };
                            
                            return newMarkedDates;
                        });
                        
                        console.log('ğŸ” [App.js] ì£¼ê¸°ì  í™•ì¸ì—ì„œ ë‚ ì§œ ë³€ê²½ ì²˜ë¦¬ ì™„ë£Œ:', {
                            from: originalDate,
                            to: newDate
                        });
                    } else {
                        // ë‚ ì§œ ë³€ê²½ì´ ì—†ëŠ” ê²½ìš° - ê¸°ì¡´ ë¡œì§ (ë‚´ìš©ë§Œ ì—…ë°ì´íŠ¸)
                        console.log('ğŸ” [App.js] ë‚ ì§œ ë³€ê²½ ì—†ìŒ - ë‚´ìš©ë§Œ ì—…ë°ì´íŠ¸');
                        
                        // appointments ìƒíƒœ ì—…ë°ì´íŠ¸
                        setAppointments(prev => {
                            const newAppointments = [...prev];
                            let updateCount = 0;
                            
                            newAppointments.forEach(appointment => {
                                appointment.events = appointment.events.map(event => {
                                    if (event.id === scheduleData.id || event._id === scheduleData.id) {
                                        updateCount++;
                                        console.log('ğŸ” [App.js] ì£¼ê¸°ì  í™•ì¸ì—ì„œ ì¼ì • ì—…ë°ì´íŠ¸ë¨:', {
                                            date: appointment.date,
                                            eventId: event.id || event._id,
                                            oldTitle: event.title,
                                            newTitle: scheduleData.title
                                        });
                                        
                                        return {
                                            ...event,
                                            title: scheduleData.title,
                                            restaurant: scheduleData.restaurant,
                                            time: scheduleData.time,
                                            location: scheduleData.location,
                                            description: scheduleData.description,
                                            attendees: scheduleData.attendees,
                                            isRecurring: scheduleData.isRecurring,
                                            recurrenceType: scheduleData.recurrenceType,
                                            recurrenceInterval: scheduleData.recurrenceInterval,
                                            endType: scheduleData.endType,
                                            endDate: scheduleData.endDate
                                        };
                                    }
                                    return event;
                                });
                            });
                            
                            console.log('ğŸ” [App.js] ì£¼ê¸°ì  í™•ì¸ì—ì„œ appointments ì—…ë°ì´íŠ¸ ì™„ë£Œ, ì´', updateCount, 'ê°œ ì¼ì • ìˆ˜ì •ë¨');
                            return newAppointments;
                        });
                        
                        // allEvents ìƒíƒœë„ ì—…ë°ì´íŠ¸
                        setAllEvents(prev => {
                            const newAllEvents = { ...prev };
                            let updateCount = 0;
                            
                            Object.keys(newAllEvents).forEach(date => {
                                newAllEvents[date] = newAllEvents[date].map(event => {
                                    if (event.id === scheduleData.id || event._id === scheduleData.id) {
                                        updateCount++;
                                        console.log('ğŸ” [App.js] ì£¼ê¸°ì  í™•ì¸ì—ì„œ allEvents ì—…ë°ì´íŠ¸ë¨:', {
                                            date,
                                            eventId: event.id || event._id,
                                            oldTitle: event.title,
                                            newTitle: scheduleData.title
                                        });
                                        
                                        return {
                                            ...event,
                                            title: scheduleData.title,
                                            restaurant: scheduleData.restaurant,
                                            time: scheduleData.time,
                                            location: scheduleData.location,
                                            description: scheduleData.description,
                                            attendees: scheduleData.attendees,
                                            isRecurring: scheduleData.isRecurring,
                                            recurrenceType: scheduleData.recurrenceType,
                                            recurrenceInterval: scheduleData.recurrenceInterval,
                                            endType: scheduleData.endType,
                                            endDate: scheduleData.endDate
                                        };
                                    }
                                    return event;
                                });
                            });
                            
                            console.log('ğŸ” [App.js] ì£¼ê¸°ì  í™•ì¸ì—ì„œ allEvents ì—…ë°ì´íŠ¸ ì™„ë£Œ, ì´', updateCount, 'ê°œ ì¼ì • ìˆ˜ì •ë¨');
                            return newAllEvents;
                        });
                    }
                    
                    // ğŸš¨ ê°•ì œ ë¦¬ë Œë”ë§ì„ ìœ„í•œ ìƒíƒœ ì—…ë°ì´íŠ¸
                    setTimeout(() => {
                        setAppointments(prev => [...prev]);
                        setAllEvents(prev => ({ ...prev }));
                        console.log('ğŸ” [App.js] ì£¼ê¸°ì  í™•ì¸ì—ì„œ ê°•ì œ ë¦¬ë Œë”ë§ ì‹¤í–‰ë¨');
                    }, 100);
                    
                    // ì „ì—­ ë³€ìˆ˜ ì´ˆê¸°í™” ë° ì²˜ë¦¬ ì™„ë£Œ
                    global.updatedPersonalSchedule = undefined;
                    isProcessingSchedule.current = false;
                    
                    console.log('ğŸ” [App.js] ì£¼ê¸°ì  í™•ì¸ì—ì„œ ì²˜ë¦¬ ì™„ë£Œ');
                    return;
                }
                
                // ì¼ë°˜ ìˆ˜ì • ë˜ëŠ” ë‹¨ì¼ ë°˜ë³µ ì¼ì • ìˆ˜ì •: ë‚ ì§œ ë³€ê²½ ì²˜ë¦¬
                console.log('ğŸ” [App.js] ì£¼ê¸°ì  í™•ì¸ì—ì„œ ì¼ë°˜ ìˆ˜ì • ë˜ëŠ” ë‹¨ì¼ ë°˜ë³µ ì¼ì • ìˆ˜ì • ê°ì§€');
                
                // appointments ìƒíƒœ ì—…ë°ì´íŠ¸
                setAppointments(prev => {
                    const newAppointments = [...prev];
                    
                    // ì›ë˜ ë‚ ì§œì—ì„œ ì¼ì • ì œê±°
                    const originalDateIndex = newAppointments.findIndex(item => item.date === originalDate);
                    if (originalDateIndex >= 0) {
                        newAppointments[originalDateIndex] = {
                            ...newAppointments[originalDateIndex],
                            events: newAppointments[originalDateIndex].events.filter(event => 
                                event.id !== scheduleData.id && event._id !== scheduleData.id
                            )
                        };
                        
                        // ì´ë²¤íŠ¸ê°€ ì—†ì–´ì§„ ë‚ ì§œëŠ” ì œê±°
                        if (newAppointments[originalDateIndex].events.length === 0) {
                            newAppointments.splice(originalDateIndex, 1);
                        }
                    }
                    
                    // ìƒˆ ë‚ ì§œì— ì¼ì • ì¶”ê°€
                    const newDateIndex = newAppointments.findIndex(item => item.date === newDate);
                    if (newDateIndex >= 0) {
                        newAppointments[newDateIndex] = {
                            ...newAppointments[newDateIndex],
                            events: [...newAppointments[newDateIndex].events, scheduleData]
                        };
                    } else {
                        newAppointments.push({
                            date: newDate,
                            events: [scheduleData]
                        });
                    }
                    
                    return newAppointments;
                });
                
                // markedDates ìƒíƒœ ì—…ë°ì´íŠ¸
                setMarkedDates(prev => {
                    const newMarkedDates = { ...prev };
                    
                    // ì›ë˜ ë‚ ì§œ ë§ˆí‚¹ ì œê±°
                    if (newMarkedDates[originalDate]) {
                        delete newMarkedDates[originalDate];
                    }
                    
                    // ìƒˆ ë‚ ì§œ ë§ˆí‚¹ ì¶”ê°€
                    newMarkedDates[newDate] = {
                        selected: true,
                        selectedColor: '#64748B' // ê¸°íƒ€ ì¼ì • ìƒ‰ìƒ
                    };
                    
                    return newMarkedDates;
                });
                
                // allEvents ìƒíƒœ ì—…ë°ì´íŠ¸
                setAllEvents(prev => {
                    const newAllEvents = { ...prev };
                    
                    // ì›ë˜ ë‚ ì§œì—ì„œ ì¼ì • ì œê±°
                    if (newAllEvents[originalDate]) {
                        newAllEvents[originalDate] = newAllEvents[originalDate].filter(event => 
                            event.id !== scheduleData.id && event._id !== scheduleData.id
                        );
                        
                        // ì´ë²¤íŠ¸ê°€ ì—†ì–´ì§„ ë‚ ì§œëŠ” ì œê±°
                        if (newAllEvents[originalDate].length === 0) {
                            delete newAllEvents[originalDate];
                        }
                    }
                    
                    // ìƒˆ ë‚ ì§œì— ì¼ì • ì¶”ê°€
                    if (newAllEvents[newDate]) {
                        newAllEvents[newDate] = [...newAllEvents[newDate], scheduleData];
                    } else {
                        newAllEvents[newDate] = [scheduleData];
                    }
                    
                    return newAllEvents;
                });
                
                // ğŸš¨ ì¤‘ìš”: ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€ í•´ì œ
                isProcessingSchedule.current = false;
                
                // ì „ì—­ ë³€ìˆ˜ ì´ˆê¸°í™”
                global.updatedPersonalSchedule = undefined;
                
                console.log('ğŸ” [App.js] ì£¼ê¸°ì  í™•ì¸ì—ì„œ ìƒíƒœ ì—…ë°ì´íŠ¸ ì™„ë£Œ');
            }
        }, 500); // 500msë§ˆë‹¤ í™•ì¸
        
        return () => clearInterval(interval);
    }, []);
    
    // ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ ì‹œ ì¦‰ì‹œ ì „ì—­ ë³€ìˆ˜ í™•ì¸ (fetchHomeDataë³´ë‹¤ ë¨¼ì € ì‹¤í–‰)
    useEffect(() => {
        // ì»´í¬ë„ŒíŠ¸ ë§ˆìš´íŠ¸ ì‹œ ì¦‰ì‹œ ì²´í¬ ì‹œì‘
        // ì „ì—­ ë³€ìˆ˜ ìƒíƒœ
        
                    // ì „ì—­ ë³€ìˆ˜ì—ì„œ ìƒˆë¡œìš´ ì¼ì • í™•ì¸
            if (global.newPersonalSchedule) {
                // ë§ˆìš´íŠ¸ ì‹œ ì „ì—­ ë³€ìˆ˜ ì¼ì • ê°ì§€
                
                const newSchedule = global.newPersonalSchedule;
                const dateString = newSchedule.date;
                
                // appointments ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                setAppointments(prev => {
                    const newAppointments = [...prev];
                    const existingDateIndex = newAppointments.findIndex(item => item.date === dateString);
                    
                    if (existingDateIndex >= 0) {
                        newAppointments[existingDateIndex] = {
                            ...newAppointments[existingDateIndex],
                            events: [...newAppointments[existingDateIndex].events, newSchedule]
                        };
                                                // console.log('ğŸ” [í™ˆíƒ­] ë§ˆìš´íŠ¸ ì‹œ: ê¸°ì¡´ ë‚ ì§œì— ì¼ì • ì¶”ê°€');
                    } else {
                        newAppointments.push({
                            date: dateString,
                            events: [newSchedule]
                        });
                                                // console.log('ğŸ” [í™ˆíƒ­] ë§ˆìš´íŠ¸ ì‹œ: ìƒˆë¡œìš´ ë‚ ì§œì— ì¼ì • ì¶”ê°€');
                    }
                    
                    return newAppointments;
                });
                
                // markedDates ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                setMarkedDates(prev => {
                    const newMarkedDates = { ...prev };
                    newMarkedDates[dateString] = {
                        selected: true,
                        selectedColor: currentColors.gray
                    };
                    return newMarkedDates;
                });
                
                // allEvents ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                setAllEvents(prev => {
                    const newAllEvents = { ...prev };
                    if (newAllEvents[dateString]) {
                        newAllEvents[dateString] = [...newAllEvents[dateString], newSchedule];
                    } else {
                        newAllEvents[dateString] = [newSchedule];
                    }
                    return newAllEvents;
                });
                
                // ì „ì—­ ë³€ìˆ˜ ì´ˆê¸°í™”
                global.newPersonalSchedule = undefined;
                                // console.log('ğŸ” [í™ˆíƒ­] ë§ˆìš´íŠ¸ ì‹œ ì „ì—­ ë³€ìˆ˜ ì¼ì • ì²˜ë¦¬ ì™„ë£Œ');
            }

            // ì „ì—­ ë³€ìˆ˜ì—ì„œ ìˆ˜ì •ëœ ì¼ì • í™•ì¸
            if (global.updatedPersonalSchedule) {
                // ğŸš¨ ë””ë²„ê¹…: ë§ˆìš´íŠ¸ ì‹œ ì „ì—­ ë³€ìˆ˜ ì¡´ì¬ í™•ì¸
                console.log('ğŸ” [App.js] ë§ˆìš´íŠ¸ ì‹œ ì „ì—­ ë³€ìˆ˜ ì¡´ì¬ í™•ì¸:', {
                    hasGlobalVar: !!global.updatedPersonalSchedule,
                    globalVarContent: global.updatedPersonalSchedule
                });
                
                const updatedSchedule = global.updatedPersonalSchedule;
                const originalDate = updatedSchedule.originalDate;
                const newDate = updatedSchedule.newDate;
                const scheduleData = updatedSchedule.schedule;
                
                // ğŸš¨ ë””ë²„ê¹…: ë§ˆìš´íŠ¸ ì‹œ ì „ì—­ ë³€ìˆ˜ ê°ì§€ ë¡œê·¸
                console.log('ğŸ” [App.js] ë§ˆìš´íŠ¸ ì‹œ ì „ì—­ ë³€ìˆ˜ ê°ì§€:', {
                    originalDate,
                    newDate,
                    scheduleId: scheduleData.id || scheduleData._id,
                    timestamp: updatedSchedule.timestamp
                });
                
                // appointments ìƒíƒœ ì—…ë°ì´íŠ¸
                setAppointments(prev => {
                    const newAppointments = [...prev];
                    
                    // ì›ë˜ ë‚ ì§œì—ì„œ ì¼ì • ì œê±°
                    const originalDateIndex = newAppointments.findIndex(item => item.date === originalDate);
                    if (originalDateIndex >= 0) {
                        newAppointments[originalDateIndex] = {
                            ...newAppointments[originalDateIndex],
                            events: newAppointments[originalDateIndex].events.filter(event => 
                                event.id !== scheduleData.id && event._id !== scheduleData.id
                            )
                        };
                        
                        // ì´ë²¤íŠ¸ê°€ ì—†ì–´ì§„ ë‚ ì§œëŠ” ì œê±°
                        if (newAppointments[originalDateIndex].events.length === 0) {
                            newAppointments.splice(originalDateIndex, 1);
                        }
                    }
                    
                    // ìƒˆ ë‚ ì§œì— ì¼ì • ì¶”ê°€
                    const newDateIndex = newAppointments.findIndex(item => item.date === newDate);
                    if (newDateIndex >= 0) {
                        newAppointments[newDateIndex] = {
                            ...newAppointments[newDateIndex],
                            events: [...newAppointments[newDateIndex].events, scheduleData]
                        };
                    } else {
                        newAppointments.push({
                            date: newDate,
                            events: [scheduleData]
                        });
                    }
                    
                    return newAppointments;
                });
                
                // markedDates ìƒíƒœ ì—…ë°ì´íŠ¸
                setMarkedDates(prev => {
                    const newMarkedDates = { ...prev };
                    
                    // ì›ë˜ ë‚ ì§œ ë§ˆí‚¹ ì œê±°
                    if (newMarkedDates[originalDate]) {
                        delete newMarkedDates[originalDate];
                    }
                    
                    // ìƒˆ ë‚ ì§œ ë§ˆí‚¹ ì¶”ê°€
                    newMarkedDates[newDate] = {
                        selected: true,
                        selectedColor: currentColors.gray
                    };
                    
                    return newMarkedDates;
                });
                
                // allEvents ìƒíƒœ ì—…ë°ì´íŠ¸
                setAllEvents(prev => {
                    const newAllEvents = { ...prev };
                    
                    // ì›ë˜ ë‚ ì§œì—ì„œ ì¼ì • ì œê±°
                    if (newAllEvents[originalDate]) {
                        newAllEvents[originalDate] = newAllEvents[originalDate].filter(event => 
                            event.id !== scheduleData.id && event._id !== scheduleData.id
                        );
                        
                        // ì´ë²¤íŠ¸ê°€ ì—†ì–´ì§„ ë‚ ì§œëŠ” ì œê±°
                        if (newAllEvents[originalDate].length === 0) {
                            delete newAllEvents[originalDate];
                        }
                    }
                    
                    // ìƒˆ ë‚ ì§œì— ì¼ì • ì¶”ê°€
                    if (newAllEvents[newDate]) {
                        newAllEvents[newDate] = [...newAllEvents[newDate], scheduleData];
                    } else {
                        newAllEvents[newDate] = [scheduleData];
                    }
                    
                    return newAllEvents;
                });
                
                // ì „ì—­ ë³€ìˆ˜ ì´ˆê¸°í™”
                global.updatedPersonalSchedule = undefined;
            }
        
        // ğŸš¨ ì¤‘ìš”: ì „ì—­ ë³€ìˆ˜ì—ì„œ ìƒˆë¡œìš´ íŒŒí‹° í™•ì¸
        if (global.newPartySchedule) {
                            // console.log('ğŸ” [í™ˆíƒ­] ë§ˆìš´íŠ¸ ì‹œ ì „ì—­ ë³€ìˆ˜ ìƒˆ íŒŒí‹° ê°ì§€:', global.newPartySchedule);
            
            const newParty = global.newPartySchedule;
            const dateString = newParty.date;
            
                            // console.log('ğŸ” [í™ˆíƒ­] ë§ˆìš´íŠ¸ ì‹œ ìƒˆ íŒŒí‹° ë‚ ì§œ:', dateString);
                // console.log('ğŸ” [í™ˆíƒ­] ë§ˆìš´íŠ¸ ì‹œ ìƒˆ íŒŒí‹° ì œëª©:', newParty.title);
            
            // appointments ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
            setAppointments(prev => {
                const newAppointments = [...prev];
                const existingDateIndex = newAppointments.findIndex(item => item.date === dateString);
                
                if (existingDateIndex >= 0) {
                    newAppointments[existingDateIndex] = {
                        ...newAppointments[existingDateIndex],
                        events: [...newAppointments[existingDateIndex].events, newParty]
                    };
                                            // console.log('ğŸ” [í™ˆíƒ­] ë§ˆìš´íŠ¸ ì‹œ: ê¸°ì¡´ ë‚ ì§œì— ìƒˆ íŒŒí‹° ì¶”ê°€');
                } else {
                    newAppointments.push({
                        date: dateString,
                        events: [newParty]
                    });
                                            // console.log('ğŸ” [í™ˆíƒ­] ë§ˆìš´íŠ¸ ì‹œ: ìƒˆë¡œìš´ ë‚ ì§œì— ìƒˆ íŒŒí‹° ì¶”ê°€');
                }
                
                // console.log('ğŸ” [í™ˆíƒ­] ë§ˆìš´íŠ¸ ì‹œ: ì—…ë°ì´íŠ¸ëœ appointments:', newAppointments);
                return newAppointments;
            });
            
            // markedDates ìƒíƒœ ì—…ë°ì´íŠ¸
            setMarkedDates(prev => {
                const newMarkedDates = { ...prev };
                // ëœë¤ëŸ°ì¹˜ íŒŒí‹°ì¸ì§€ í™•ì¸í•˜ì—¬ ìƒ‰ìƒ ê²°ì •
                const isRandomLunch = newParty && newParty.is_from_match === true;
                const selectedColor = isRandomLunch ? '#F4D160' : currentColors.primary; // ëœë¤ëŸ°ì¹˜ëŠ” ë…¸ë€ìƒ‰, ì¼ë°˜ íŒŒí‹°ëŠ” íŒŒë€ìƒ‰
                
                newMarkedDates[dateString] = {
                    selected: true,
                    selectedColor: selectedColor
                };
                // console.log('ğŸ” [í™ˆíƒ­] ë§ˆìš´íŠ¸ ì‹œ: ì—…ë°ì´íŠ¸ëœ markedDates:', newMarkedDates);
                return newMarkedDates;
            });
            
            // allEvents ìƒíƒœ ì—…ë°ì´íŠ¸
            setAllEvents(prev => {
                const newAllEvents = { ...prev };
                if (newAllEvents[dateString]) {
                    newAllEvents[dateString] = [...newAllEvents[dateString], newParty];
                } else {
                    newAllEvents[dateString] = [newParty];
                }
                // console.log('ğŸ” [í™ˆíƒ­] ë§ˆìš´íŠ¸ ì‹œ: ì—…ë°ì´íŠ¸ëœ allEvents:', newAllEvents);
                return newAllEvents;
            });
            
            // ì „ì—­ ë³€ìˆ˜ ì´ˆê¸°í™”
            global.newPartySchedule = undefined;
                            // console.log('ğŸ” [í™ˆíƒ­] ë§ˆìš´íŠ¸ ì‹œ ì „ì—­ ë³€ìˆ˜ ìƒˆ íŒŒí‹° ì²˜ë¦¬ ì™„ë£Œ');
        }
        
        if (!global.newPersonalSchedule && !global.newPartySchedule) {
                            // console.log('ğŸ” [í™ˆíƒ­] ë§ˆìš´íŠ¸ ì‹œ ì „ì—­ ë³€ìˆ˜ì— ìƒˆ ì¼ì •/íŒŒí‹° ì—†ìŒ');
        }
    }, []); // ë¹ˆ ì˜ì¡´ì„± ë°°ì—´ë¡œ ë§ˆìš´íŠ¸ ì‹œì—ë§Œ ì‹¤í–‰
    
    // ê¸°íƒ€ ì¼ì • ì¶”ê°€ í›„ í™ˆ ë°ì´í„° ìƒˆë¡œê³ ì¹¨ì„ ìœ„í•œ route params ë¦¬ìŠ¤ë„ˆ
    useEffect(() => {
        if (route.params?.refreshHomeData) {
            // console.log('ğŸ” [í™ˆíƒ­] ê¸°íƒ€ ì¼ì • ì¶”ê°€ ê°ì§€, í™ˆ ë°ì´í„° ìƒˆë¡œê³ ì¹¨ ì‹œì‘');
            // console.log('ğŸ” [í™ˆíƒ­] ìƒˆë¡œê³ ì¹¨ íƒ€ì„ìŠ¤íƒ¬í”„:', route.params.refreshTimestamp);
            // console.log('ğŸ” [í™ˆíƒ­] ìƒˆë¡œìš´ ì¼ì • ë°ì´í„°:', route.params.newScheduleData);
            // console.log('ğŸ” [í™ˆíƒ­] ì¦‰ì‹œ ì—…ë°ì´íŠ¸ í”Œë˜ê·¸:', route.params.immediateUpdate);
            
            // ì¦‰ì‹œ ì—…ë°ì´íŠ¸ê°€ í•„ìš”í•œ ê²½ìš° ë¡œì»¬ ìƒíƒœì— ë¨¼ì € ì¶”ê°€
            if (route.params?.immediateUpdate && route.params?.newScheduleData) {
                // console.log('ğŸ” [í™ˆíƒ­] ì¦‰ì‹œ ë¡œì»¬ ìƒíƒœ ì—…ë°ì´íŠ¸ ì‹œì‘');
                const newSchedule = route.params.newScheduleData;
                
                // ë‚ ì§œ í˜•ì‹ í†µì¼ (YYYY-MM-DD í˜•ì‹ìœ¼ë¡œ)
                let dateString;
                try {
                    if (newSchedule.date && typeof newSchedule.date === 'string') {
                        // ì´ë¯¸ YYYY-MM-DD í˜•ì‹ì¸ ê²½ìš°
                        if (/^\d{4}-\d{2}-\d{2}$/.test(newSchedule.date)) {
                            dateString = newSchedule.date;
                        } else {
                            // ë‹¤ë¥¸ í˜•ì‹ì¸ ê²½ìš° Date ê°ì²´ë¡œ ë³€í™˜
                            const scheduleDate = new Date(newSchedule.date);
                            dateString = scheduleDate.toISOString().split('T')[0];
                        }
                    } else {
                        // ë‚ ì§œê°€ ì—†ëŠ” ê²½ìš° í˜„ì¬ ë‚ ì§œ ì‚¬ìš©
                        dateString = new Date().toISOString().split('T')[0];
                    }
                } catch (error) {
                    console.error('ğŸ” [í™ˆíƒ­] ë‚ ì§œ ë³€í™˜ ì˜¤ë¥˜:', error);
                    dateString = new Date().toISOString().split('T')[0];
                }
                
                // console.log('ğŸ” [í™ˆíƒ­] ì›ë³¸ ë‚ ì§œ:', newSchedule.date);
                // console.log('ğŸ” [í™ˆíƒ­] ë³€í™˜ëœ ë‚ ì§œ ë¬¸ìì—´:', dateString);
                
                // appointments ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                setAppointments(prev => {
                    const newAppointments = [...prev];
                    const existingDateIndex = newAppointments.findIndex(item => item.date === dateString);
                    
                    if (existingDateIndex >= 0) {
                        // ê¸°ì¡´ ë‚ ì§œì— ì¶”ê°€
                        newAppointments[existingDateIndex] = {
                            ...newAppointments[existingDateIndex],
                            events: [...newAppointments[existingDateIndex].events, newSchedule]
                        };
                        // console.log('ğŸ” [í™ˆíƒ­] ê¸°ì¡´ ë‚ ì§œì— ì¼ì • ì¶”ê°€:', existingDateIndex);
                    } else {
                        // ìƒˆë¡œìš´ ë‚ ì§œ ì¶”ê°€
                        newAppointments.push({
                            date: dateString,
                            events: [newSchedule]
                        });
                        // console.log('ğŸ” [í™ˆíƒ­] ìƒˆë¡œìš´ ë‚ ì§œì— ì¼ì • ì¶”ê°€');
                    }
                    
                    // console.log('ğŸ” [í™ˆíƒ­] ì—…ë°ì´íŠ¸ëœ appointments:', newAppointments);
                    return newAppointments;
                });
                
                // markedDates ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                setMarkedDates(prev => {
                    const newMarkedDates = { ...prev };
                    newMarkedDates[dateString] = {
                        selected: true,
                        selectedColor: currentColors.gray  // ê¸°íƒ€ ì¼ì •ì€ íšŒìƒ‰
                    };
                    // console.log('ğŸ” [í™ˆíƒ­] ì—…ë°ì´íŠ¸ëœ markedDates:', newMarkedDates);
                    return newMarkedDates;
                });
                
                // allEvents ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                setAllEvents(prev => {
                    const newAllEvents = { ...prev };
                    if (newAllEvents[dateString]) {
                        newAllEvents[dateString] = [...newAllEvents[dateString], newSchedule];
                    } else {
                        newAllEvents[dateString] = [newSchedule];
                    }
                    // console.log('ğŸ” [í™ˆíƒ­] ì—…ë°ì´íŠ¸ëœ allEvents:', newAllEvents);
                    return newAllEvents;
                });
                
                                    // console.log('ğŸ” [í™ˆíƒ­] ë¡œì»¬ ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸ ì™„ë£Œ');
            }
            
            // ì„œë²„ì—ì„œ ìµœì‹  ë°ì´í„° ê°€ì ¸ì˜¤ê¸° (ì•½ê°„ì˜ ì§€ì—° í›„)
            setTimeout(() => {
                // console.log('ğŸ” [í™ˆíƒ­] ì„œë²„ ë°ì´í„° ë™ê¸°í™” ì‹œì‘');
                fetchHomeData();
            }, 1000);
            
            // íŒŒë¼ë¯¸í„° ì´ˆê¸°í™”
            navigation.setParams({ 
                refreshHomeData: undefined, 
                refreshTimestamp: undefined,
                newScheduleData: undefined,
                immediateUpdate: undefined
            });
        }
    }, [route.params?.refreshHomeData, route.params?.refreshTimestamp]);
    
    // ğŸš¨ ì¤‘ìš”: allEvents ìƒíƒœ ë³€í™”ë¥¼ ê°ì§€í•˜ì—¬ markedDates ìë™ ë™ê¸°í™”
    useEffect(() => {
        if (allEvents && typeof allEvents === 'object') {
            const newMarkedDates = generateMarkedDatesFromAllEvents();
            setMarkedDates(newMarkedDates);
            
            // AsyncStorageì—ë„ ì €ì¥
            try {
                AsyncStorage.setItem('@marked_dates', JSON.stringify(newMarkedDates));
            } catch (storageError) {
                console.error('ğŸ” [useEffect] AsyncStorage markedDates ì €ì¥ ì˜¤ë¥˜:', storageError);
            }
        }
    }, [allEvents]);
    
    // ì „ì—­ ë³€ìˆ˜ì—ì„œ ìƒˆë¡œìš´ ì¼ì • í™•ì¸ (ë°±ì—… ë°©ë²•)
    useEffect(() => {
        if (global.newPersonalSchedule) {

            
            const newSchedule = global.newPersonalSchedule;
            const dateString = newSchedule.date;
            

            
            // appointments ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
            setAppointments(prev => {
                const newAppointments = [...prev];
                const existingDateIndex = newAppointments.findIndex(item => item.date === dateString);
                
                if (existingDateIndex >= 0) {
                    // ê¸°ì¡´ ë‚ ì§œì— ì¶”ê°€
                    newAppointments[existingDateIndex] = {
                        ...newAppointments[existingDateIndex],
                        events: [...newAppointments[existingDateIndex].events, newSchedule]
                    };

                } else {
                    // ìƒˆë¡œìš´ ë‚ ì§œ ì¶”ê°€
                    newAppointments.push({
                        date: dateString,
                        events: [newSchedule]
                    });

                }
                

                return newAppointments;
            });
            
            // markedDates ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
            setMarkedDates(prev => {
                const newMarkedDates = { ...prev };
                newMarkedDates[dateString] = {
                    selected: true,
                    selectedColor: currentColors.gray
                };

                return newMarkedDates;
            });
            
            // allEvents ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
            setAllEvents(prev => {
                const newAllEvents = { ...prev };
                if (newAllEvents[dateString]) {
                    newAllEvents[dateString] = [...newAllEvents[dateString], newSchedule];
                } else {
                    newAllEvents[dateString] = [newSchedule];
                }

                return newAllEvents;
            });
            
            // ì „ì—­ ë³€ìˆ˜ ì´ˆê¸°í™”
            global.newPersonalSchedule = undefined;

        }
    }, []);
    
    // ì „ì—­ ë³€ìˆ˜ í™•ì¸ì„ ìœ„í•œ ì£¼ê¸°ì  ì²´í¬ (ì¶”ê°€ ë°±ì—…)
    useEffect(() => {
        const checkGlobalSchedule = () => {
            if (global.newPersonalSchedule) {

                
                const newSchedule = global.newPersonalSchedule;
                const dateString = newSchedule.date;
                

                
                // appointments ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                setAppointments(prev => {
                    const newAppointments = [...prev];
                    const existingDateIndex = newAppointments.findIndex(item => item.date === dateString);
                    
                    if (existingDateIndex >= 0) {
                        newAppointments[existingDateIndex] = {
                            ...newAppointments[existingDateIndex],
                            events: [...newAppointments[existingDateIndex].events, newSchedule]
                        };
                    } else {
                        newAppointments.push({
                            date: dateString,
                            events: [newSchedule]
                        });
                    }
                    
                    return newAppointments;
                });
                
                // markedDates ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                setMarkedDates(prev => {
                    const newMarkedDates = { ...prev };
                    newMarkedDates[dateString] = {
                        selected: true,
                        selectedColor: currentColors.gray
                    };
                    return newMarkedDates;
                });
                
                // allEvents ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
                setAllEvents(prev => {
                    const newAllEvents = { ...prev };
                    if (newAllEvents[dateString]) {
                        newAllEvents[dateString] = [...newAllEvents[dateString], newSchedule];
                    } else {
                        newAllEvents[dateString] = [newSchedule];
                    }
                    return newAllEvents;
                });
                
                // ì „ì—­ ë³€ìˆ˜ ì´ˆê¸°í™”
                global.newPersonalSchedule = undefined;
                // console.log('ğŸ” [í™ˆíƒ­] ì£¼ê¸°ì  ì²´í¬ ì „ì—­ ë³€ìˆ˜ ì¼ì • ì²˜ë¦¬ ì™„ë£Œ');
            }
        };
        
        // ì¦‰ì‹œ í•œ ë²ˆ ì²´í¬
        checkGlobalSchedule();
        
        // 1ì´ˆ í›„ ë‹¤ì‹œ ì²´í¬
        const timer = setTimeout(checkGlobalSchedule, 1000);
        
        return () => clearTimeout(timer);
    }, []);
    
    // ì „ì—­ ë³€ìˆ˜ í™•ì¸ì„ ìœ„í•œ ê°„ë‹¨í•œ ì²´í¬
    useEffect(() => {
        // ì»´í¬ë„ŒíŠ¸ê°€ ë§ˆìš´íŠ¸ëœ í›„ ì¦‰ì‹œ í™•ì¸
        const immediateCheck = () => {
            // ê°„ë‹¨í•œ ì²´í¬ ì‹œì‘
            // ì „ì—­ ë³€ìˆ˜ ìƒíƒœ
            
            // ì „ì—­ ë³€ìˆ˜ í™•ì¸
            if (global.newPersonalSchedule) {
                // ì „ì—­ ë³€ìˆ˜ì—ì„œ ì¼ì • ê°ì§€
                processNewSchedule(global.newPersonalSchedule, 'ì „ì—­ ë³€ìˆ˜');
                global.newPersonalSchedule = undefined;
                return;
            }
            
            // ì „ì—­ ë³€ìˆ˜ì— ìƒˆ ì¼ì • ì—†ìŒ
        };
        
        // ìƒˆë¡œìš´ ì¼ì • ì²˜ë¦¬ í•¨ìˆ˜ (ê°„ë‹¨í•œ ë²„ì „)
        const processNewSchedule = (newSchedule, source) => {
            const dateString = newSchedule.date;
            
            // ğŸš¨ ì¤‘ìš”: ë¡œì»¬ ì¼ì •ì— ê³ ìœ  ID ìƒì„± (ì‚­ì œ ê¸°ëŠ¥ì„ ìœ„í•´)
            const scheduleWithId = {
                ...newSchedule,
                id: newSchedule.id || `local_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                _id: newSchedule._id || newSchedule.id || `local_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
            };
            
                    // console.log('ğŸ” [processNewSchedule] IDê°€ ì¶”ê°€ëœ ì¼ì •:', scheduleWithId);
        // console.log('ğŸ” [processNewSchedule] attendees ë°ì´í„°:', scheduleWithId.attendees);
        // console.log('ğŸ” [processNewSchedule] ì¼ì • íƒ€ì…:', scheduleWithId.scheduleType || 'ê¸°íƒ€ ì¼ì •');
            
            // appointments ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
            setAppointments(prev => {
                const newAppointments = [...prev];
                const existingDateIndex = newAppointments.findIndex(item => item.date === dateString);
                
                if (existingDateIndex >= 0) {
                    // ê¸°ì¡´ ë‚ ì§œì— ì¼ì • ì¶”ê°€
                    const existingEvents = newAppointments[existingDateIndex].events || [];
                    newAppointments[existingDateIndex] = {
                        ...newAppointments[existingDateIndex],
                        events: [...existingEvents, scheduleWithId]
                    };
                } else {
                    // ìƒˆë¡œìš´ ë‚ ì§œì— ì¼ì • ì¶”ê°€
                    newAppointments.push({
                        date: dateString,
                        events: [scheduleWithId]
                    });
                }
                
                                        // console.log('ğŸ” [processNewSchedule] appointments ì—…ë°ì´íŠ¸ ì™„ë£Œ:', newAppointments.length, 'ê°œ ë‚ ì§œ');
                return newAppointments;
            });
            
            // markedDates ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
            setMarkedDates(prev => {
                const newMarkedDates = { ...prev };
                newMarkedDates[dateString] = {
                    selected: true,
                    selectedColor: '#64748B' // ê¸°íƒ€ ì¼ì • ìƒ‰ìƒ
                };
                                        // console.log('ğŸ” [processNewSchedule] markedDates ì—…ë°ì´íŠ¸ ì™„ë£Œ:', dateString);
                return newMarkedDates;
            });
            
            // allEvents ìƒíƒœ ì¦‰ì‹œ ì—…ë°ì´íŠ¸
            setAllEvents(prev => {
                const newAllEvents = { ...prev };
                if (newAllEvents[dateString]) {
                    newAllEvents[dateString] = [...newAllEvents[dateString], scheduleWithId];
                } else {
                    newAllEvents[dateString] = [scheduleWithId];
                }
                                        // console.log('ğŸ” [processNewSchedule] allEvents ì—…ë°ì´íŠ¸ ì™„ë£Œ:', dateString, 'ì—', newAllEvents[dateString]?.length || 0, 'ê°œ ì¼ì •');
                return newAllEvents;
            });
            
            // ì¼ì • ì²˜ë¦¬ ì™„ë£Œ
            console.log('âœ… [processNewSchedule] ì¼ì • ì²˜ë¦¬ ì™„ë£Œ:', dateString);
        };
        
        // ì¦‰ì‹œ ì‹¤í–‰
        immediateCheck();
        
        // ì¶”ê°€ ì§€ì—° ì²´í¬ (2ì´ˆ, 5ì´ˆ í›„)
        const timer1 = setTimeout(immediateCheck, 2000);
        const timer2 = setTimeout(immediateCheck, 5000);
        
        return () => {
            clearTimeout(timer1);
            clearTimeout(timer2);
        };
    }, []);
    
    // í†µí•© ì•½ì† ìƒì„±ê¸°ì—ì„œ ìƒì„±ëœ ì•½ì†ì„ í™ˆ í™”ë©´ì— ë°˜ì˜
    const handleAppointmentCreated = useCallback((newAppointment) => {
        // ë¡œì»¬ ìƒíƒœì— ì¦‰ì‹œ ì¶”ê°€ (Optimistic Update)
        const appointmentDate = newAppointment.date;
        setAppointments(prev => ({
            ...prev,
            [appointmentDate]: [
                ...(prev[appointmentDate] || []),
                newAppointment
            ]
        }));
        
        // ë‹¬ë ¥ ë§ˆí‚¹ ì—…ë°ì´íŠ¸
        setMarkedDates(prev => ({
            ...prev,
            [appointmentDate]: {
                selected: true,
                selectedColor: newAppointment.type === 'ëœë¤ ëŸ°ì¹˜' ? '#F4D160' : 
                              newAppointment.type === 'ê°œì¸ ì¼ì •' ? '#64748B' : '#3B82F6'
            }
        }));
        
        // ì „ì²´ ì´ë²¤íŠ¸ ë°ì´í„° ì—…ë°ì´íŠ¸
        setAllEvents(prev => ({
            ...prev,
            [appointmentDate]: [
                ...(prev[appointmentDate] || []),
                newAppointment
            ]
        }));
        
        // ì„œë²„ì™€ ë™ê¸°í™”
        fetchHomeData();
    }, []);

    const handleEditPersonalSchedule = (event, editMode = 'single') => {
        setModalData({ visible: false, events: [] });
        safeNavigateToTab(navigation, 'íŒŒí‹°', 'EditPersonalSchedule', { 
            schedule: event, 
            editMode: editMode 
        });
    };

    const handleDeletePersonalSchedule = (scheduleId, eventData = null, deleteMode = 'single') => {
        // ï¿½ï¿½ ìˆ˜ì •: deleteModeë¥¼ ì§ì ‘ ì‚¬ìš©
        if (deleteMode === 'single') {
            // ë‹¨ì¼ ì¼ì • ì‚­ì œ
            deleteSchedule(scheduleId, 'single', eventData);
        } else if (deleteMode === 'all') {
            // ëª¨ë“  ë°˜ë³µ ì¼ì • ì‚­ì œ
            deleteSchedule(scheduleId, 'all', eventData);
        } else {
            // deleteModeê°€ ì—†ìœ¼ë©´ ê¸°ì¡´ ë¡œì§ ì‚¬ìš© (í•˜ìœ„ í˜¸í™˜ì„±)
        const isRecurring = eventData?.is_recurring || false;
        
        if (isRecurring) {
            Alert.alert(
                "ë°˜ë³µ ì¼ì • ì‚­ì œ", 
                "ì´ ì¼ì •ì€ ë°˜ë³µ ì¼ì •ì…ë‹ˆë‹¤. ì–´ë–»ê²Œ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?",
                [
                    { text: "ì·¨ì†Œ", style: "cancel" },
                    { 
                        text: "ì´ ë‚ ì§œë§Œ ì‚­ì œ", 
                        onPress: () => deleteSchedule(scheduleId, 'single', eventData)
                    },
                    { 
                        text: "ëª¨ë“  ë°˜ë³µ ì¼ì • ì‚­ì œ", 
                        style: "destructive",
                        onPress: () => deleteSchedule(scheduleId, 'all', eventData)
                    }
                ]
            );
        } else {
            Alert.alert("ì¼ì • ì‚­ì œ", "ì •ë§ë¡œ ì´ ì ì‹¬ ì•½ì†ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?", [
                { text: "ì·¨ì†Œ", style: "cancel" },
                { text: "ì‚­ì œ", style: "destructive", onPress: () => deleteSchedule(scheduleId, 'single', eventData) }
            ]);
            }
        }
    };

    const deleteSchedule = async (scheduleId, deleteMode, eventData = null) => {
        try {


            // scheduleId ìœ íš¨ì„± ê²€ì‚¬
            if (!scheduleId) {
                console.error('âŒ [ì‚­ì œ] scheduleIdê°€ ì—†ìŠµë‹ˆë‹¤:', scheduleId);
                Alert.alert("ì˜¤ë¥˜", "ì¼ì • IDë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ì¼ì • ë°ì´í„°ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.");
                return;
            }

            // ğŸš¨ ì¤‘ìš”: ë¡œì»¬ ì¼ì •ì¸ì§€ í™•ì¸ (local_ ë˜ëŠ” temp_ë¡œ ì‹œì‘í•˜ëŠ” ID)
            const isLocalSchedule = scheduleId.toString().startsWith('local_') || scheduleId.toString().startsWith('temp_');
            
            // ì¤‘ìš”: deleteMode === 'all'ì´ë©´ í•´ë‹¹ ë°˜ë³µ ì¼ì •ì˜ ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤ë§Œ ì‚­ì œ
            if (isLocalSchedule && deleteMode === 'all') {
                // ë¡œì»¬ ì¼ì •ì˜ ëª¨ë“  ë°˜ë³µ ì¼ì • ì‚­ì œ
                console.log('ï¿½ï¿½ [ì‚­ì œ] ë¡œì»¬ ì¼ì • ëª¨ë“  ë°˜ë³µ ì¼ì • ì‚­ì œ:', scheduleId);
                
                // í•´ë‹¹ ë°˜ë³µ ì¼ì •ì˜ ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì°¾ì•„ì„œ ì‚­ì œ
                const targetScheduleId = scheduleId;
                const targetSchedule = eventData;
                
                if (!targetSchedule) {
                    console.error('âŒ [ì‚­ì œ] ë°˜ë³µ ì¼ì • ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                    Alert.alert("ì˜¤ë¥˜", "ë°˜ë³µ ì¼ì • ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                    return;
                }
                
                // 1ë‹¨ê³„: appointmentsì—ì„œ í•´ë‹¹ ë°˜ë³µ ì¼ì •ì˜ ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤ ì œê±°
                setAppointments(prev => {
                    const newAppointments = prev.map(item => {
                        const filteredEvents = (item.events || []).filter(event => {
                            const eventId = event.id || event._id || event.local_id;
                            // ê°™ì€ ë°˜ë³µ ì¼ì •ì¸ì§€ í™•ì¸ (IDê°€ ê°™ê±°ë‚˜ ê°™ì€ ë°˜ë³µ ê·¸ë£¹ì— ì†í•˜ëŠ”ì§€)
                            const isSameRecurringSchedule = eventId === targetScheduleId || 
                                (event.isRecurring && event.recurrenceType === targetSchedule.recurrenceType && 
                                 event.recurrenceInterval === targetSchedule.recurrenceInterval &&
                                 event.title === targetSchedule.title &&
                                 event.restaurant === targetSchedule.restaurant);
                            
                            return !isSameRecurringSchedule;
                        });
                        
                        return {
                            ...item,
                            events: filteredEvents
                        };
                    }).filter(item => item.events && Array.isArray(item.events) && item.events.length > 0); // ì¼ì •ì´ ì—†ëŠ” ë‚ ì§œëŠ” ì œê±°
                    
                    return newAppointments;
                });
                
                // 2ë‹¨ê³„: allEventsì—ì„œ í•´ë‹¹ ë°˜ë³µ ì¼ì •ì˜ ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤ ì œê±°
                setAllEvents(prev => {
                    const newAllEvents = { ...prev };
                    
                    Object.keys(newAllEvents).forEach(dateString => {
                        if (newAllEvents[dateString] && Array.isArray(newAllEvents[dateString])) {
                            const filteredEvents = newAllEvents[dateString].filter(event => {
                                const eventId = event.id || event._id || event.local_id;
                                // ê°™ì€ ë°˜ë³µ ì¼ì •ì¸ì§€ í™•ì¸
                                const isSameRecurringSchedule = eventId === targetScheduleId || 
                                    (event.isRecurring && event.recurrenceType === targetSchedule.recurrenceType && 
                                     event.recurrenceInterval === targetSchedule.recurrenceInterval &&
                                     event.title === targetSchedule.title &&
                                     event.restaurant === targetSchedule.restaurant);
                                
                                return !isSameRecurringSchedule;
                            });
                            
                            newAllEvents[dateString] = filteredEvents;
                            
                            // í•´ë‹¹ ë‚ ì§œì— ì¼ì •ì´ ì—†ìœ¼ë©´ ë‚ ì§œ ìì²´ë„ ì œê±°
                            if (filteredEvents.length === 0) {
                                delete newAllEvents[dateString];
                            }
                        }
                    });
                    
                    return newAllEvents;
                });
                
                // 3ë‹¨ê³„: markedDatesì—ì„œ í•´ë‹¹ ë°˜ë³µ ì¼ì •ê³¼ ê´€ë ¨ëœ ë‚ ì§œë“¤ ì œê±°
                setMarkedDates(prev => {
                    const newMarkedDates = { ...prev };
                    
                    // allEventsì—ì„œ ì œê±°ëœ ë‚ ì§œë“¤ì„ markedDatesì—ì„œë„ ì œê±°
                    Object.keys(newMarkedDates).forEach(dateString => {
                        if (!global.allEvents || !global.allEvents[dateString] || global.allEvents[dateString].length === 0) {
                            delete newMarkedDates[dateString];
                        }
                    });
                    
                    return newMarkedDates;
                });
                
                // ì „ì—­ ë³€ìˆ˜ ì—…ë°ì´íŠ¸
                global.allEvents = {};
                
                // AsyncStorageì—ì„œë„ í•´ë‹¹ ë°˜ë³µ ì¼ì • ê´€ë ¨ ë°ì´í„°ë§Œ ì‚­ì œ
                try {
                    await AsyncStorage.removeItem('@all_events');
                    await AsyncStorage.removeItem('@appointments');
                    await AsyncStorage.removeItem('@marked_dates');
                } catch (storageError) {
                    console.error('ğŸ” [ì‚­ì œ] AsyncStorage ì‚­ì œ ì˜¤ë¥˜:', storageError);
                }
                
                Alert.alert("ì„±ê³µ", "í•´ë‹¹ ë°˜ë³µ ì¼ì •ì˜ ëª¨ë“  ì¸ìŠ¤í„´ìŠ¤ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.");
                setModalData({ visible: false, events: [] });
                return;
            }
            
            // ì¤‘ìš”: deleteMode === 'single'ì´ê³  ë¡œì»¬ ì¼ì •ì¸ ê²½ìš°
            if (isLocalSchedule && deleteMode === 'single') {
                // ë¡œì»¬ ì¼ì • ì‚­ì œ (ë°±ì—”ë“œ API í˜¸ì¶œ ì—†ìŒ)

                
                // ë¡œì»¬ ìƒíƒœì—ì„œ ì¼ì • ì œê±°
                const targetDate = eventData?.date;
                if (targetDate) {

                    
                    // 1ë‹¨ê³„: appointmentsì—ì„œ ì œê±°
                    setAppointments(prev => {

                        const newAppointments = prev.map(item => {
                            if (item.date === targetDate) {
                                const filteredEvents = (item.events || []).filter(event => {
                                    const eventId = event.id || event._id || event.local_id;
                                    const shouldKeep = eventId !== scheduleId;
                                    if (!shouldKeep) {

                                    }
                                    return shouldKeep;
                                });
                                

                                
                                return {
                                    ...item,
                                    events: filteredEvents
                                };
                            }
                            return item;
                        });
                        

                        return newAppointments;
                    });

                    // 2ë‹¨ê³„: allEventsì—ì„œ ì œê±° (markedDatesëŠ” useEffectê°€ ìë™ ë™ê¸°í™”)
                    setAllEvents(prev => {
                        const newAllEvents = { ...prev };
                        
                        if (newAllEvents[targetDate] && Array.isArray(newAllEvents[targetDate])) {
                            const filteredEvents = newAllEvents[targetDate].filter(event => {
                                const eventId = event.id || event._id || event.local_id;
                                const shouldKeep = eventId !== scheduleId;
                                return shouldKeep;
                            });
                            
                            newAllEvents[targetDate] = filteredEvents;
                            
                            // í•´ë‹¹ ë‚ ì§œì— ì¼ì •ì´ ì—†ìœ¼ë©´ ë‚ ì§œ ìì²´ë„ ì œê±°
                            if (filteredEvents.length === 0) {
                                delete newAllEvents[targetDate];
                            }
                        }
                        
                        // ğŸš¨ ì¤‘ìš”: useEffectê°€ allEvents ë³€í™”ë¥¼ ê°ì§€í•˜ì—¬ markedDates ìë™ ë™ê¸°í™”
                        return newAllEvents;
                    });
                }

                Alert.alert("ì„±ê³µ", "í•´ë‹¹ ë‚ ì§œì˜ ì¼ì •ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.");
                setModalData({ visible: false, events: [] });
                
                // ğŸš¨ ì¤‘ìš”: useEffectê°€ ìë™ìœ¼ë¡œ markedDates ë™ê¸°í™”í•˜ë¯€ë¡œ ìˆ˜ë™ ë™ê¸°í™” ë¶ˆí•„ìš”
                return;
            }

            // ë°±ì—”ë“œ APIë¥¼ í†µí•œ ì‚­ì œ (ê¸°ì¡´ ë¡œì§)
            const token = global.accessToken;
            if (!token) {
                Alert.alert("ì˜¤ë¥˜", "ì¸ì¦ í† í°ì´ ì—†ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ë¡œê·¸ì¸í•´ì£¼ì„¸ìš”.");
                return;
            }

            // ì‚­ì œ ìš”ì²­ ë°ì´í„° ì¤€ë¹„
            const deleteData = {
                delete_mode: deleteMode
            };

            // ë°˜ë³µ ì¼ì •ì˜ íŠ¹ì • ë‚ ì§œë§Œ ì‚­ì œí•˜ëŠ” ê²½ìš°, í•´ë‹¹ ë‚ ì§œ ì •ë³´ ì¶”ê°€
            if (deleteMode === 'single' && eventData?.date) {
                deleteData.target_date = eventData.date;
            }

            const apiUrl = `${RENDER_SERVER_URL}/personal_schedules/${scheduleId}`;


            const response = await fetch(apiUrl, { 
                method: 'DELETE',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(deleteData)
            });
            

            
            // ì‘ë‹µ ë³¸ë¬¸ í™•ì¸
            let responseData = null;
            try {
                responseData = await response.json();

            } catch (parseError) {
                console.log(' [ì‚­ì œ] ì‘ë‹µ ë³¸ë¬¸ íŒŒì‹± ì‹¤íŒ¨ (ì •ìƒì ì¸ ê²½ìš°)');
            }
            
            if (response.ok) {
                const message = deleteMode === 'single' ? 'í•´ë‹¹ ë‚ ì§œì˜ ì¼ì •ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.' : 'ëª¨ë“  ë°˜ë³µ ì¼ì •ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.';
                Alert.alert("ì„±ê³µ", message);
                setModalData({ visible: false, events: [] });
                
                // ğŸš¨ ì¤‘ìš”: ë°˜ë³µ ì¼ì • ì‚­ì œ í›„ ìƒíƒœ ì™„ì „ ì´ˆê¸°í™”
                if (deleteMode === 'all') {

                    
                    // ì „ì—­ ë³€ìˆ˜ ë°ì´í„° ì™„ì „ ì´ˆê¸°í™”
                    global.allEvents = {};
                    global.newScheduleData = undefined;
                    global.newPersonalSchedule = undefined;
                    
                    // ë¡œì»¬ ìƒíƒœ ì¦‰ì‹œ ì´ˆê¸°í™”
                    setAllEvents({});
                    setAppointments([]);
                    setMarkedDates({});
                    
                    // AsyncStorageì—ì„œë„ ì‚­ì œ
                    try {
                        await AsyncStorage.removeItem('@all_events');
                        await AsyncStorage.removeItem('@appointments');
                        await AsyncStorage.removeItem('@marked_dates');

                    } catch (storageError) {
                        console.error('ğŸ” [ì‚­ì œ] AsyncStorage ì‚­ì œ ì˜¤ë¥˜:', storageError);
                    }
                    
                    // ğŸš¨ ì¤‘ìš”: fetchHomeData() í˜¸ì¶œí•˜ì§€ ì•ŠìŒ - ë¡œì»¬ ìƒíƒœë§Œ ì‚¬ìš©

                                } else if (deleteMode === 'single') {
                    // ğŸš¨ ì¤‘ìš”: íŠ¹ì • ë‚ ì§œë§Œ ì‚­ì œí•œ ê²½ìš°
                    // fetchHomeData() í˜¸ì¶œí•˜ì§€ ì•ŠìŒ - ë¡œì»¬ ìƒíƒœë§Œ ì‚¬ìš©
                    // useEffectê°€ allEvents ë³€í™”ë¥¼ ê°ì§€í•˜ì—¬ markedDates ìë™ ë™ê¸°í™”
                }
            } else {
                let errorMessage = "ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.";
                try {
                const errorData = await response.json();
                    errorMessage = errorData.message || errorData.error || errorMessage;
                } catch (parseError) {
                    console.error('âŒ [ì‚­ì œ] ì‘ë‹µ íŒŒì‹± ì˜¤ë¥˜:', parseError);
                }
                
                console.error('âŒ [ì‚­ì œ] API ì˜¤ë¥˜:', response.status, errorMessage);
                Alert.alert("ì‚­ì œ ì‹¤íŒ¨", `ì˜¤ë¥˜ ì½”ë“œ: ${response.status}\n${errorMessage}`);
            }
        } catch (error) {
            console.error('âŒ [ì‚­ì œ] ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜:', error);
            Alert.alert("ì˜¤ë¥˜", `ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ${error.message}`);
        }
    };
        // allEventsì—ì„œ appointments ë°ì´í„° ìƒì„± (ë°˜ë³µ ì¼ì • í¬í•¨)
    const generateAppointmentsFromAllEvents = () => {
        // ğŸš¨ ì¤‘ìš”: í•œêµ­ ì‹œê°„ ê¸°ì¤€ìœ¼ë¡œ ì˜¤ëŠ˜ ë‚ ì§œ ê°€ì ¸ì˜¤ê¸°
        const today = getKoreanToday();
        

        
        const appointments = [];
        
        // ì˜¤ëŠ˜ë¶€í„° 7ì¼ê°„ì˜ ì¹´ë“œë¥¼ í•­ìƒ ìƒì„±
        for (let i = 0; i < 7; i++) {
            const date = new Date(today);
            date.setDate(today.getDate() + i);
            const dateString = date.toISOString().split('T')[0];
            
            
            
            // allEventsì—ì„œ í•´ë‹¹ ë‚ ì§œì˜ ì¼ì • ê°€ì ¸ì˜¤ê¸°
            const events = allEvents && allEvents[dateString] ? allEvents[dateString] : [];
            
            appointments.push({
                date: dateString,
                events: events
            });
        }
        

        
        return appointments;
    };

    // allEventsì—ì„œ markedDates ë°ì´í„° ìƒì„± (ë‹¬ë ¥ ë™ê·¸ë¼ë¯¸ìš©)
    const generateMarkedDatesFromAllEvents = () => {
        const newMarkedDates = {};
        
        if (allEvents && typeof allEvents === 'object') {
            Object.keys(allEvents).forEach(dateString => {
                const events = allEvents[dateString];
                if (events && Array.isArray(events) && events.length > 0) {
                    // í•´ë‹¹ ë‚ ì§œì— ì¼ì •ì´ ìˆìœ¼ë©´ ë§ˆí‚¹
                    // ê¸°íƒ€ ì¼ì •(ê°œì¸ ì¼ì •)ì€ íšŒìƒ‰, íŒŒí‹° ì¼ì •ì€ íŒŒë€ìƒ‰, ëœë¤ëŸ°ì¹˜ëŠ” ë…¸ë€ìƒ‰ìœ¼ë¡œ í‘œì‹œ
                    const hasPartySchedule = events.some(event => event.type === 'party' || event.isParty);
                    const hasPersonalSchedule = events.some(event => 
                        !event.type || 
                        event.type === 'personal' || 
                        !event.isParty || 
                        event.scheduleType === 'ê¸°íƒ€ ì¼ì •'
                    );
                    // ëœë¤ëŸ°ì¹˜ í™•ì •ëœ ì¼ì • íŒë‹¨ ì¡°ê±´ ê°œì„ 
                    const hasRandomLunch = events.some(event => 
                        event.is_from_match === true || 
                        event.type === 'ëœë¤ ëŸ°ì¹˜' ||
                        event.scheduleType === 'ëœë¤ ëŸ°ì¹˜' ||
                        (event.type === 'party' && event.is_from_match === true) ||
                        (event.type === 'party' && event.status === 'confirmed' && event.is_from_match === true)
                    );
                    
                    let selectedColor = '#3B82F6'; // ê¸°ë³¸ íŒŒë€ìƒ‰
                    
                    if (hasRandomLunch) {
                        // ëœë¤ëŸ°ì¹˜ê°€ ìˆëŠ” ê²½ìš° ë…¸ë€ìƒ‰ (ìµœìš°ì„ )
                        selectedColor = '#F4D160'; // ë…¸ë€ìƒ‰
                        console.log('ğŸ” [ë‹¬ë ¥ë§ˆí¬] ëœë¤ëŸ°ì¹˜ ë…¸ë€ìƒ‰ ë§ˆí¬:', dateString, events.filter(e => 
                            e.is_from_match === true || 
                            e.type === 'ëœë¤ ëŸ°ì¹˜' ||
                            e.scheduleType === 'ëœë¤ ëŸ°ì¹˜'
                        ));
                        
                        // ëœë¤ëŸ°ì¹˜ ì¼ì •ì˜ ê²½ìš° ê¸€ììƒ‰ì„ ë‚¨ìƒ‰ìœ¼ë¡œ ì„¤ì •
                        newMarkedDates[dateString] = {
                            selected: true,
                            selectedColor: selectedColor,
                            textColor: '#1D5D9B' // ë‚¨ìƒ‰ ê¸€ììƒ‰
                        };
                    } else if (hasPersonalSchedule && !hasPartySchedule) {
                        // ê¸°íƒ€ ì¼ì •ë§Œ ìˆëŠ” ê²½ìš° íšŒìƒ‰
                        selectedColor = '#64748B'; // ê¸°íƒ€ ì¼ì • ìƒ‰ìƒ
                        newMarkedDates[dateString] = {
                            selected: true,
                            selectedColor: selectedColor
                        };
                    } else if (hasPartySchedule) {
                        // íŒŒí‹° ì¼ì •ì´ ìˆëŠ” ê²½ìš° íŒŒë€ìƒ‰
                        selectedColor = '#3B82F6'; // íŒŒë€ìƒ‰
                        newMarkedDates[dateString] = {
                            selected: true,
                            selectedColor: selectedColor
                        };
                    }
                }
            });
        }
        
        return newMarkedDates;
    };
    
    // ğŸš¨ ì¤‘ìš”: ì˜ëª»ëœ markedDates ì •ë¦¬ í•¨ìˆ˜
    const cleanupInvalidMarkedDates = () => {
        if (!allEvents || !markedDates) return;
        
        const allEventDates = Object.keys(allEvents);
        const markedDateKeys = Object.keys(markedDates);
        
        // allEventsì— ì—†ëŠ” ë‚ ì§œì˜ markedDates ì œê±°
        const invalidDates = markedDateKeys.filter(date => !allEventDates.includes(date));
        
        if (invalidDates.length > 0) {
                            // console.log('ğŸ” [cleanupInvalidMarkedDates] ì˜ëª»ëœ markedDates ë°œê²¬:', invalidDates);
            
            setMarkedDates(prev => {
                const newMarkedDates = { ...prev };
                invalidDates.forEach(date => {
                    delete newMarkedDates[date];
                });
                return newMarkedDates;
            });
            
                            // console.log('ğŸ” [cleanupInvalidMarkedDates] ì˜ëª»ëœ markedDates ì •ë¦¬ ì™„ë£Œ');
        }
    };

    // ğŸš¨ ì¤‘ìš”: allEvents ìƒíƒœ ë³€í™” ê°ì§€í•˜ì—¬ markedDates ë™ê¸°í™”
    useEffect(() => {
        if (allEvents && Object.keys(allEvents).length > 0) {
            
            
            const newMarkedDates = generateMarkedDatesFromAllEvents();
            setMarkedDates(newMarkedDates);
            
            // AsyncStorageì—ë„ ì €ì¥
            try {
                AsyncStorage.setItem('@marked_dates', JSON.stringify(newMarkedDates));
    
            } catch (storageError) {
                console.error('ğŸ” [useEffect] AsyncStorage markedDates ì €ì¥ ì˜¤ë¥˜:', storageError);
            }
        }
    }, [allEvents]);

    // ê¸°ë³¸ ì•½ì† ìƒìë“¤ ìƒì„± (ì•½ì† ë°ì´í„°ê°€ ì—†ì„ ë•Œ ì‚¬ìš©)
    const generateDefaultAppointments = () => {
        const defaultAppointments = [];
        const today = getKoreanToday();
        
        // ì˜¤ëŠ˜ë¶€í„° 7ì¼ê°„ì˜ ê¸°ë³¸ ë‚ ì§œ ìƒì„±
        for (let i = 0; i < 7; i++) {
            const date = new Date(today);
            date.setDate(today.getDate() + i);
            const dateString = date.toISOString().split('T')[0];
            
            defaultAppointments.push({
                date: dateString,
                events: [] // ë¹ˆ ì´ë²¤íŠ¸ ë°°ì—´
            });
        }
        
        return defaultAppointments;
    };

    const renderAppointmentItem = ({ item }) => {
        const date = new Date(item.date);
        const dayOfWeek = ['ì¼', 'ì›”', 'í™”', 'ìˆ˜', 'ëª©', 'ê¸ˆ', 'í† '][date.getDay()];
        return (
            <TouchableOpacity style={styles.appointmentCard}             onPress={() => { 
                setModalData({ visible: true, events: item.events || [], date: item.date }); 
            }}>
                <View style={styles.appointmentHeader}>
                    <Text style={styles.appointmentDate}>{`${date.getDate()}ì¼ (${dayOfWeek})`}</Text>
                </View>
                {item.events && item.events.length > 0 ? (
                    item.events.map((event, index) => {
                        // ì°¸ì„ìì—ì„œ ë‚´ ë‹‰ë„¤ì„ ì œì™¸ (userManager ì‚¬ìš©)
                        const currentNickname = global.myNickname || 'ì‚¬ìš©ì';
                        
                        // ê¸°íƒ€ ì¼ì •ì˜ attendees í•„ë“œ ì²˜ë¦¬
                        let others = [];
                        if (event.attendees && Array.isArray(event.attendees)) {
                            // ê¸°íƒ€ ì¼ì •: attendees ë°°ì—´ì—ì„œ nickname ì¶”ì¶œ
                            others = event.attendees
                                .map(attendee => attendee.nickname || attendee.name)
                                .filter(name => name && name.toLowerCase() !== currentNickname.trim().toLowerCase());
                        } else if (event.all_members || event.members) {
                            // íŒŒí‹° ì¼ì •: ê¸°ì¡´ ë°©ì‹
                            others = (event.all_members || event.members || []).map(s => s.trim()).filter(name => name.toLowerCase() !== currentNickname.trim().toLowerCase());
                        }
                        
                        // descriptionì—ì„œ ì‹œê°„, ì‹ë‹¹, ì°¸ì„ì íŒŒì‹± (í•„ë“œê°€ ì—†ì„ ë•Œë§Œ)
                        let parsedTime = event.time;
                        let parsedRestaurant = event.restaurant;
                        let parsedLocation = event.location;
                        
                        if ((!parsedTime || !parsedRestaurant || !parsedLocation || others.length === 0) && event.description) {
                            // ìƒˆë¡œìš´ í˜•ì‹ íŒŒì‹± (ëª¨ì´ëŠ” ì‹œê°„, ëª¨ì´ëŠ” ì¥ì†Œ)
                            const timeMatch = event.description.match(/ğŸ• ëª¨ì´ëŠ” ì‹œê°„: ([^\n]+)/) || event.description.match(/ì‹œê°„: ([^\n]+)/);
                            const restaurantMatch = event.description.match(/ğŸ½ï¸ ì‹ë‹¹: ([^\n]+)/);
                            const locationMatch = event.description.match(/ğŸ“ ëª¨ì´ëŠ” ì¥ì†Œ: ([^\n]+)/) || event.description.match(/ì¥ì†Œ: ([^\n]+)/);
                            const attendeesMatch = event.description.match(/ğŸ‘¥ ì°¸ì„ì: ([^\n]+)/) || event.description.match(/ì°¸ê°€ì: ([^\n]+)/);
                            
                            if (!parsedTime && timeMatch) parsedTime = timeMatch[1].trim();
                            if (!parsedRestaurant && restaurantMatch) parsedRestaurant = restaurantMatch[1].trim();
                            if (!parsedLocation && locationMatch) parsedLocation = locationMatch[1].trim();
                            if (others.length === 0 && attendeesMatch) {
                                // ì°¸ì„ìì—ì„œ (ìˆ«ìëª…) ì œê±°í•˜ê³  íŒŒì‹±
                                const attendeesText = attendeesMatch[1].replace(/\s*\(\d+ëª…\)$/, '');
                                others = attendeesText.split(',').map(s => s.trim()).filter(name => name && name.toLowerCase() !== currentNickname.trim().toLowerCase());
                            }
                        }
                        return (
                            <View key={index} style={styles.eventItem}>
                                <Text style={styles.eventTitle} numberOfLines={1}>
                                    {event.type === 'ëœë¤ ëŸ°ì¹˜' ? 'âš¡ï¸' : 
                                     (event.type === 'íŒŒí‹°' || event.isParty) ? 'ğŸ‰' : 
                                     (event.scheduleType === 'ê¸°íƒ€ ì¼ì •' || !event.type) ? 'ğŸ“' : 'ğŸ“'} {event.title}
                                </Text>
                                {/* ì‹œê°„ í‘œì‹œ */}
                                {parsedTime && <Text style={styles.eventDetail} numberOfLines={1}>â° {parsedTime}</Text>}
                                {/* ì‹ë‹¹ í‘œì‹œ */}
                                {parsedRestaurant && <Text style={styles.eventDetail} numberOfLines={1}>ğŸ½ï¸ {parsedRestaurant}</Text>}
                                {/* ëª¨ì´ëŠ” ì¥ì†Œ í‘œì‹œ */}
                                {parsedLocation && <Text style={styles.eventDetail} numberOfLines={1}>ğŸ“ {parsedLocation}</Text>}
                                {/* ì°¸ì„ì(ë‚´ ë‹‰ë„¤ì„ ì œì™¸) */}
                                {others.length > 0 && <Text style={styles.eventDetail} numberOfLines={1}>ğŸ‘¥ {others.join(', ')}</Text>}
                            </View>
                        );
                    })
                ) : (<View style={{flex: 1, justifyContent: 'center'}}><Text style={styles.noAppointmentText}>ì•½ì† ì—†ìŒ</Text></View>)}
            </TouchableOpacity>
        );
    };

    const renderRandomLunchCard = () => {
        return (
            <TouchableOpacity style={{
                backgroundColor: currentColors.primary,
                borderRadius: 20,
                marginHorizontal: 16,
                marginBottom: 16,
                padding: 20,
                elevation: 3,
                shadowColor: currentColors.primary,
                shadowOffset: { width: 0, height: 4 },
                shadowOpacity: 0.1,
                shadowRadius: 8,
                borderWidth: 1,
                borderColor: 'rgba(59, 130, 246, 0.1)'
            }} onPress={handleMatchPress}>
                <View style={{flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center'}}>
                    <Text style={{color: '#FFFFFF', fontSize: 20, fontWeight: 'bold', marginBottom: 12}}>ëœë¤ ëŸ°ì¹˜ ğŸ²</Text>
                    <Ionicons name="shuffle" size={28} color="#FFFFFF" />
                </View>
                <Text style={{color: '#FFFFFF', fontSize: 16, marginTop: 8}}>ìƒˆë¡œìš´ ë™ë£Œì™€ ì ì‹¬ ì•½ì†ì„ ì¡ì•„ë³´ì„¸ìš”!</Text>
            </TouchableOpacity>
        );
    };
    
    return (
        <SafeAreaView style={styles.safeArea}>
            <ScrollView contentContainerStyle={styles.homeContainer}>
                <View style={{
                    backgroundColor: currentColors.surface,
                    borderRadius: 20,
                    marginHorizontal: 16,
                    marginBottom: 16,
                    marginTop: 14,
                    padding: 20,
                    elevation: 3,
                    shadowColor: currentColors.primary,
                    shadowOffset: { width: 0, height: 4 },
                    shadowOpacity: 0.1,
                    shadowRadius: 8,
                    borderWidth: 1,
                    borderColor: 'rgba(59, 130, 246, 0.1)'
                }}>
                    <Text style={styles.cardTitle}>ì˜¤ëŠ˜ì˜ êµ¬ë‚´ì‹ë‹¹ ë©”ë‰´ ğŸ±</Text>
                    <Text style={styles.menuText}>{(todayMenu || []).length > 0 ? todayMenu.join(', ') : 'ë©”ë‰´ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤.'}</Text>
                </View>
                {renderRandomLunchCard()}
                
                <View style={{
                    backgroundColor: currentColors.surface,
                    borderRadius: 20,
                    marginHorizontal: 16,
                    marginBottom: 16,
                    padding: 20,
                    elevation: 3,
                    shadowColor: currentColors.primary,
                    shadowOffset: { width: 0, height: 4 },
                    shadowOpacity: 0.1,
                    shadowRadius: 8,
                    borderWidth: 1,
                    borderColor: 'rgba(59, 130, 246, 0.1)'
                }}>
                    <Text style={styles.cardTitle}>ë‚˜ì˜ ì ì‹¬ ì•½ì† ğŸ—“ï¸</Text>
                    <FlatList 
                        data={generateAppointmentsFromAllEvents()} 
                        renderItem={renderAppointmentItem} 
                        keyExtractor={item => item.date} 
                        horizontal 
                        showsHorizontalScrollIndicator={false} 
                        contentContainerStyle={{ paddingVertical: 5 }} 
                    />
                </View>
                <View style={{
                    backgroundColor: currentColors.surface,
                    borderRadius: 20,
                    marginHorizontal: 16,
                    marginBottom: 16,
                    padding: 20,
                    elevation: 3,
                    shadowColor: currentColors.primary,
                    shadowOffset: { width: 0, height: 4 },
                    shadowOpacity: 0.1,
                    shadowRadius: 8,
                    borderWidth: 1,
                    borderColor: 'rgba(59, 130, 246, 0.1)'
                }}>
                    <Text style={styles.cardTitle}>ë‹¬ë ¥ ğŸ“…</Text>
                    <Calendar 
                        markedDates={markedDates} 
                        maxDate={new Date(Date.now() + 15 * 365 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]} // 15ë…„ í›„ê¹Œì§€
                        onDayPress={(day) => { 
                            try {
                                // ğŸš¨ ì¤‘ìš”: ì•ˆì „í•œ í—¬í¼ í•¨ìˆ˜ ì‚¬ìš©
                                const validEvents = getSafeEventsForDate(day.dateString);
                            
                                // console.log('ğŸ” [Calendar] onDayPress - ë‚ ì§œ:', day.dateString, 'ì´ë²¤íŠ¸ ìˆ˜:', validEvents.length);
                            
                                // ë‚ ì§œ í´ë¦­ ì‹œ ëª¨ë‹¬ ë°ì´í„° ì„¤ì •
                            setModalData({ visible: true, events: validEvents, date: day.dateString }); 
                            } catch (error) {
                                console.error('ğŸ” [Calendar] onDayPress ì˜¤ë¥˜:', error);
                                setModalData({ visible: true, events: [], date: day.dateString });
                            }
                        }} 
                        theme={{ 
                            selectedDayBackgroundColor: currentColors.primary, 
                            todayTextColor: currentColors.primary, 
                            arrowColor: currentColors.primary,
                            selectedDayTextColor: '#FFFFFF',
                            'stylesheet.calendar.header': { 
                                week: { 
                                    marginTop: 5, 
                                    flexDirection: 'row', 
                                    justifyContent: 'space-between' 
                                } 
                            },
                            'stylesheet.day.basic': {
                                base: {
                                    width: 32,
                                    height: 32,
                                    alignItems: 'center',
                                    justifyContent: 'center'
                                }
                            },
                            'stylesheet.day.single': {
                                base: {
                                    width: 32,
                                    height: 32,
                                    alignItems: 'center',
                                    justifyContent: 'center'
                                },
                                selected: {
                                    backgroundColor: 'transparent',
                                    borderRadius: 16,
                                    borderWidth: 2,
                                    borderColor: 'transparent'
                                }
                            },
                            // ëœë¤ëŸ°ì¹˜ ì¼ì •ì˜ ê¸€ììƒ‰ì„ ë‚¨ìƒ‰ìœ¼ë¡œ ì„¤ì •
                            'stylesheet.day.marked': {
                                base: {
                                    width: 32,
                                    height: 32,
                                    alignItems: 'center',
                                    justifyContent: 'center'
                                }
                            }
                        }} 
                    />
                </View>
            </ScrollView>

            {/* ìƒˆë¡œìš´ ì¼ì • ìƒì„¸ ëª¨ë‹¬ */}
            <ScheduleDetailModal
                visible={modalData.visible && (modalData.events || []).length > 0}
                onClose={() => setModalData({ ...modalData, visible: false })}
                events={modalData.events || []}
                date={modalData.date}
                navigation={navigation}
                onEdit={handleEditPersonalSchedule}
                onDelete={handleDeletePersonalSchedule}
            />

            {/* ê¸°ì¡´ ì¼ì • ì¶”ê°€ ì˜µì…˜ ëª¨ë‹¬ */}
            <Modal 
                visible={modalData.visible && (!modalData.events || modalData.events.length === 0)} 
                transparent={true} 
                animationType="fade" 
                onRequestClose={() => setModalData({ ...modalData, visible: false })}
            >
                <Pressable style={styles.centeredView} onPress={() => setModalData({ ...modalData, visible: false })}>
                    <Pressable style={styles.modalView} onPress={(e) => e.stopPropagation()}>
                        {/* ì¼ì • ì¶”ê°€ ì˜µì…˜ë§Œ í‘œì‹œ */} 
                            <>
                                <Text style={styles.modalTitle}>ì ì‹¬ ì•½ì†ì„ ë§Œë“¤ì–´ ë³¼ê¹Œìš”?</Text>
                                <View style={styles.appointmentOptionsContainer}>
                                    <TouchableOpacity style={[styles.appointmentOptionButton, {backgroundColor: currentColors.yellow}]} onPress={() => { setModalData({ visible: false }); handleMatchPress(); }}>
                                        <View style={styles.optionContent}>
                                            <Text style={[styles.optionTitle, {color: currentColors.deepBlue}]}>ğŸ² ëœë¤ ëŸ°ì¹˜</Text>
                                            <Text style={[styles.optionSubtitle, {color: currentColors.deepBlue}]}>AIê°€ ì¶”ì²œí•˜ëŠ” ë™ë£Œì™€ í•¨ê»˜</Text>
                                        </View>
                                        <Ionicons name="chevron-forward" size={20} color={currentColors.deepBlue} />
                                    </TouchableOpacity>
                                    
                                    <TouchableOpacity style={[styles.appointmentOptionButton, {backgroundColor: currentColors.primary}]} onPress={() => { setModalData({ visible: false }); safeNavigateToTab(navigation, 'íŒŒí‹°', 'CreateParty'); }}>
                                        <View style={styles.optionContent}>
                                            <Text style={[styles.optionTitle, {color: '#FFFFFF'}]}>ğŸ‰ ê·¸ë£¹ íŒŒí‹°</Text>
                                            <Text style={[styles.optionSubtitle, {color: '#FFFFFF'}]}>ê°€ê³  ì‹¶ì€ ë§›ì§‘ì— ê·¸ë£¹ ì‚¬ëƒ¥ì„</Text>
                                        </View>
                                        <Ionicons name="chevron-forward" size={20} color="#FFFFFF" />
                                    </TouchableOpacity>
                                    
                                    <TouchableOpacity style={[styles.appointmentOptionButton, {backgroundColor: currentColors.secondary}]} onPress={() => { 
                                        setModalData({ visible: false }); 
                                        safeNavigateToTab(navigation, 'ì†Œí†µ', 'VotingScreen', {
                                            chatRoomId: -1,
                                            chatTitle: '',
                                            participants: [{ 
                                                employee_id: user.employee_id, 
                                                nickname: user.nickname 
                                            }]
                                        });
                                    }}>
                                        <View style={styles.optionContent}>
                                            <Text style={[styles.optionTitle, {color: '#FFFFFF'}]}>ğŸ—³ï¸ ìŠ¤ë§ˆíŠ¸ ì¼ì • ì¡°ìœ¨</Text>
                                            <Text style={[styles.optionSubtitle, {color: '#FFFFFF'}]}>ì•½ì†ì´ ì—†ëŠ” ì¼ì •ë§Œ ê³¨ë¼ì„œ íˆ¬í‘œ</Text>
                                        </View>
                                        <Ionicons name="chevron-forward" size={20} color="#FFFFFF" />
                                    </TouchableOpacity>
                                    
                                    <TouchableOpacity style={[styles.appointmentOptionButton, {backgroundColor: currentColors.gray}]} onPress={() => { 
                                        const dateToUse = modalData.date || toLocalDateString(getKoreanToday());
                                        setModalData({ visible: false }); 
                                        safeNavigateToTab(navigation, 'íŒŒí‹°', 'CreatePersonalSchedule', { date: dateToUse }); 
                                    }}>
                                        <View style={styles.optionContent}>
                                            <Text style={[styles.optionTitle, {color: '#FFFFFF'}]}>ğŸ“ ê¸°íƒ€ ì¼ì •</Text>
                                            <Text style={[styles.optionSubtitle, {color: '#FFFFFF'}]}>ë‚˜ë§Œì˜ ê°œì¸ ì¼ì •</Text>
                                        </View>
                                        <Ionicons name="chevron-forward" size={20} color="#FFFFFF" />
                                    </TouchableOpacity>
                                </View>
                            </>
                    </Pressable>
                </Pressable>
            </Modal>
            
            {/* í”Œë¡œíŒ… ë¹ ë¥¸ ì•¡ì…˜ ë²„íŠ¼ */}
            <TouchableOpacity
                style={{
                    position: 'absolute',
                    right: 24,
                    bottom: 32,
                    width: 56,
                    height: 56,
                    borderRadius: 28,
                    backgroundColor: currentColors.primary,
                    justifyContent: 'center',
                    alignItems: 'center',
                    zIndex: 10,
                    elevation: 8,
                    shadowColor: currentColors.primary,
                    shadowOffset: { width: 0, height: 4 },
                    shadowOpacity: 0.3,
                    shadowRadius: 8
                }}
                activeOpacity={0.85}
                onPress={() => {
                    // ğŸ¯ í™ˆíƒ­ì—ì„œ ì´ë¯¸ ê³„ì‚°ëœ ì •í™•í•œ ì˜¤ëŠ˜ ë‚ ì§œë¥¼ ì „ì—­ ë³€ìˆ˜ì—ì„œ ê°€ì ¸ì˜¤ê¸°
                    const todayString = global.homeTodayDate || toLocalDateString(getKoreanToday());
                    setModalData({ visible: true, events: [], date: todayString });
                }}
            >
                <Ionicons name="add" size={32} color="#fff" />
            </TouchableOpacity>
            
            <MissionModal 
                visible={missionModalVisible}
                onClose={() => setMissionModalVisible(false)}
                navigation={navigation}
                onMissionUpdate={() => {
                    // ë¯¸ì…˜ ìˆ˜ë ¹ í›„ ì¦‰ì‹œ í—¤ë”ì˜ ë¹¨ê°„ ì  ìƒíƒœ ê°±ì‹ 
                    // ì´ ì½œë°±ì€ MissionModalì—ì„œ ë¯¸ì…˜ ìˆ˜ë ¹ ì‹œ í˜¸ì¶œë¨
                    // TabNavigatorì˜ ìƒíƒœë¥¼ ì¦‰ì‹œ ì—…ë°ì´íŠ¸í•˜ì—¬ í™ˆíƒ­ê³¼ í—¤ë”ì˜ ë¹¨ê°„ ì  ë™ê¸°í™”
                }}
            />
            

        </SafeAreaView>
    );
}

// --- ìƒˆë¡œìš´ ëœë¤ ëŸ°ì¹˜ ì‹œìŠ¤í…œ í™”ë©´ë“¤ ---
function SelectLunchDateScreen({ navigation }) {
    const { user } = useAuth();
    const [availableDates, setAvailableDates] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        fetchAvailableDates();
    }, []);

    const fetchAvailableDates = async () => {
        try {
            setLoading(true);
            const response = await fetch(`${RENDER_SERVER_URL}/proposals/available-dates?employee_id=${global.myEmployeeId || '1'}`);
            const data = await response.json();
            if (response.ok) {
                // ì˜¤ëŠ˜ ì´í›„(ì˜¤ëŠ˜ í¬í•¨) ë‚ ì§œë§Œ ë‚¨ê¸°ê¸°
                const today = new Date();
                today.setHours(0, 0, 0, 0); // ì˜¤ëŠ˜ 00:00

                const filteredDates = data.filter(d => {
                    // dê°€ 'YYYY-MM-DD' ë¬¸ìì—´ì´ë©´, í•­ìƒ UTC ê¸°ì¤€ìœ¼ë¡œ í•´ì„
                    const dateObj = new Date(d + 'T00:00:00Z');
                    // í•œêµ­ ì‹œê°„(UTC+9)ìœ¼ë¡œ ë³€í™˜
                    const koreaDate = new Date(dateObj.getTime() + 9 * 60 * 60 * 1000);
                    koreaDate.setHours(0, 0, 0, 0);
                    
                    return koreaDate > today; // ì˜¤ëŠ˜ë³´ë‹¤ í° ë‚ ì§œ(ë‚´ì¼ë¶€í„°)ë§Œ ë‚¨ê¹€
                });
                
                setAvailableDates(filteredDates);
} else {
    Alert.alert('ì˜¤ë¥˜', data.message || 'ë‚ ì§œ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
}
        } catch (error) {
            console.error('ë‚ ì§œ ì¡°íšŒ ì˜¤ë¥˜:', error);
            Alert.alert('ì˜¤ë¥˜', 'ë„¤íŠ¸ì›Œí¬ì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        } finally {
            setLoading(false);
        }
    };

    const handleDateSelect = (date) => {
        navigation.navigate('SuggestGroupScreen', { selectedDate: date });
    };



    const renderDateButton = ({ item }) => {
        const date = new Date(item);
        const dayOfWeek = ['ì¼', 'ì›”', 'í™”', 'ìˆ˜', 'ëª©', 'ê¸ˆ', 'í† '][date.getDay()];
        const isToday = new Date().toDateString() === date.toDateString();
        
        return (
            <TouchableOpacity 
                style={[styles.dateButton, isToday && styles.todayButton]} 
                onPress={() => handleDateSelect(item)}
            >
                <Text style={[styles.dateButtonText, isToday && styles.todayButtonText]}>
                    {date.getDate()}ì¼
                </Text>
                <Text style={[styles.dateButtonSubText, isToday && styles.todayButtonText]}>
                    ({dayOfWeek})
                </Text>
                {isToday && <Text style={styles.todayLabel}>ì˜¤ëŠ˜</Text>}
            </TouchableOpacity>
        );
    };

    if (loading) {
        return (
            <SafeAreaView style={styles.safeArea}>
                <View style={styles.loadingContainer}>
                    <ActivityIndicator size="large" color={currentColors.primary} />
                    <Text style={styles.loadingText}>ë‚ ì§œ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</Text>
                </View>
            </SafeAreaView>
        );
    }

    return (
        <SafeAreaView style={styles.safeArea}>
            <ScrollView style={styles.container}>
                <FlatList
                    data={availableDates}
                    renderItem={renderDateButton}
                    keyExtractor={item => item}
                    numColumns={3}
                    contentContainerStyle={styles.dateGrid}
                    scrollEnabled={false}
                />
            </ScrollView>
        </SafeAreaView>
    );
}
function SuggestGroupScreen({ navigation, route }) {
    const { user } = useAuth();
    const { selectedDate } = route?.params || {};
    const [suggestedGroups, setSuggestedGroups] = useState([]);
    const [loading, setLoading] = useState(true);
    const [currentGroupIndex, setCurrentGroupIndex] = useState(0);
    const [proposedGroups, setProposedGroups] = useState(new Set());
    
    // ëœë¤ëŸ°ì¹˜ íƒ­ì—ì„œ ì‚¬ìš©ë  ë•Œ ê¸°ë³¸ ë‚ ì§œ ì„¤ì •
    const defaultDate = selectedDate || new Date();
    const [currentDate, setCurrentDate] = useState(defaultDate);

    useEffect(() => {
        fetchSuggestedGroups();
    }, [currentDate]);

    useEffect(() => {
        if (suggestedGroups.length > 0) {
            fetchMyProposals();
        }
    }, [suggestedGroups]);

    // í™”ë©´ì´ í¬ì»¤ìŠ¤ë  ë•Œë§ˆë‹¤ ì œì•ˆ ìƒíƒœ ìƒˆë¡œê³ ì¹¨
    useFocusEffect(
        useCallback(() => {
            fetchMyProposals();
        }, [])
    );

    const fetchMyProposals = async () => {
        try {
            const response = await fetch(`${RENDER_SERVER_URL}/proposals/mine?employee_id=${global.myEmployeeId || '1'}`);
            const data = await response.json();
            if (response.ok) {
                const sentProposals = data.sent_proposals || [];
                const pendingProposals = sentProposals.filter(p => p.status === 'pending');
                const proposedGroupKeys = new Set();
                pendingProposals.forEach(proposal => {
                    if (proposal.recipient_ids) {
                        // ì—¬ê¸° ë‘ ì¤„ì´ ì¤‘ìš”!
                        const ids = parseRecipientIds(proposal.recipient_ids);
                        const groupKey = getGroupKeyFromIds(ids);
                        proposedGroupKeys.add(groupKey);
                    }
                });
                setProposedGroups(proposedGroupKeys);
            }
        } catch (error) {
            console.error('ì œì•ˆ ìƒíƒœ ì¡°íšŒ ì˜¤ë¥˜:', error);
        }
    };

    const fetchSuggestedGroups = async () => {
        try {
            setLoading(true);
            // ê°€ìƒ ê·¸ë£¹ ë§¤ì¹­ API ì‚¬ìš© - ì—¬ëŸ¬ ê·¸ë£¹ ì§€ì›
            const response = await fetch(`${RENDER_SERVER_URL}/dev/random-lunch/${user.employee_id || '1'}`);
            const groupsData = await response.json();
            
            if (response.ok && groupsData && Array.isArray(groupsData)) {
                // APIê°€ ë°°ì—´ì„ ë°˜í™˜í•˜ë¯€ë¡œ ê° ê·¸ë£¹ì„ ë³€í™˜
                const virtualGroups = groupsData.map(data => ({
                    id: data.id,
                    date: data.date,
                    members: data.members,
                    status: data.status,
                    created_at: data.created_at,
                    score: data.score || 0,
                    // í™”ë©´ í‘œì‹œìš© ì¶”ê°€ í•„ë“œ
                    title: `ğŸ½ï¸ ${data.date} ì ì‹¬ ëª¨ì„`,
                    current_members: data.current_members || data.members.length,
                    max_members: data.max_members || 4,
                    restaurant_name: 'ì¶”ì²œ ì‹ë‹¹',
                    party_date: data.date,
                    party_time: '12:00',
                    users: data.members.map(memberId => {
                        // memberIdë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì‹¤ì œ ë‹‰ë„¤ì„ ê°€ì ¸ì˜¤ê¸°
                        const nicknames = {
                            '1': 'ê¹€ì² ìˆ˜', '2': 'ì´ì˜í¬', '3': 'ë°•ë¯¼ìˆ˜', '4': 'ìµœì§€ì€', '5': 'ì •í˜„ìš°',
                            '6': 'í•œì†Œì˜', '7': 'ìœ¤ì¤€í˜¸', '8': 'ì†¡ë¯¸ë¼', '9': 'ê°•ë™í˜„', '10': 'ì„ì„œì—°',
                            '11': 'ì˜¤íƒœí˜¸', '12': 'ì‹ ìœ ì§„', '13': 'ì¡°ì„±ë¯¼', '14': 'ë°±í•˜ì€', '15': 'ë‚¨ì¤€ì„',
                            '16': 'ë¥˜ì§€í˜„', '17': 'ì°¨ì¤€í˜¸', '18': 'êµ¬ë¯¸ì˜', '19': 'í™ì„±í›ˆ', '20': 'ì „ì†Œì—°'
                        };
                        return {
                            employee_id: memberId,
                            nickname: nicknames[memberId] || `ì‚¬ìš©ì${memberId}`,
                            profile_image: null
                        };
                    })
                }));
                
                setSuggestedGroups(virtualGroups);
                console.log('âœ… [ëœë¤ëŸ°ì¹˜]', virtualGroups.length, 'ê°œ ê·¸ë£¹ ë§¤ì¹­ ì™„ë£Œ');
            } else {
                setSuggestedGroups([]);
            }
        } catch (error) {
            console.error('ê·¸ë£¹ ì¶”ì²œ ì˜¤ë¥˜:', error);
            setSuggestedGroups([]);
        } finally {
            setLoading(false);
        }
    };

    const handleCancelSentProposal = async (proposalId) => {
        try {
            const response = await fetch(`${RENDER_SERVER_URL}/proposals/${proposalId}/cancel`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ employee_id: user.employee_id })
            });
            
            if (response.ok) {
                Alert.alert('ì•Œë¦¼', 'ì œì•ˆì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.');
                fetchMyProposals();
            } else {
                Alert.alert('ì˜¤ë¥˜', 'ì œì•ˆ ì·¨ì†Œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }
        } catch (error) {
            console.error('ì œì•ˆ ì·¨ì†Œ ì˜¤ë¥˜:', error);
            Alert.alert('ì˜¤ë¥˜', 'ë„¤íŠ¸ì›Œí¬ì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        }
    };

    const handleProposeGroup = async (group) => {
        // ê·¸ë£¹ í‚¤ ìƒì„± (ë‚ ì§œ í¬í•¨)
        const groupUserIds = group.users
            .map(user => user.employee_id)
            .filter(id => id && id.trim().length > 0)
            .sort();
        const selectedDateStr = toKoreanDateString(selectedDate);
        const groupKey = getGroupKeyFromIds(groupUserIds, selectedDateStr);
        
        // ì´ë¯¸ ì œì•ˆí•œ ê·¸ë£¹ì´ë©´ ì·¨ì†Œ
        if (group.isProposed || proposedGroups.has(groupKey)) {
            try {
                // í•´ë‹¹ ë‚ ì§œì— ë‚´ê°€ ë³´ë‚¸ ì œì•ˆ ì°¾ê¸°
                const response = await fetch(`${RENDER_SERVER_URL}/proposals/mine?employee_id=${user.employee_id}`);
                const data = await response.json();
                
                if (response.ok) {
                    const sentProposals = data.sent_proposals || [];
                    
                    // í•´ë‹¹ ê·¸ë£¹ì— í•´ë‹¹í•˜ëŠ” ì œì•ˆ ì°¾ê¸°
                    const myProposal = sentProposals.find(proposal => {
                        if (proposal.proposed_date !== selectedDate || proposal.status !== 'pending') {
                            return false;
                        }
                        
                        if (proposal.recipient_ids) {
                            const recipientIds = parseRecipientIds(proposal.recipient_ids);
                            return getGroupKeyFromIds(recipientIds) === groupKey;
                        }
                        return false;
                    });
                    
                    if (myProposal) {
                        const cancelResponse = await fetch(`${RENDER_SERVER_URL}/proposals/${myProposal.id}/cancel`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ employee_id: user.employee_id })
                        });
                        
                        if (cancelResponse.ok) {
                            setProposedGroups(prev => {
                                const newSet = new Set(prev);
                                newSet.delete(groupKey);
                                return newSet;
                            });
                            Alert.alert('ì•Œë¦¼', 'ì œì•ˆì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.');
                            fetchMyProposals();
                            fetchSmartRecommendations(false);
                        } else {
                            Alert.alert('ì˜¤ë¥˜', 'ì œì•ˆ ì·¨ì†Œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                        }
                    }
                }
            } catch (error) {
                console.error('ì œì•ˆ ì·¨ì†Œ ì˜¤ë¥˜:', error);
                Alert.alert('ì˜¤ë¥˜', 'ë„¤íŠ¸ì›Œí¬ì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
            fetchMyProposals();
            return;
        }

        try {
            const recipientIds = group.users
                .map(user => user.employee_id)
                .filter(id => id && id.trim().length > 0);
            const response = await fetch(`${RENDER_SERVER_URL}/proposals`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    proposer_id: user.employee_id,
                    recipient_ids: recipientIds,
                    proposed_date: toKoreanDateString(selectedDate)
                })
            });
            const data = await response.json();
            if (response.ok) {
                // ì¦‰ì‹œ UI ì—…ë°ì´íŠ¸
                setProposedGroups(prev => new Set([...prev, groupKey]));
                Alert.alert('ì„±ê³µ', 'ì œì•ˆì´ ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤.');
                fetchMyProposals();
            } else {
                Alert.alert('ì˜¤ë¥˜', data.message || 'ì œì•ˆì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }
        } catch (error) {
            console.error('ì œì•ˆ ì˜¤ë¥˜:', error);
            Alert.alert('ì˜¤ë¥˜', 'ë„¤íŠ¸ì›Œí¬ì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        }
        fetchMyProposals();
    };

    const renderUserCard = ({ item }) => {
        console.log('DEBUG: renderUserCard item:', item);
        return (
        <View style={{
            backgroundColor: currentColors.surface,
            borderRadius: 16,
            padding: 16,
            marginBottom: 12,
            elevation: 2,
            shadowColor: currentColors.primary,
            shadowOffset: { width: 0, height: 2 },
            shadowOpacity: 0.1,
            shadowRadius: 4,
            borderWidth: 1,
            borderColor: 'rgba(59, 130, 246, 0.1)'
        }}>
                            <View style={{flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 8}}>
                <View style={{flexDirection: 'row', alignItems: 'center', flex: 1}}>
                    {/* ì•„ë°”íƒ€ ì´ë¯¸ì§€ ê³µê°„ */}
                    <View style={{
                        width: 40,
                        height: 40,
                        borderRadius: 20,
                        backgroundColor: '#3B82F6',
                        marginRight: 12,
                        justifyContent: 'center',
                        alignItems: 'center',
                        borderWidth: 1,
                        borderColor: '#2563EB'
                    }}>
                        <Text style={{
                            fontSize: 18,
                            color: '#FFFFFF',
                            fontWeight: 'bold'
                        }}>
                            {item.nickname ? item.nickname.charAt(0) : '?'}
                        </Text>
                    </View>
                    <Text style={{fontSize: 16, fontWeight: 'bold', color: currentColors.text, flex: 1}}>{item.nickname}</Text>
                </View>
                <View style={{
                    backgroundColor: currentColors.yellow,
                    borderRadius: 12,
                    paddingVertical: 4,
                    paddingHorizontal: 8
                }}>
                    <Text style={{color: currentColors.deepBlue, fontSize: 'bold', fontSize: 12}}>ì¶”ì²œ</Text>
                </View>
            </View>
            {item.lunch_preference && (
                <Text style={{fontSize: 14, color: currentColors.textSecondary, marginBottom: 4}}>ğŸ½ï¸ {item.lunch_preference}</Text>
            )}
            {item.main_dish_genre && (
                <Text style={{fontSize: 14, color: currentColors.textSecondary}}>ğŸœ {item.main_dish_genre}</Text>
            )}
        </View>
        );
    };

    const renderGroupCard = ({ item, index }) => {
        // ê·¸ë£¹ í‚¤ ìƒì„± (ë‚ ì§œ í¬í•¨)
        const groupUserIds = item.users
            .map(user => user.employee_id)
            .filter(id => id && id.trim().length > 0)
            .sort();
        const selectedDateStr = toKoreanDateString(selectedDate);
        const groupKey = getGroupKeyFromIds(groupUserIds, selectedDateStr);
        
        return (
            <View style={{
                backgroundColor: currentColors.surface,
                borderRadius: 20,
                padding: 20,
                marginHorizontal: 16,
                marginBottom: 16,
                elevation: 3,
                shadowColor: currentColors.primary,
                shadowOffset: { width: 0, height: 4 },
                shadowOpacity: 0.1,
                shadowRadius: 8,
                borderWidth: 1,
                borderColor: 'rgba(59, 130, 246, 0.1)'
            }}>
                <View style={{marginBottom: 16}}>
                    <View style={{flexDirection: 'row', alignItems: 'center', marginBottom: 8}}>
                        {/* ê·¸ë£¹ ì•„ë°”íƒ€ */}
                        <View style={{
                            width: 50,
                            height: 50,
                            borderRadius: 25,
                            backgroundColor: '#FF0000',
                            marginRight: 15,
                            justifyContent: 'center',
                            alignItems: 'center'
                        }}>
                            <Text style={{
                                fontSize: 20,
                                color: '#FFFFFF',
                                fontWeight: 'bold'
                            }}>
                                {index + 1}
                            </Text>
                        </View>
                        <Text style={{fontSize: 20, fontWeight: 'bold', color: currentColors.primary}}>
                            ì¶”ì²œ ê·¸ë£¹ {index + 1}
                        </Text>
                    </View>
                    <Text style={{fontSize: 14, color: currentColors.textSecondary}}>
                        ì„±í–¥ì´ ë§ëŠ” ë™ë£Œë“¤ê³¼ í•¨ê»˜ ì ì‹¬ì„ ë¨¹ì–´ë³´ì„¸ìš”!
                    </Text>
                </View>
                
                <FlatList
                    data={item.recommended_group}
                    renderItem={renderUserCard}
                    keyExtractor={(user, index) => `user-${user.employee_id}-${index}`}
                    scrollEnabled={false}
                />
                
                <TouchableOpacity 
                    style={{
                        backgroundColor: item.isProposed ? currentColors.gray : currentColors.primary,
                        borderRadius: 16,
                        padding: 16,
                        marginTop: 16,
                        elevation: 3,
                        shadowColor: currentColors.primary,
                        shadowOffset: { width: 0, height: 2 },
                        shadowOpacity: 0.2,
                        shadowRadius: 4
                    }}
                    onPress={() => handleProposeGroup(item)}
                >
                    <Text style={{
                        color: '#FFFFFF',
                        fontWeight: 'bold',
                        textAlign: 'center',
                        fontSize: 16
                    }}>
                        {item.isProposed ? 'ì œì•ˆ ì·¨ì†Œ' : 'ì´ ê·¸ë£¹ì— ì œì•ˆí•˜ê¸°'}
                    </Text>
                </TouchableOpacity>
            </View>
        );
    };

    if (loading) {
        return (
            <SafeAreaView style={styles.safeArea}>
                <View style={{
                    flex: 1,
                    justifyContent: 'center',
                    alignItems: 'center',
                    padding: 20,
                    backgroundColor: currentColors.background
                }}>
                    <ActivityIndicator size="large" color={currentColors.primary} />
                    <Text style={{
                        fontSize: 16,
                        color: currentColors.textSecondary,
                        marginTop: 16
                    }}>ì¶”ì²œ ê·¸ë£¹ì„ ì°¾ëŠ” ì¤‘...</Text>
                </View>
            </SafeAreaView>
        );
    }

    return (
        <SafeAreaView style={styles.safeArea}>
            <ScrollView style={styles.container}>
                <View style={{
                    backgroundColor: currentColors.surface,
                    borderRadius: 20,
                    padding: 20,
                    marginHorizontal: 16,
                    marginBottom: 16,
                    elevation: 3,
                    shadowColor: currentColors.primary,
                    shadowOffset: { width: 0, height: 4 },
                    shadowOpacity: 0.1,
                    shadowRadius: 8,
                    borderWidth: 1,
                    borderColor: 'rgba(59, 130, 246, 0.1)'
                }}>
                    <Text style={{
                        fontSize: 18,
                        fontWeight: 'bold',
                        marginBottom: 12,
                        color: currentColors.primary
                    }}>
                        {new Date(currentDate).getMonth() + 1}ì›” ë‚ ì§œ ì„ íƒ
                    </Text>
                    <Text style={{
                        fontSize: 16,
                        color: currentColors.textSecondary,
                        lineHeight: 24,
                        marginBottom: 16
                    }}>
                        ì„±í–¥ì´ ë§ëŠ” ë™ë£Œë“¤ê³¼ í•¨ê»˜ ì ì‹¬ì„ ë¨¹ì–´ë³´ì„¸ìš”!
                        {suggestedGroups.length > 1 && ' ì¢Œìš°ë¡œ ìŠ¤ì™€ì´í”„í•˜ì—¬ ë‹¤ë¥¸ ê·¸ë£¹ë„ í™•ì¸í•´ë³´ì„¸ìš”.'}
                    </Text>
                    
                    {/* ë‚ ì§œ ì„ íƒ ë²„íŠ¼ */}
                    <TouchableOpacity
                        style={{
                            backgroundColor: currentColors.primary,
                            borderRadius: 12,
                            padding: 12,
                            alignItems: 'center'
                        }}
                        onPress={() => {
                            // ë‚ ì§œ ì„ íƒ ëª¨ë‹¬ ì—´ê¸°
                            const newDate = new Date(currentDate);
                            newDate.setDate(newDate.getDate() + 1);
                            setCurrentDate(newDate);
                        }}
                    >
                        <Text style={{
                            color: '#FFFFFF',
                            fontWeight: 'bold',
                            fontSize: 16
                        }}>
                            ë‹¤ìŒ ë‚ ì§œë¡œ ë³€ê²½
                        </Text>
                    </TouchableOpacity>
                </View>
                
                {suggestedGroups.length > 0 ? (
                    <>
                        <FlatList
                            data={suggestedGroups}
                            renderItem={renderGroupCard}
                            keyExtractor={item => `group-${item.group_id}`}
                            horizontal
                            pagingEnabled
                            showsHorizontalScrollIndicator={false}
                            onMomentumScrollEnd={(event) => {
                                const index = Math.round(event.nativeEvent.contentOffset.x / (SCREEN_WIDTH - 32));
                                setCurrentGroupIndex(index);
                            }}
                            contentContainerStyle={{ paddingHorizontal: 0 }}
                        />
                        
                        {suggestedGroups.length > 1 && (
                            <View style={{
                                flexDirection: 'row',
                                justifyContent: 'center',
                                alignItems: 'center',
                                marginTop: 20,
                                marginBottom: 20
                            }}>
                                {suggestedGroups.map((_, index) => (
                                    <View
                                        key={index}
                                        style={{
                                            width: 8,
                                            height: 8,
                                            borderRadius: 4,
                                            backgroundColor: index === currentGroupIndex ? currentColors.primary : currentColors.lightGray,
                                            marginHorizontal: 4
                                        }}
                                    />
                                ))}
                            </View>
                        )}
                    </>
                ) : (
                    <View style={{
                        flex: 1,
                        justifyContent: 'center',
                        alignItems: 'center',
                        padding: 20,
                        backgroundColor: currentColors.background
                    }}>
                        <Text style={{
                            fontSize: 16,
                            color: currentColors.textSecondary,
                            textAlign: 'center',
                            marginTop: 50
                        }}>
                            í•´ë‹¹ ë‚ ì§œì— ì¶”ì²œí•  ìˆ˜ ìˆëŠ” ë™ë£Œê°€ ì—†ìŠµë‹ˆë‹¤.
                        </Text>
                    </View>
                )}
            </ScrollView>
        </SafeAreaView>
    );
}
function MyProposalsScreen({ navigation }) {
    const { user } = useAuth();
    const [proposals, setProposals] = useState({ sent_proposals: [], received_proposals: [] });
    const [loading, setLoading] = useState(true);
    const [expandedProposals, setExpandedProposals] = useState(new Set());
    const [groupMembersMap, setGroupMembersMap] = useState({});
    const [confirmedGroups, setConfirmedGroups] = useState([]);

    useEffect(() => {
        fetchMyProposals();
        fetchConfirmedGroups();
    }, []);

    // í™”ë©´ì´ í¬ì»¤ìŠ¤ë  ë•Œë§ˆë‹¤ ì œì•ˆ ëª©ë¡ ìƒˆë¡œê³ ì¹¨
    useFocusEffect(
        useCallback(() => {
            fetchMyProposals();
            fetchConfirmedGroups();
        }, [])
    );

    const fetchConfirmedGroups = async () => {
        try {
            const response = await fetch(`${RENDER_SERVER_URL}/parties?employee_id=${global.myEmployeeId || '1'}&is_from_match=true`);
            const data = await response.json();
            if (response.ok && Array.isArray(data)) {
                // API ì‘ë‹µ ë°ì´í„°ë¥¼ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬ (members_employee_ids í•„ë“œ ì œê±°)
                const safeData = data.map(party => {
                    // members_employee_ids í•„ë“œë¥¼ ì œê±°í•˜ê³  í•„ìš”í•œ í•„ë“œë§Œ ì¶”ì¶œ
                    const { members_employee_ids, ...safeParty } = party;
                    
                    return {
                        ...safeParty,
                        // ê¸°ë³¸ê°’ ì„¤ì •
                        current_members: party.current_members || party.members_count || 1,
                        restaurant_name: party.restaurant_name || party.restaurant || 'ì‹ë‹¹ëª… ì—†ìŒ',
                        party_date: party.party_date || party.date || 'ë‚ ì§œ ì—†ìŒ'
                    };
                });
                setConfirmedGroups(safeData);
            }
        } catch (error) {
            console.error('ì„±ì‚¬ëœ ê·¸ë£¹ ì¡°íšŒ ì˜¤ë¥˜:', error);
            // ì˜¤ë¥˜ ë°œìƒ ì‹œ ë¹ˆ ë°°ì—´ë¡œ ì„¤ì •
            setConfirmedGroups([]);
        }
    };

    const handleRejectProposal = async (proposalId) => {
        try {
            const response = await fetch(`${RENDER_SERVER_URL}/proposals/${proposalId}/reject`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ user_id: user.employee_id })
            });
            const data = await response.json();
            if (response.ok) {
                Alert.alert('ì•Œë¦¼', data.message || 'ì œì•ˆì„ ê±°ì ˆí–ˆìŠµë‹ˆë‹¤.');
                fetchMyProposals(); // ëª©ë¡ ìƒˆë¡œê³ ì¹¨
            } else {
                Alert.alert('ì˜¤ë¥˜', data.message || 'ê±°ì ˆì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }
        } catch (error) {
            console.error('ì œì•ˆ ê±°ì ˆ ì˜¤ë¥˜:', error);
            Alert.alert('ì˜¤ë¥˜', 'ë„¤íŠ¸ì›Œí¬ì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        }
    };

    const fetchMyProposals = async () => {
        try {
            setLoading(true);
            const response = await fetch(`${RENDER_SERVER_URL}/proposals/mine?employee_id=${user.employee_id}`);
            const data = await response.json();
            if (response.ok) {
                // ì·¨ì†Œëœ ì œì•ˆë§Œ ì œê±°
                const filterProposals = (proposals) => proposals.filter(p => p.status !== 'cancelled');
                const filteredData = {
                    sent_proposals: filterProposals(data.sent_proposals || []),
                    received_proposals: filterProposals(data.received_proposals || [])
                };
                setProposals(filteredData);
                // ë³´ë‚¸ ì œì•ˆë“¤ì˜ ê·¸ë£¹ ë©¤ë²„ ì •ë³´ë¥¼ ë°”ë¡œ ê°€ì ¸ì˜¤ê¸°
                const sentProposals = filteredData.sent_proposals || [];
                for (const proposal of sentProposals) {
                    if (proposal.recipient_ids) {
                        fetchGroupMembers(proposal.id, proposal.recipient_ids);
                    }
                }
            } else {
                Alert.alert('ì˜¤ë¥˜', data.message || 'ì œì•ˆ ëª©ë¡ì„ ê°€ì ¸ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }
        } catch (error) {
            console.error('ì œì•ˆ ëª©ë¡ ì¡°íšŒ ì˜¤ë¥˜:', error);
            Alert.alert('ì˜¤ë¥˜', 'ë„¤íŠ¸ì›Œí¬ì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        } finally {
            setLoading(false);
        }
    };

    const handleAcceptProposal = async (proposalId) => {
        try {
            const response = await fetch(`${RENDER_SERVER_URL}/proposals/${proposalId}/accept`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ user_id: user.employee_id })
            });
            const data = await response.json();
            
            if (response.ok) {
                if (data.status === 'confirmed') {
                    Alert.alert('ì„±ê³µ!', 'ë§¤ì¹­ì´ ì„±ì‚¬ë˜ì—ˆìŠµë‹ˆë‹¤!');
                } else {
                    Alert.alert('ì•Œë¦¼', data.message);
                }
                fetchMyProposals();
            } else {
                Alert.alert('ì˜¤ë¥˜', data.message || 'ìˆ˜ë½ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }
        } catch (error) {
            console.error('ì œì•ˆ ìˆ˜ë½ ì˜¤ë¥˜:', error);
            Alert.alert('ì˜¤ë¥˜', 'ë„¤íŠ¸ì›Œí¬ì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        }
    };

    const handleCancelProposal = async (proposalId) => {
        try {
            const response = await fetch(`${RENDER_SERVER_URL}/proposals/${proposalId}/cancel`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ user_id: user.employee_id })
            });
            const data = await response.json();
            
            if (response.ok) {
                Alert.alert('ì•Œë¦¼', data.message);
                // ëª©ë¡ì—ì„œ ì¦‰ì‹œ ì œê±°
                setProposals(prev => ({
                    sent_proposals: prev.sent_proposals.filter(p => p.id !== proposalId),
                    received_proposals: prev.received_proposals
                }));
            } else {
                Alert.alert('ì˜¤ë¥˜', data.message || 'ì·¨ì†Œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }
        } catch (error) {
            console.error('ì œì•ˆ ì·¨ì†Œ ì˜¤ë¥˜:', error);
            Alert.alert('ì˜¤ë¥˜', 'ë„¤íŠ¸ì›Œí¬ì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        }
    };

    const toggleProposalExpansion = (proposalId) => {
        setExpandedProposals(prev => {
            const newSet = new Set(prev);
            if (newSet.has(proposalId)) {
                newSet.delete(proposalId);
            } else {
                newSet.add(proposalId);
            }
            return newSet;
        });
    };

    const fetchGroupMembers = async (proposalId, recipientIds) => {
        try {
            const userIds = parseRecipientIds(recipientIds);
            
            console.log('ê·¸ë£¹ ë©¤ë²„ ì¡°íšŒ:', { proposalId, recipientIds, userIds });
            
            if (userIds.length === 0) {
                console.log('ìœ íš¨í•œ ì‚¬ìš©ì IDê°€ ì—†ìŒ');
                setGroupMembersMap(prev => ({
                    ...prev,
                    [proposalId]: []
                }));
                return;
            }
            
            const response = await fetch(`${RENDER_SERVER_URL}/users/batch`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ user_ids: userIds })
            });
            
            console.log('API ì‘ë‹µ ìƒíƒœ:', response.status);
            const data = await response.json();
            console.log('API ì‘ë‹µ ë°ì´í„°:', data);
            
            if (response.ok && Array.isArray(data)) {
                setGroupMembersMap(prev => ({
                    ...prev,
                    [proposalId]: data
                }));
                console.log('ê·¸ë£¹ ë©¤ë²„ ì •ë³´ ì €ì¥ ì™„ë£Œ:', data);
            } else {
                console.error('API ì‘ë‹µ ì˜¤ë¥˜:', data);
                // ì—ëŸ¬ ì‹œì—ë„ ë¹ˆ ë°°ì—´ë¡œ ì„¤ì •í•˜ì—¬ ë¡œë”© ìƒíƒœ í•´ì œ
                setGroupMembersMap(prev => ({
                    ...prev,
                    [proposalId]: []
                }));
            }
        } catch (error) {
            console.error('ê·¸ë£¹ ë©¤ë²„ ì •ë³´ ì¡°íšŒ ì˜¤ë¥˜:', error);
            // ì—ëŸ¬ ì‹œì—ë„ ë¹ˆ ë°°ì—´ë¡œ ì„¤ì •í•˜ì—¬ ë¡œë”© ìƒíƒœ í•´ì œ
            setGroupMembersMap(prev => ({
                ...prev,
                [proposalId]: []
            }));
        }
    };

    const renderConfirmedGroupItem = ({ item }) => (
        <TouchableOpacity 
            style={{
                backgroundColor: currentColors.surface,
                borderRadius: 20,
                padding: 20,
                marginHorizontal: 6,
                width: SCREEN_WIDTH * 0.5,
                height: 160,
                borderWidth: 1,
                borderColor: 'rgba(59, 130, 246, 0.1)',
                justifyContent: 'flex-start',
                elevation: 3,
                shadowColor: currentColors.primary,
                shadowOffset: { width: 0, height: 4 },
                shadowOpacity: 0.1,
                shadowRadius: 8
            }}
            onPress={() => navigation.navigate('PartyDetail', { partyId: item.id })}
        >
            <View style={{marginBottom: 6}}>
                <Text style={{fontSize: 16, fontWeight: 'bold', color: currentColors.text}}>âš¡ï¸ {item.party_date}</Text>
            </View>
            <Text style={{fontSize: 13, color: currentColors.textSecondary, marginBottom: 6}}>
                ğŸ‘¥ {item.current_members}ëª… ì°¸ì—¬
            </Text>
            <Text style={{fontSize: 13, color: currentColors.textSecondary}}>
                ğŸ½ï¸ {item.restaurant_name}
            </Text>
        </TouchableOpacity>
    );

    const renderProposalItem = ({ item, type }) => {
        const isPending = item.status === 'pending';
        const isReceived = type === 'received';
        const isExpanded = expandedProposals.has(item.id);
        const groupMembers = groupMembersMap[item.id] || [];
        
        // ê·¸ë£¹ ë©¤ë²„ ì •ë³´ ê°€ì ¸ì˜¤ê¸° (hooks ì—†ì´ ì²˜ë¦¬)
        if (isExpanded && type === 'sent' && item.recipient_ids && !groupMembersMap[item.id]) {
            console.log('ê·¸ë£¹ ë©¤ë²„ ì •ë³´ ìš”ì²­:', { proposalId: item.id, recipientIds: item.recipient_ids });
            fetchGroupMembers(item.id, item.recipient_ids);
        }
        
        return (
            <View style={{
                backgroundColor: currentColors.surface,
                borderRadius: 20,
                marginHorizontal: 16,
                marginBottom: 16,
                padding: 20,
                elevation: 3,
                shadowColor: currentColors.primary,
                shadowOffset: { width: 0, height: 4 },
                shadowOpacity: 0.1,
                shadowRadius: 8,
                borderWidth: 1,
                borderColor: 'rgba(59, 130, 246, 0.1)'
            }}>
                <TouchableOpacity 
                    style={{flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center'}}
                    onPress={() => toggleProposalExpansion(item.id)}
                >
                    <Text style={{fontSize: 16, fontWeight: 'bold', color: currentColors.text}}>
                        {new Date(item.proposed_date).toLocaleDateString('ko-KR', { 
                            month: 'long', 
                            day: 'numeric' 
                        })}
                    </Text>
                    <View style={{flexDirection: 'row', alignItems: 'center'}}>
                        <View style={{
                            backgroundColor: item.status === 'confirmed' ? currentColors.success : 
                                          item.status === 'cancelled' ? currentColors.error : 
                                          item.status === 'expired' ? currentColors.warning : currentColors.primaryLight,
                            borderRadius: 20,
                            paddingVertical: 6,
                            paddingHorizontal: 12,
                            marginRight: 8
                        }}>
                            <Text style={{color: item.status === 'confirmed' ? '#FFFFFF' : 
                                         item.status === 'cancelled' ? '#FFFFFF' : 
                                         item.status === 'expired' ? '#FFFFFF' : currentColors.primary, 
                                         fontWeight: 'bold', fontSize: 12}}>
                                {item.status === 'pending' ? 'ëŒ€ê¸°ì¤‘' : 
                                 item.status === 'confirmed' ? 'í™•ì •' : 
                                 item.status === 'cancelled' ? 'ì·¨ì†Œ' : 'ë§Œë£Œ'}
                            </Text>
                        </View>
                        <Ionicons 
                            name={isExpanded ? "chevron-up" : "chevron-down"} 
                            size={20} 
                            color={currentColors.textSecondary} 
                        />
                    </View>
                </TouchableOpacity>
                
                {isExpanded && (
                    <View style={{marginTop: 12, paddingTop: 12, borderTopWidth: 1, borderTopColor: currentColors.lightGray}}>
                        {type === 'sent' && (
                            <View style={{marginBottom: 8}}>
                                <Text style={{fontSize: 14, fontWeight: 'bold', color: currentColors.text, marginBottom: 8}}>ì œì•ˆí•œ ê·¸ë£¹:</Text>
                                {(groupMembers && groupMembers.length > 0) ? (
                                    groupMembers.map((member, index) => (
                                        <View key={index} style={{marginBottom: 8}}>
                                            <Text style={{fontSize: 14, color: currentColors.text, fontWeight: '600'}}>{member.nickname || member.employee_id}</Text>
                                            <Text style={{fontSize: 12, color: currentColors.textSecondary, marginLeft: 16}}>
                                                ğŸ½ï¸ {member.lunch_preference || '-'}
                                                {member.dining_history && `  |  ${member.dining_history}`}
                                            </Text>
                                            {member.main_dish_genre && (
                                                <Text style={{fontSize: 12, color: currentColors.textSecondary, marginLeft: 16}}>ğŸœ {member.main_dish_genre}</Text>
                                            )}
                                        </View>
                                    ))
                                ) : (
                                    <View style={{marginBottom: 8}}>
                                        <Text style={{fontSize: 12, color: currentColors.textSecondary}}>
                                            {item.recipient_ids ? 'ì°¸ì—¬ì ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...' : 'ì°¸ì—¬ì ì •ë³´ ì—†ìŒ'}
                                        </Text>
                                        {item.recipient_ids && (
                                            <Text style={{fontSize: 10, color: currentColors.textSecondary, marginTop: 4}}>
                                                ID: {item.recipient_ids}
                                            </Text>
                                        )}
                                    </View>
                                )}
                            </View>
                        )}
                        
                        {item.accepted_nicknames && item.accepted_nicknames.length > 0 && (
                            <Text style={{fontSize: 14, color: currentColors.success, fontWeight: '600', marginBottom: 8}}>
                                ìˆ˜ë½í•œ ì‚¬ëŒ: {item.accepted_nicknames.join(', ')}
                            </Text>
                        )}
                
                        {isReceived && isPending && (
                            <View style={{flexDirection: 'row', justifyContent: 'space-between', marginTop: 8}}>
                                <TouchableOpacity 
                                    style={{
                                        backgroundColor: currentColors.primary,
                                        borderRadius: 16,
                                        paddingVertical: 12,
                                        paddingHorizontal: 20,
                                        flex: 1,
                                        marginRight: 8,
                                        alignItems: 'center',
                                        elevation: 3,
                                        shadowColor: currentColors.primary,
                                        shadowOffset: { width: 0, height: 4 },
                                        shadowOpacity: 0.3,
                                        shadowRadius: 8
                                    }}
                                    onPress={() => handleAcceptProposal(item.id)}
                                >
                                    <Text style={{color: '#FFFFFF', fontWeight: 'bold', fontSize: 14}}>
                                        ìˆ˜ë½
                                    </Text>
                                </TouchableOpacity>
                                <TouchableOpacity 
                                    style={{
                                        backgroundColor: currentColors.error,
                                        borderRadius: 16,
                                        paddingVertical: 12,
                                        paddingHorizontal: 20,
                                        flex: 1,
                                        marginLeft: 8,
                                        alignItems: 'center',
                                        elevation: 3,
                                        shadowColor: currentColors.error,
                                        shadowOffset: { width: 0, height: 4 },
                                        shadowOpacity: 0.3,
                                        shadowRadius: 8
                                    }}
                                       onPress={() => {
        Alert.alert('ê±°ì ˆ', 'ì´ ì œì•ˆì„ ê±°ì ˆí•˜ì‹œê² ìŠµë‹ˆê¹Œ?', [
            { text: 'ì·¨ì†Œ', style: 'cancel' },
            { text: 'í™•ì¸', style: 'destructive', onPress: () => handleRejectProposal(item.id) }
        ]);
    }}
>
    <Text style={{color: '#FFFFFF', fontWeight: 'bold', fontSize: 14}}>
        ê±°ì ˆ
    </Text>
</TouchableOpacity>
                             </View>
                        )}
                        
                        {type === 'sent' && isPending && (
                            <View style={{marginTop: 8}}>
                                <TouchableOpacity 
                                    style={{
                                        backgroundColor: '#EF4444',
                                        borderRadius: 16,
                                        paddingVertical: 12,
                                        paddingHorizontal: 24,
                                        alignItems: 'center',
                                        width: '100%',
                                        elevation: 3,
                                        shadowColor: '#EF4444',
                                        shadowOffset: { width: 0, height: 4 },
                                        shadowOpacity: 0.3,
                                        shadowRadius: 8
                                    }}
                                    onPress={async () => {
                                        Alert.alert('ì œì•ˆ ì·¨ì†Œ', 'ì´ ì œì•ˆì„ ì·¨ì†Œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?', [
                                            { text: 'ì·¨ì†Œ', style: 'cancel' },
                                            { 
                                                text: 'í™•ì¸', 
                                                style: 'destructive', 
                                                onPress: async () => {
                                                    try {
                                                        console.log('DEBUG: ì œì•ˆ ì·¨ì†Œ ì‹œë„ - proposalId:', item.id);
                                                        const response = await fetch(`${RENDER_SERVER_URL}/proposals/${item.id}/cancel`, {
                                                            method: 'POST',
                                                            headers: { 'Content-Type': 'application/json' },
                                                            body: JSON.stringify({ employee_id: user.employee_id })
                                                        });
                                                        
                                                        console.log('DEBUG: ì œì•ˆ ì·¨ì†Œ ì‘ë‹µ - status:', response.status);
                                                        const responseData = await response.text();
                                                        console.log('DEBUG: ì œì•ˆ ì·¨ì†Œ ì‘ë‹µ - data:', responseData);
                                                        
                                                        if (response.ok) {
                                                            Alert.alert('ì•Œë¦¼', 'ì œì•ˆì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.');
                                                            fetchMyProposals();
                                                        } else {
                                                            Alert.alert('ì˜¤ë¥˜', `ì œì•ˆ ì·¨ì†Œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. (${response.status})`);
                                                        }
                                                    } catch (error) {
                                                        console.error('ì œì•ˆ ì·¨ì†Œ ì˜¤ë¥˜:', error);
                                                        Alert.alert('ì˜¤ë¥˜', 'ë„¤íŠ¸ì›Œí¬ì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                                                    }
                                                }
                                            }
                                        ]);
                                    }}
                                >
                                    <Text style={{color: '#FFFFFF', fontWeight: 'bold', fontSize: 14}}>
                                        ì œì•ˆ ì·¨ì†Œ
                                    </Text>
                                </TouchableOpacity>
                            </View>
                        )}
                    </View>
                )}
            </View>
        );
    };

    if (loading) {
        return (
            <SafeAreaView style={styles.safeArea}>
                <View style={{flex: 1, justifyContent: 'center', alignItems: 'center'}}>
                    <ActivityIndicator size="large" color={currentColors.primary} />
                    <Text style={{fontSize: 16, color: currentColors.textSecondary, marginTop: 16}}>ì œì•ˆ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘...</Text>
                </View>
            </SafeAreaView>
        );
    }

    return (
        <SafeAreaView style={styles.safeArea}>
            <ScrollView style={{flex: 1, backgroundColor: currentColors.background}}>

                {/* ë§¤ì¹­ ì„±ê³µí•œ ì ì‹¬ ëª¨ì„ */}
                {confirmedGroups.length > 0 && (
                    <View style={{marginBottom: 24}}>
                        <Text style={{fontSize: 20, fontWeight: 'bold', marginBottom: 12, color: currentColors.primary, paddingHorizontal: 16, marginTop: 16}}>
                            ë§¤ì¹­ ì„±ê³µ
                        </Text>
                        <FlatList
                            data={confirmedGroups}
                            renderItem={renderConfirmedGroupItem}
                            keyExtractor={item => `confirmed-${item.id}`}
                            horizontal
                            showsHorizontalScrollIndicator={false}
                            contentContainerStyle={{ paddingHorizontal: 16, paddingVertical: 5 }}
                        />
                    </View>
                )}
                
                <View style={{marginBottom: 24}}>
                    <Text style={{fontSize: 20, fontWeight: 'bold', marginBottom: 12, color: currentColors.primary, paddingHorizontal: 16, marginTop: 16}}>
                        ë³´ë‚¸ ì œì•ˆ
                    </Text>
                    {proposals.sent_proposals.length > 0 ? (
                        proposals.sent_proposals.map(item => (
                            <View key={item.id}>
                                {renderProposalItem({ item, type: 'sent' })}
                            </View>
                        ))
                    ) : (
                        <Text style={{fontSize: 16, color: currentColors.textSecondary, textAlign: 'center', marginTop: 50, paddingHorizontal: 16}}>ë³´ë‚¸ ì œì•ˆì´ ì—†ìŠµë‹ˆë‹¤.</Text>
                    )}
                </View>
                
                <View style={{marginBottom: 24}}>
                    <Text style={{fontSize: 20, fontWeight: 'bold', marginBottom: 12, color: currentColors.primary, paddingHorizontal: 16, marginTop: 16}}>
                        ë°›ì€ ì œì•ˆ
                    </Text>
                    {proposals.received_proposals.length > 0 ? (
                        proposals.received_proposals.map(item => (
                            <View key={item.id}>
                                {renderProposalItem({ item, type: 'received' })}
                            </View>
                        ))
                    ) : (
                        <Text style={{fontSize: 16, color: currentColors.textSecondary, textAlign: 'center', marginTop: 50, paddingHorizontal: 16}}>ë°›ì€ ì œì•ˆì´ ì—†ìŠµë‹ˆë‹¤.</Text>
                    )}
                </View>
            </ScrollView>
        </SafeAreaView>
    );
}
// ì‹ë‹¹ ì•„ì´í…œ ì»´í¬ë„ŒíŠ¸
function RestaurantItem({ restaurant, navigation, activeTab, currentColors, onAddVisit }) {
    const [restaurantData, setRestaurantData] = useState({
        reviews: [],
        averageRating: 0,
        reviewCount: 0,
        mostSelectedFoodTypes: [],
        topKeywords: [],
        latestImage: null
    });
    const [distance, setDistance] = useState(null);
    const [isFavorite, setIsFavorite] = useState(false);
    const [favoriteId, setFavoriteId] = useState(null);

    // ê±°ë¦¬ ê³„ì‚° í•¨ìˆ˜
    const calculateDistance = (lat1, lon1, lat2, lon2) => {
        const R = 6371; // ì§€êµ¬ì˜ ë°˜ì§€ë¦„ (km)
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                  Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const distance = R * c;
        return distance;
    };

    // ì¦ê²¨ì°¾ê¸° ìƒíƒœ í™•ì¸
    const checkFavoriteStatus = async () => {
        try {
            const currentUser = await AsyncStorage.getItem('currentUser');
            if (currentUser) {
                const user = JSON.parse(currentUser);
                const response = await fetch(`${RENDER_SERVER_URL}/restaurants/favorites/check`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_id: user.employee_id,
                        restaurant_id: restaurant.id
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    setIsFavorite(result.is_favorite);
                    setFavoriteId(result.favorite_id);
                }
            }
        } catch (error) {
            console.error('ì¦ê²¨ì°¾ê¸° ìƒíƒœ í™•ì¸ ì˜¤ë¥˜:', error);
        }
    };

    // ì¦ê²¨ì°¾ê¸° í† ê¸€
    const toggleFavorite = async () => {
        try {
            const currentUser = await AsyncStorage.getItem('currentUser');
            if (!currentUser) {
                Alert.alert('ë¡œê·¸ì¸ í•„ìš”', 'ì¦ê²¨ì°¾ê¸°ë¥¼ ì‚¬ìš©í•˜ë ¤ë©´ ë¡œê·¸ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.');
                return;
            }

            const user = JSON.parse(currentUser);
            
            if (isFavorite) {
                // ì¦ê²¨ì°¾ê¸° ì œê±°
                if (favoriteId) {
                    const response = await fetch(`${RENDER_SERVER_URL}/restaurants/favorites/${favoriteId}`, {
                        method: 'DELETE'
                    });
                    
                    if (response.ok) {
                        setIsFavorite(false);
                        setFavoriteId(null);
                        console.log('ì¦ê²¨ì°¾ê¸° ì œê±°ë¨');
                    }
                }
            } else {
                // ì¦ê²¨ì°¾ê¸° ì¶”ê°€
                const response = await fetch(`${RENDER_SERVER_URL}/restaurants/favorites`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_id: user.employee_id,
                        restaurant_id: restaurant.id
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    setIsFavorite(true);
                    setFavoriteId(result.favorite.id);
                    console.log('ì¦ê²¨ì°¾ê¸° ì¶”ê°€ë¨');
                }
            }
        } catch (error) {
            console.error('ì¦ê²¨ì°¾ê¸° í† ê¸€ ì˜¤ë¥˜:', error);
            Alert.alert('ì˜¤ë¥˜', 'ì¦ê²¨ì°¾ê¸° ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        }
    };

    useEffect(() => {
        const fetchRestaurantData = async () => {
            try {
                console.log('ì‹ë‹¹ ID:', restaurant.id);
                // ë¦¬ë·° ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
                const storedReviews = await AsyncStorage.getItem(`reviews_${restaurant.id}`);
                console.log('ì €ì¥ëœ ë¦¬ë·°:', storedReviews);
                
                if (storedReviews) {
                    const parsedReviews = JSON.parse(storedReviews);
                    console.log('íŒŒì‹±ëœ ë¦¬ë·°:', parsedReviews);
                    
                    // í‰ê·  í‰ì  ê³„ì‚°
                    const averageRating = parsedReviews.length > 0 
                        ? (parsedReviews.reduce((sum, review) => sum + review.rating, 0) / parsedReviews.length).toFixed(1)
                        : 0;
                    
                    console.log('í‰ê·  í‰ì :', averageRating);
                    
                    // ê°€ì¥ ë§ì´ ì„ íƒëœ ìŒì‹ ì¢…ë¥˜ ê³„ì‚°
                    const foodTypeCount = {};
                    parsedReviews.forEach(review => {
                        if (review.food_types && review.food_types.length > 0) {
                            review.food_types.forEach(foodType => {
                                foodTypeCount[foodType] = (foodTypeCount[foodType] || 0) + 1;
                            });
                        }
                    });
                    
                    let maxCount = 0;
                    const mostSelectedTypes = [];
                    Object.keys(foodTypeCount).forEach(foodType => {
                        if (foodTypeCount[foodType] > maxCount) {
                            maxCount = foodTypeCount[foodType];
                        }
                    });
                    Object.keys(foodTypeCount).forEach(foodType => {
                        if (foodTypeCount[foodType] === maxCount && maxCount > 0) {
                            mostSelectedTypes.push(foodType);
                        }
                    });
                    
                    console.log('ê°€ì¥ ë§ì´ ì„ íƒëœ ìŒì‹ ì¢…ë¥˜:', mostSelectedTypes);
                    
                    // í‚¤ì›Œë“œ ê³„ì‚°
                    const keywordCount = {};
                    parsedReviews.forEach(review => {
                        if (review.atmosphere && review.atmosphere.length > 0) {
                            review.atmosphere.forEach(keyword => {
                                keywordCount[keyword] = (keywordCount[keyword] || 0) + 1;
                            });
                        }
                        if (review.features && review.features.length > 0) {
                            review.features.forEach(keyword => {
                                keywordCount[keyword] = (keywordCount[keyword] || 0) + 1;
                            });
                        }
                    });
                    
                    const topKeywords = Object.keys(keywordCount)
                        .sort((a, b) => keywordCount[b] - keywordCount[a])
                        .slice(0, 3);
                    
                    console.log('ìƒìœ„ í‚¤ì›Œë“œ:', topKeywords);
                    
                    // ìµœì‹  ì´ë¯¸ì§€ ì°¾ê¸°
                    let latestImage = null;
                    if (parsedReviews.length > 0) {
                        const sortedReviews = [...parsedReviews].sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
                        for (let review of sortedReviews) {
                            if (review.images && review.images.length > 0) {
                                latestImage = review.images[0];
                                break;
                            }
                        }
                    }
                    
                    console.log('ìµœì‹  ì´ë¯¸ì§€:', latestImage);
                    
                    setRestaurantData({
                        reviews: parsedReviews,
                        averageRating: parseFloat(averageRating),
                        reviewCount: parsedReviews.length,
                        mostSelectedFoodTypes: mostSelectedTypes,
                        topKeywords: topKeywords,
                        latestImage: latestImage
                    });
                } else {
                    console.log('ë¦¬ë·° ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                    // ë¦¬ë·°ê°€ ì—†ì„ ë•ŒëŠ” ê¸°ë³¸ê°’ìœ¼ë¡œ ì„¤ì •
                    setRestaurantData({
                        reviews: [],
                        averageRating: 0,
                        reviewCount: 0,
                        mostSelectedFoodTypes: [],
                        topKeywords: [],
                        latestImage: null
                    });
                }

                // ê±°ë¦¬ ê³„ì‚°
                if (restaurant.latitude && restaurant.longitude) {
                    // í˜„ì¬ ìœ„ì¹˜ëŠ” ì„œìš¸ì‹œì²­ìœ¼ë¡œ ê°€ì • (ì‹¤ì œë¡œëŠ” GPSì—ì„œ ê°€ì ¸ì™€ì•¼ í•¨)
                    const currentLat = 37.5665;
                    const currentLon = 126.9780;
                    const calculatedDistance = calculateDistance(
                        currentLat, currentLon,
                        restaurant.latitude, restaurant.longitude
                    );
                    setDistance(calculatedDistance);
                }
            } catch (error) {
                console.error('ì‹ë‹¹ ë°ì´í„° ë¡œë“œ ì˜¤ë¥˜:', error);
            }
        };

        fetchRestaurantData();
        checkFavoriteStatus(); // ì¦ê²¨ì°¾ê¸° ìƒíƒœ í™•ì¸
    }, [restaurant.id]);

    return (
        <TouchableOpacity 
            style={{
                backgroundColor: currentColors.surface,
                borderRadius: 16,
                marginHorizontal: 16,
                marginBottom: 12,
                padding: 16,
                elevation: 2,
                shadowColor: currentColors.primary,
                shadowOffset: { width: 0, height: 2 },
                shadowOpacity: 0.1,
                shadowRadius: 4,
                borderWidth: 1,
                borderColor: 'rgba(99, 102, 241, 0.2)'
            }}
            onPress={() => safeNavigateToTab(navigation, 'ë§›ì§‘', 'RestaurantDetail', { restaurant })}
        >
            <View style={{ flexDirection: 'row' }}>
                {/* ìµœì‹  ì´ë¯¸ì§€ */}
                <View style={{ marginRight: 12 }}>
                    {restaurantData.latestImage ? (
                        <Image 
                            source={{ uri: restaurantData.latestImage }} 
                            style={{ width: 80, height: 80, borderRadius: 8 }}
                        />
                    ) : (
                        <View style={{ 
                            width: 80, 
                            height: 80, 
                            borderRadius: 8, 
                            backgroundColor: '#f8f9fa',
                            justifyContent: 'center',
                            alignItems: 'center'
                        }}>
                            <Ionicons name="image-outline" size={32} color="#adb5bd" />
                        </View>
                    )}
                </View>
                
                {/* ì‹ë‹¹ ì •ë³´ */}
                <View style={{ flex: 1 }}>
                    <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 8 }}>
                        <Text style={{ fontSize: 18, fontWeight: 'bold', color: currentColors.text, flex: 1 }}>
                            {restaurant.name}
                        </Text>
                        {/* ë°©ë¬¸ ê¸°ë¡ ë²„íŠ¼ */}
                        <TouchableOpacity
                            onPress={(e) => {
                                e.stopPropagation(); // ìƒì„¸ë³´ê¸° í™”ë©´ ì´ë™ ë°©ì§€
                                if (onAddVisit) {
                                    onAddVisit(restaurant);
                                }
                            }}
                            style={{
                                marginRight: 8,
                                padding: 4
                            }}
                        >
                            <Ionicons 
                                name="calendar-outline" 
                                size={24} 
                                color={currentColors.primary} 
                            />
                        </TouchableOpacity>
                        
                        {/* ì¦ê²¨ì°¾ê¸° ë²„íŠ¼ */}
                        <TouchableOpacity
                            onPress={(e) => {
                                e.stopPropagation(); // ìƒì„¸ë³´ê¸° í™”ë©´ ì´ë™ ë°©ì§€
                                toggleFavorite();
                            }}
                            style={{
                                marginRight: 8,
                                padding: 4
                            }}
                        >
                            <Ionicons 
                                name={isFavorite ? "heart" : "heart-outline"} 
                                size={24} 
                                color={isFavorite ? "#ff4757" : currentColors.textSecondary} 
                            />
                        </TouchableOpacity>
                        {restaurantData.mostSelectedFoodTypes.length > 0 && (
                            <View style={{
                                backgroundColor: currentColors.primary,
                                borderRadius: 16,
                                paddingHorizontal: 12,
                                paddingVertical: 6,
                                marginLeft: 8
                            }}>
                                <Text style={{ color: '#fff', fontWeight: 'bold', fontSize: 12 }}>
                                    {restaurantData.mostSelectedFoodTypes[0]}
                                </Text>
                            </View>
                        )}
                    </View>
                    
                    {/* ë³„ì , ë¦¬ë·° ìˆ˜, ì˜¤ì°¬ ì¶”ì²œ í•˜íŠ¸ */}
                    <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 8 }}>
                        <Text style={{ fontSize: 14, color: currentColors.textSecondary }}>
                            â­ {restaurantData.reviewCount > 0 ? restaurantData.averageRating.toFixed(1) : '0.0'}
                        </Text>
                        <Text style={{ fontSize: 14, color: currentColors.textSecondary }}>
                            ğŸ’¬ {restaurantData.reviewCount}ê°œ
                        </Text>
                        {(restaurant.recommend_count && restaurant.recommend_count > 0) && (
                            <Text style={{ fontSize: 14, color: currentColors.textSecondary }}>
                                â¤ï¸ {restaurant.recommend_count}ê°œ
                            </Text>
                        )}
                    </View>
                    

                    
                    {/* í‚¤ì›Œë“œ */}
                    {restaurantData.topKeywords.length > 0 && (
                        <View style={{ flexDirection: 'row', flexWrap: 'wrap' }}>
                            {restaurantData.topKeywords.slice(0, 3).map((keyword, index) => (
                                <Text key={index} style={{ 
                                    color: currentColors.textSecondary, 
                                    fontSize: 12, 
                                    marginRight: 8,
                                    marginBottom: 4
                                }}>
                                    #{keyword}
                                </Text>
                            ))}
                        </View>
                    )}
                    
                    {/* ì¶”ì²œ íƒœê·¸ */}
                    {activeTab !== 'all' && (
                        <View style={{
                            backgroundColor: activeTab === 'personal' ? currentColors.primaryLight : currentColors.secondary + '20',
                            borderRadius: 12,
                            paddingVertical: 4,
                            paddingHorizontal: 8,
                            alignSelf: 'flex-start',
                            marginTop: 8
                        }}>
                            <Text style={{
                                color: activeTab === 'personal' ? currentColors.primary : currentColors.secondary,
                                fontWeight: 'bold',
                                fontSize: 12
                            }}>
                                {activeTab === 'personal' ? 'ê°œì¸ ì¶”ì²œ' : 'ì¹œêµ¬ ì¶”ì²œ'}
                            </Text>
                        </View>
                    )}
                </View>
            </View>
        </TouchableOpacity>
    );
}

function RestaurantsScreen({ navigation }) {
    const { user } = useAuth();
    const { handleActionCompletion } = useMission();
    const [restaurants, setRestaurants] = useState([]);
    const [recommendations, setRecommendations] = useState({ personal: [], friend: [] });
    const [isLoading, setIsLoading] = useState(true);
    const [searchQuery, setSearchQuery] = useState('');
    const [activeTab, setActiveTab] = useState('all'); // 'all', 'personal', 'friend'
    const [sortBy, setSortBy] = useState('name');
    const [categoryFilter, setCategoryFilter] = useState(null);
    const [isCategoryModalVisible, setCategoryModalVisible] = useState(false);
    const [paginationInfo, setPaginationInfo] = useState({ total: 0, pages: 0, currentPage: 1 });
    const [showVisitModal, setShowVisitModal] = useState(false);
    const [selectedRestaurantForVisit, setSelectedRestaurantForVisit] = useState(null);
    const [currentUser, setCurrentUser] = useState(null);
    const CATEGORY_OPTIONS = ['í•œì‹', 'ì¤‘ì‹', 'ì¼ì‹', 'ì–‘ì‹', 'ë¶„ì‹', 'ì¹´í˜', 'ì•„ì‹œì•ˆ', 'í“¨ì „', 'ê¸°íƒ€'];

    // ì‚¬ìš©ì ì •ë³´ ì´ˆê¸°í™”
    useEffect(() => {
        const initUser = async () => {
            try {
                await userManager.initialize();
                setCurrentUser(userManager.getCurrentUser());
            } catch (error) {
                console.error('ì‚¬ìš©ì ì •ë³´ ì´ˆê¸°í™” ì‹¤íŒ¨:', error);
            }
        };
        initUser();
    }, []);
    
    useFocusEffect(useCallback(() => {
        setIsLoading(true);
        let url = `${RENDER_SERVER_URL}/restaurants?query=${searchQuery}&sort_by=${sortBy}`;
        if (categoryFilter) url += `&category=${categoryFilter}`;
        fetch(url).then(res => res.json()).then(data => { 
            if(data && data.restaurants) {
                setRestaurants(data.restaurants);
                setPaginationInfo({
                    total: data.total || 0,
                    pages: data.pages || 0,
                    currentPage: data.current_page || 1
                });
                console.log(`ì‹ë‹¹ ë°ì´í„° ë¡œë“œ: ${data.restaurants.length}ê°œ, ì „ì²´: ${data.total}ê°œ, í˜ì´ì§€: ${data.pages}ê°œ`);
                
                // ê²€ìƒ‰ ë§ˆìŠ¤í„° ë¯¸ì…˜ ì™„ë£Œ ì²˜ë¦¬ (ê²€ìƒ‰ì–´ê°€ ìˆì„ ë•Œë§Œ)
                if (searchQuery.trim()) {
                    handleActionCompletion('restaurant_search');
                }
            } else if(Array.isArray(data)) {
                setRestaurants(data);
                setPaginationInfo({ total: data.length, pages: 1, currentPage: 1 });
            }
        }).catch(err => console.error(err)).finally(() => setIsLoading(false));
        
        // ì¶”ì²œ ì‹ë‹¹ë„ í•¨ê»˜ ê°€ì ¸ì˜¤ê¸°
        fetchRecommendations();
    }, [searchQuery, sortBy, categoryFilter]));

    const fetchRecommendations = async () => {
        try {
            // currentUserê°€ ì—†ìœ¼ë©´ ê¸°ë³¸ê°’ ì‚¬ìš©
            const userId = currentUser?.employee_id || 'default_user';
            const response = await fetch(`${RENDER_SERVER_URL}/restaurants/recommend?employee_id=${userId}`);
            if (response.ok) {
                const data = await response.json();
                setRecommendations({
                    personal: data.personal_recommendations || [],
                    friend: data.friend_recommendations || []
                });
            }
        } catch (error) {
            console.error('ì¶”ì²œ ì‹ë‹¹ ì¡°íšŒ ì‹¤íŒ¨:', error);
        }
    };

    // ë°©ë¬¸ ê¸°ë¡ ì¶”ê°€
    const addRestaurantVisit = async (restaurantId, visitDate, visitTime, partySize) => {
        try {
            const userId = 'KOICA001'; // ì„ì‹œ ì‚¬ìš©ì ID
            const response = await fetch(`${RENDER_SERVER_URL}/restaurants/visits`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    user_id: userId,
                    restaurant_id: restaurantId,
                    visit_date: visitDate,
                    visit_time: visitTime,
                    party_size: partySize
                })
            });

            if (response.ok) {
                const result = await response.json();
                Alert.alert('ë°©ë¬¸ ê¸°ë¡ ì¶”ê°€', 'ë°©ë¬¸ ê¸°ë¡ì´ ì„±ê³µì ìœ¼ë¡œ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.');
                
                // ë§›ì§‘ íƒí—˜ ë¯¸ì…˜ ì™„ë£Œ ì²˜ë¦¬ (ì„ì‹œ ë¹„í™œì„±í™”)
                // handleActionCompletion('restaurant_visit');
                
                // ëª¨ë‹¬ ë‹«ê¸°
                setShowVisitModal(false);
                setSelectedRestaurantForVisit(null);
                
                // ì¶”ì²œ ì‹ë‹¹ ë‹¤ì‹œ ë¡œë“œ (ë°©ë¬¸ ê¸°ë¡ì´ ë³€ê²½ë˜ì—ˆìœ¼ë¯€ë¡œ)
                fetchRecommendations();
            } else {
                const errorData = await response.json();
                Alert.alert('ì˜¤ë¥˜', errorData.error || 'ë°©ë¬¸ ê¸°ë¡ ì¶”ê°€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }
        } catch (error) {
            console.error('ë°©ë¬¸ ê¸°ë¡ ì¶”ê°€ ì˜¤ë¥˜:', error);
            Alert.alert('ì˜¤ë¥˜', 'ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        }
    };

    return (
        <SafeAreaView style={styles.safeArea}>
            {/* ê²€ìƒ‰ ë° í•„í„° */}
            <View style={{paddingHorizontal: 16, paddingVertical: 12, backgroundColor: currentColors.background}}>
                <TextInput 
                    style={{
                        backgroundColor: currentColors.surface,
                        borderRadius: 16,
                        padding: 14,
                        fontSize: 16,
                        marginBottom: 12,
                        borderWidth: 1,
                        borderColor: currentColors.lightGray
                    }} 
                    placeholder="ë§›ì§‘ ì´ë¦„ ê²€ìƒ‰..." 
                    placeholderTextColor={currentColors.gray} 
                    value={searchQuery} 
                    onChangeText={setSearchQuery} 
                />
                <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                    <TouchableOpacity
                        style={{
                            backgroundColor: sortBy === 'name' ? currentColors.primary : currentColors.surface,
                            borderRadius: 20,
                            paddingVertical: 8,
                            paddingHorizontal: 16,
                            marginRight: 8,
                            elevation: sortBy === 'name' ? 2 : 1,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: sortBy === 'name' ? 0.2 : 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: sortBy === 'name' ? currentColors.primary : currentColors.lightGray
                        }}
                        onPress={() => setSortBy('name')}
                    >
                        <Text style={{
                            color: sortBy === 'name' ? '#FFFFFF' : currentColors.text,
                            fontWeight: sortBy === 'name' ? 'bold' : '600',
                            fontSize: 14
                        }}>
                            ì´ë¦„ìˆœ
                        </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                        style={{
                            backgroundColor: sortBy === 'rating_desc' ? currentColors.primary : currentColors.surface,
                            borderRadius: 20,
                            paddingVertical: 8,
                            paddingHorizontal: 16,
                            marginRight: 8,
                            elevation: sortBy === 'rating_desc' ? 2 : 1,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: sortBy === 'rating_desc' ? 0.2 : 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: sortBy === 'rating_desc' ? currentColors.primary : currentColors.lightGray
                        }}
                        onPress={() => setSortBy('rating_desc')}
                    >
                        <Text style={{
                            color: sortBy === 'rating_desc' ? '#FFFFFF' : currentColors.text,
                            fontWeight: sortBy === 'rating_desc' ? 'bold' : '600',
                            fontSize: 14
                        }}>
                            â­ë³„ì ìˆœ
                        </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                        style={{
                            backgroundColor: sortBy === 'reviews_desc' ? currentColors.primary : currentColors.surface,
                            borderRadius: 20,
                            paddingVertical: 8,
                            paddingHorizontal: 16,
                            marginRight: 8,
                            elevation: sortBy === 'reviews_desc' ? 2 : 1,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: sortBy === 'reviews_desc' ? 0.2 : 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: sortBy === 'reviews_desc' ? currentColors.primary : currentColors.lightGray
                        }}
                        onPress={() => setSortBy('reviews_desc')}
                    >
                        <Text style={{
                            color: sortBy === 'reviews_desc' ? '#FFFFFF' : currentColors.text,
                            fontWeight: sortBy === 'reviews_desc' ? 'bold' : '600',
                            fontSize: 14
                        }}>
                            ğŸ’¬ë¦¬ë·°ìˆœ
                        </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                        style={{
                            backgroundColor: sortBy === 'recommend_desc' ? currentColors.primary : currentColors.surface,
                            borderRadius: 20,
                            paddingVertical: 8,
                            paddingHorizontal: 16,
                            marginRight: 8,
                            elevation: sortBy === 'recommend_desc' ? 2 : 1,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: sortBy === 'recommend_desc' ? 0.2 : 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: sortBy === 'recommend_desc' ? currentColors.primary : currentColors.lightGray
                        }}
                        onPress={() => setSortBy('recommend_desc')}
                    >
                        <Text style={{
                            color: sortBy === 'recommend_desc' ? '#FFFFFF' : currentColors.text,
                            fontWeight: sortBy === 'recommend_desc' ? 'bold' : '600',
                            fontSize: 14
                        }}>
                            â¤ï¸ì˜¤ì°¬ì¶”ì²œìˆœ
                        </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                        style={{
                            backgroundColor: categoryFilter ? currentColors.primary : currentColors.surface,
                            borderRadius: 20,
                            paddingVertical: 8,
                            paddingHorizontal: 16,
                            marginRight: 8,
                            elevation: categoryFilter ? 2 : 1,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: categoryFilter ? 0.2 : 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: categoryFilter ? currentColors.primary : currentColors.lightGray,
                            flexDirection: 'row',
                            alignItems: 'center'
                        }}
                        onPress={() => setCategoryModalVisible(true)}
                    >
                        <Ionicons name="filter" size={16} color={categoryFilter ? '#FFFFFF' : currentColors.gray} />
                        <Text style={{
                            color: categoryFilter ? '#FFFFFF' : currentColors.text,
                            fontWeight: categoryFilter ? 'bold' : '600',
                            fontSize: 14,
                            marginLeft: 4
                        }}>
                            {categoryFilter || 'ì¹´í…Œê³ ë¦¬'}
                        </Text>
                        {categoryFilter && (
                            <TouchableOpacity onPress={() => setCategoryFilter(null)} style={{marginLeft: 4}}>
                                <Ionicons name="close-circle" size={16} color="#FFFFFF" />
                            </TouchableOpacity>
                        )}
                    </TouchableOpacity>
                </ScrollView>
            </View>

            <SelectionModal visible={isCategoryModalVisible} title="ì¹´í…Œê³ ë¦¬ í•„í„°" options={CATEGORY_OPTIONS} selected={categoryFilter} onSelect={setCategoryFilter} onClose={() => setCategoryModalVisible(false)} styles={styles} colors={currentColors} />
            
            {/* íƒ­ ë„¤ë¹„ê²Œì´ì…˜ */}
            <View style={{paddingHorizontal: 16, paddingVertical: 12, backgroundColor: currentColors.background}}>
                <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                    <TouchableOpacity
                        style={{
                            backgroundColor: activeTab === 'all' ? currentColors.primary : currentColors.surface,
                            borderRadius: 20,
                            paddingVertical: 8,
                            paddingHorizontal: 16,
                            marginRight: 8,
                            elevation: activeTab === 'all' ? 2 : 1,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: activeTab === 'all' ? 0.2 : 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: activeTab === 'all' ? currentColors.primary : currentColors.lightGray
                        }}
                        onPress={() => setActiveTab('all')}
                    >
                        <Text style={{
                            color: activeTab === 'all' ? '#FFFFFF' : currentColors.text,
                            fontWeight: activeTab === 'all' ? 'bold' : '600',
                            fontSize: 14
                        }}>
                            ì „ì²´
                        </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                        style={{
                            backgroundColor: activeTab === 'personal' ? currentColors.primary : currentColors.surface,
                            borderRadius: 20,
                            paddingVertical: 8,
                            paddingHorizontal: 16,
                            marginRight: 8,
                            elevation: activeTab === 'personal' ? 2 : 1,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: activeTab === 'personal' ? 0.2 : 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: activeTab === 'personal' ? currentColors.primary : currentColors.lightGray
                        }}
                        onPress={() => setActiveTab('personal')}
                    >
                        <Text style={{
                            color: activeTab === 'personal' ? '#FFFFFF' : currentColors.text,
                            fontWeight: activeTab === 'personal' ? 'bold' : '600',
                            fontSize: 14
                        }}>
                            ê°œì¸ ì¶”ì²œ
                        </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                        style={{
                            backgroundColor: activeTab === 'friend' ? currentColors.primary : currentColors.surface,
                            borderRadius: 20,
                            paddingVertical: 8,
                            paddingHorizontal: 16,
                            marginRight: 8,
                            elevation: activeTab === 'friend' ? 2 : 1,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: activeTab === 'friend' ? 0.2 : 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: activeTab === 'friend' ? currentColors.primary : currentColors.lightGray
                        }}
                        onPress={() => setActiveTab('friend')}
                    >
                        <Text style={{
                            color: activeTab === 'friend' ? '#FFFFFF' : currentColors.text,
                            fontWeight: activeTab === 'friend' ? 'bold' : '600',
                            fontSize: 14
                        }}>
                            ì¹œêµ¬ ì¶”ì²œ
                        </Text>
                    </TouchableOpacity>
                </ScrollView>
            </View>
            
            {isLoading ? (
                <ActivityIndicator size="large" style={{marginTop: 20}} color={currentColors.primary} />
            ) : (
                <FlatList 
                    data={
                        activeTab === 'all' ? restaurants :
                        activeTab === 'personal' ? recommendations.personal :
                        activeTab === 'friend' ? recommendations.friend : []
                    }
                    keyExtractor={item => item.id.toString()} 
                    renderItem={({ item }) => (
                        <RestaurantItem 
                            restaurant={item} 
                            navigation={navigation} 
                            activeTab={activeTab}
                            currentColors={currentColors}
                            onAddVisit={(restaurant) => {
                                setSelectedRestaurantForVisit(restaurant);
                                setShowVisitModal(true);
                            }}
                        />
                    )} 
                    ListEmptyComponent={
                        <Text style={{fontSize: 16, color: currentColors.textSecondary, textAlign: 'center', marginTop: 50, paddingHorizontal: 16}}>
                            {activeTab === 'all' ? 'ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.' :
                             activeTab === 'personal' ? 'ê°œì¸ ì¶”ì²œ ì‹ë‹¹ì´ ì—†ìŠµë‹ˆë‹¤.' :
                             'ì¹œêµ¬ ì¶”ì²œ ì‹ë‹¹ì´ ì—†ìŠµë‹ˆë‹¤.'}
                        </Text>
                    } 
                    ListFooterComponent={
                        activeTab === 'all' && paginationInfo.total > 0 ? (
                            <View style={{
                                paddingHorizontal: 16,
                                paddingVertical: 20,
                                alignItems: 'center',
                                borderTopWidth: 1,
                                borderTopColor: currentColors.border
                            }}>
                                <Text style={{
                                    fontSize: 14,
                                    color: currentColors.textSecondary,
                                    marginBottom: 8
                                }}>
                                    ì „ì²´ {paginationInfo.total}ê°œ ì¤‘ {restaurants.length}ê°œ í‘œì‹œ
                                </Text>
                                {paginationInfo.pages > 1 && (
                                    <Text style={{
                                        fontSize: 12,
                                        color: currentColors.gray
                                    }}>
                                        {paginationInfo.currentPage} / {paginationInfo.pages} í˜ì´ì§€
                                    </Text>
                                )}
                            </View>
                        ) : null
                    }
                    contentContainerStyle={{paddingTop: 16, paddingBottom: 200}}  
                />
            )}
            
            {/* ë°©ë¬¸ ê¸°ë¡ ëª¨ë‹¬ */}
            {showVisitModal && selectedRestaurantForVisit && (
                <VisitRecordModal
                    visible={showVisitModal}
                    restaurant={selectedRestaurantForVisit}
                    onClose={() => {
                        setShowVisitModal(false);
                        setSelectedRestaurantForVisit(null);
                    }}
                    onSubmit={(restaurantId, visitDate, visitTime, partySize) => {
                        // ë°©ë¬¸ ê¸°ë¡ ì¶”ê°€ API í˜¸ì¶œ
                        addRestaurantVisit(restaurantId, visitDate, visitTime, partySize);
                    }}
                />
            )}
            
            {/* í”Œë¡œíŒ… ì¶”ê°€ ë²„íŠ¼ */}
            <TouchableOpacity
                style={{
                    position: 'absolute',
                    right: 24,
                    bottom: 32,
                    width: 56,
                    height: 56,
                    borderRadius: 28,
                    backgroundColor: currentColors.primary,
                    justifyContent: 'center',
                    alignItems: 'center',
                    zIndex: 10,
                    elevation: 8,
                    shadowColor: currentColors.primary,
                    shadowOffset: { width: 0, height: 4 },
                    shadowOpacity: 0.3,
                    shadowRadius: 8
                }}
                activeOpacity={0.85}
                onPress={() => navigation.navigate('AddRestaurant')}
            >
                <Ionicons name="add" size={32} color="#fff" />
            </TouchableOpacity>
        </SafeAreaView>
    );
}

function AddRestaurantScreen({ navigation }) {
    const [name, setName] = useState('');
    const [category, setCategory] = useState('');
    const [address, setAddress] = useState('');
    const [isCategoryModalVisible, setCategoryModalVisible] = useState(false);
    const CATEGORY_OPTIONS = ['í•œì‹', 'ì¤‘ì‹', 'ì¼ì‹', 'ì–‘ì‹', 'ë¶„ì‹', 'ì¹´í˜', 'ì•„ì‹œì•ˆ', 'í“¨ì „', 'ê¸°íƒ€'];

    const handleSubmit = async () => {
        if (!name.trim() || !category || !address.trim()) {
            Alert.alert('ì…ë ¥ ì˜¤ë¥˜', 'ë§›ì§‘ ì´ë¦„, ì¹´í…Œê³ ë¦¬, ì£¼ì†Œë¥¼ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”.');
            return;
        }

        try {
            const response = await fetch(`${RENDER_SERVER_URL}/restaurants`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: name.trim(),
                    category: category,
                    address: address.trim()
                })
            });
            const data = await response.json();
            if (response.ok) {
                Alert.alert('ì„±ê³µ', 'ìƒˆë¡œìš´ ë§›ì§‘ì´ ì¶”ê°€ë˜ì—ˆìŠµë‹ˆë‹¤.');
                navigation.goBack();
            } else {
                Alert.alert('ì˜¤ë¥˜', data.message || 'ë§›ì§‘ ì¶”ê°€ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }
        } catch (error) {
            Alert.alert('ì˜¤ë¥˜', 'ë„¤íŠ¸ì›Œí¬ ìš”ì²­ ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        }
    };

    return (
        <SafeAreaView style={styles.safeArea}>
            <ScrollView contentContainerStyle={styles.formContainer}>
                <Text style={styles.inputLabel}>ë§›ì§‘ ì´ë¦„ *</Text>
                <TextInput 
                    style={styles.input} 
                    placeholder="ì˜ˆ: íŒêµì—­ ë§›ì§‘" 
                    value={name} 
                    onChangeText={setName}
                    returnKeyType="done"
                    onSubmitEditing={() => {
                        Keyboard.dismiss();
                    }}
                    blurOnSubmit={true}
                />
                
                <Text style={styles.inputLabel}>ì¹´í…Œê³ ë¦¬ *</Text>
                <TouchableOpacity style={styles.input} onPress={() => setCategoryModalVisible(true)}>
                    <Text style={category ? {color: currentColors.black} : {color: currentColors.gray}}>
                        {category || 'ì¹´í…Œê³ ë¦¬ë¥¼ ì„ íƒí•˜ì„¸ìš”'}
                    </Text>
                </TouchableOpacity>
                
                <Text style={styles.inputLabel}>ì£¼ì†Œ *</Text>
                <TextInput 
                    style={styles.input} 
                    placeholder="ì˜ˆ: ê²½ê¸°ë„ ì„±ë‚¨ì‹œ ë¶„ë‹¹êµ¬ íŒêµì—­ë¡œ 146" 
                    value={address} 
                    onChangeText={setAddress}
                    returnKeyType="done"
                    onSubmitEditing={() => {
                        Keyboard.dismiss();
                    }}
                    blurOnSubmit={true}
                />
                
                <TouchableOpacity style={styles.submitButton} onPress={handleSubmit}>
                    <Text style={styles.submitButtonText}>ë§›ì§‘ ì¶”ê°€í•˜ê¸°</Text>
                </TouchableOpacity>
                
                <TouchableOpacity style={[styles.submitButton, { backgroundColor: currentColors.gray, marginTop: 10 }]} onPress={() => navigation.navigate('ë§›ì§‘')}>
                    <Text style={styles.submitButtonText}>ì·¨ì†Œí•˜ê¸°</Text>
                </TouchableOpacity>
            </ScrollView>
            
            <SelectionModal 
                visible={isCategoryModalVisible} 
                title="ì¹´í…Œê³ ë¦¬ ì„ íƒ" 
                options={CATEGORY_OPTIONS} 
                selected={category} 
                onSelect={setCategory} 
                onClose={() => setCategoryModalVisible(false)} 
                styles={styles} colors={currentColors} 
            />
        </SafeAreaView>
    );
}
// --- íŒŒí‹° íƒ­ ---
function PartyListScreen({ navigation }) {
    const [myParties, setMyParties] = useState([]);
    const [allParties, setAllParties] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    
    // MissionContext ì‚¬ìš©
    const { handleActionCompletion } = useMission();
    
    // ğŸš¨ ì¤‘ìš”: ì „ì—­ ë³€ìˆ˜ ìƒˆ íŒŒí‹° ë°ì´í„° ì¦‰ì‹œ ê°ì§€ (useFocusEffectì™€ ë³„ë„ë¡œ)
    useEffect(() => {
        if (global.newPartyData) {
                            // console.log('ğŸ” [ì¼ë°˜íŒŒí‹°] useEffectì—ì„œ ìƒˆ íŒŒí‹° ë°ì´í„° ê°ì§€:', global.newPartyData);
            
            // ìƒˆ íŒŒí‹°ë¥¼ ë‚´ íŒŒí‹° ëª©ë¡ê³¼ ì „ì²´ íŒŒí‹° ëª©ë¡ì— ì¶”ê°€
            const newParty = {
                id: global.newPartyData.id || Date.now(), // ì„œë²„ì—ì„œ ë°˜í™˜ëœ ì‹¤ì œ ID ì‚¬ìš©
                title: global.newPartyData.title,
                party_date: global.newPartyData.date,
                party_time: global.newPartyData.time,
                restaurant_name: global.newPartyData.restaurant,
                current_members: 1, // ìƒì„±ìê°€ ì²« ë²ˆì§¸ ë©¤ë²„
                max_members: global.newPartyData.maxMembers,
                location: global.newPartyData.location,
                description: global.newPartyData.description,
                members: global.newPartyData.attendees || [], // ì°¸ì—¬ì ëª©ë¡ ì¶”ê°€
                host_employee_id: global.newPartyData.host_employee_id || global.myEmployeeId || '1' // í˜¸ìŠ¤íŠ¸ ID ì¶”ê°€
            };
            

            
            setMyParties(prev => {

                // ğŸš¨ ì¤‘ìš”: ì¤‘ë³µ ID ì œê±° í›„ ìƒˆ íŒŒí‹° ì¶”ê°€
                const filtered = (prev || []).filter(party => party.id !== newParty.id);
                const updated = [newParty, ...filtered];

                
                // ğŸš¨ ì¤‘ìš”: AsyncStorageì— ì˜êµ¬ ì €ì¥
                AsyncStorage.setItem('@my_parties', JSON.stringify(updated));
                // myParties AsyncStorage ì €ì¥ ì™„ë£Œ
                
                return updated;
            });
            
            setAllParties(prev => {

                // ğŸš¨ ì¤‘ìš”: ì¤‘ë³µ ID ì œê±° í›„ ìƒˆ íŒŒí‹° ì¶”ê°€
                const filtered = (prev || []).filter(party => party.id !== newParty.id);
                const updated = [newParty, ...filtered];

                
                // ğŸš¨ ì¤‘ìš”: AsyncStorageì— ì˜êµ¬ ì €ì¥
                AsyncStorage.setItem('@all_parties', JSON.stringify(updated));
                // allParties AsyncStorage ì €ì¥ ì™„ë£Œ
                
                return updated;
            });
            
            // ì „ì—­ ë³€ìˆ˜ ì´ˆê¸°í™”
            global.newPartyData = undefined;
            

        }
    }, [global.newPartyData]);

    useFocusEffect(useCallback(() => {

        
        setIsLoading(true);
        
        // ğŸš¨ ì¤‘ìš”: ìƒˆ íŒŒí‹° ìƒì„± ê°ì§€ ë° ì¶”ê°€
        if (global.newPartyData) {

            
            // ìƒˆ íŒŒí‹°ë¥¼ ë‚´ íŒŒí‹° ëª©ë¡ê³¼ ì „ì²´ íŒŒí‹° ëª©ë¡ì— ì¶”ê°€
            const newParty = {
                id: global.newPartyData.id || Date.now(), // ì„œë²„ì—ì„œ ë°˜í™˜ëœ ì‹¤ì œ ID ì‚¬ìš©
                title: global.newPartyData.title,
                party_date: global.newPartyData.date,
                party_time: global.newPartyData.time,
                restaurant_name: global.newPartyData.restaurant,
                current_members: 1, // ìƒì„±ìê°€ ì²« ë²ˆì§¸ ë©¤ë²„
                max_members: global.newPartyData.maxMembers,
                location: global.newPartyData.location,
                description: global.newPartyData.description,
                members: global.newPartyData.attendees || [], // ì°¸ì—¬ì ëª©ë¡ ì¶”ê°€
                host_employee_id: global.newPartyData.host_employee_id || global.myEmployeeId || '1' // í˜¸ìŠ¤íŠ¸ ID ì¶”ê°€
            };
            

            
            setMyParties(prev => {

                // ğŸš¨ ì¤‘ìš”: ì¤‘ë³µ ID ì œê±° í›„ ìƒˆ íŒŒí‹° ì¶”ê°€
                const filtered = prev.filter(party => party.id !== newParty.id);
                const updated = [newParty, ...filtered];

                return updated;
            });
            
            setAllParties(prev => {

                // ğŸš¨ ì¤‘ìš”: ì¤‘ë³µ ID ì œê±° í›„ ìƒˆ íŒŒí‹° ì¶”ê°€
                const filtered = prev.filter(party => party.id !== newParty.id);
                const updated = [newParty, ...filtered];

                return updated;
            });
            
            // ì „ì—­ ë³€ìˆ˜ ì´ˆê¸°í™”
            global.newPartyData = undefined;
            

            setIsLoading(false);
            return;
        }
        
                        // console.log('ğŸ” [ì¼ë°˜íŒŒí‹°] ìƒˆ íŒŒí‹° ë°ì´í„° ì—†ìŒ, AsyncStorageì—ì„œ ë³µì› ì‹œë„');
        
        // ğŸš¨ ì¤‘ìš”: AsyncStorageì—ì„œ íŒŒí‹° ëª©ë¡ ë³µì›
        Promise.all([
            AsyncStorage.getItem('@my_parties').then(data => data ? JSON.parse(data) : []),
            AsyncStorage.getItem('@all_parties').then(data => data ? JSON.parse(data) : [])
        ]).then(([myPartiesData, allPartiesData]) => {
                            // console.log('ğŸ” [ì¼ë°˜íŒŒí‹°] AsyncStorageì—ì„œ ë³µì›ëœ myParties:', myPartiesData);
                // console.log('ğŸ” [ì¼ë°˜íŒŒí‹°] AsyncStorageì—ì„œ ë³µì›ëœ allParties:', allPartiesData);
            
            // ğŸš¨ ì¤‘ìš”: ì•ˆì „í•œ ìƒíƒœ ì„¤ì •
            setMyParties(Array.isArray(myPartiesData) ? myPartiesData : []);
            setAllParties(Array.isArray(allPartiesData) ? allPartiesData : []);
            
            if(Array.isArray(myPartiesData) && myPartiesData.length > 0) {
                // console.log('ğŸ” [ì¼ë°˜íŒŒí‹°] AsyncStorageì—ì„œ myParties ë³µì› ì™„ë£Œ');
            }
            if(Array.isArray(allPartiesData) && allPartiesData.length > 0) {
                // console.log('ğŸ” [ì¼ë°˜íŒŒí‹°] AsyncStorageì—ì„œ allParties ë³µì› ì™„ë£Œ');
            }
            
            // ğŸš¨ ì¤‘ìš”: AsyncStorageì— ë°ì´í„°ê°€ ìˆìœ¼ë©´ API í˜¸ì¶œ ê±´ë„ˆë›°ê¸°
            if((myPartiesData && myPartiesData.length > 0) || (allPartiesData && allPartiesData.length > 0)) {
                // console.log('ğŸ” [ì¼ë°˜íŒŒí‹°] AsyncStorage ë°ì´í„°ë¡œ ë³µì› ì™„ë£Œ, API í˜¸ì¶œ ê±´ë„ˆë›°ê¸°');
                setIsLoading(false);
                return;
            }
            
                            // console.log('ğŸ” [ì¼ë°˜íŒŒí‹°] AsyncStorageì— ë°ì´í„° ì—†ìŒ, API í˜¸ì¶œ ì‹œì‘');
            
            // ê¸°ì¡´ API í˜¸ì¶œ
        Promise.all([
            fetch(`${RENDER_SERVER_URL}/my_regular_parties/${global.myEmployeeId || '1'}`).then(res => res.json()),
            fetch(`${RENDER_SERVER_URL}/parties`).then(res => res.json())
        ]).then(([myPartiesData, allPartiesData]) => {
                // ğŸš¨ ì¤‘ìš”: ì•ˆì „í•œ ë°°ì—´ ì„¤ì •
                setMyParties(Array.isArray(myPartiesData) ? myPartiesData : []);
                setAllParties(Array.isArray(allPartiesData) ? allPartiesData : []);
        }).catch(console.error).finally(() => setIsLoading(false));
        }).catch(error => {
            console.error('ğŸ” [ì¼ë°˜íŒŒí‹°] AsyncStorage ë³µì› ì‹¤íŒ¨:', error);
            
            // API í˜¸ì¶œë¡œ í´ë°±
            Promise.all([
                fetch(`${RENDER_SERVER_URL}/my_regular_parties/${global.myEmployeeId || '1'}`).then(res => res.json()),
                fetch(`${RENDER_SERVER_URL}/parties`).then(res => res.json())
            ]).then(([myPartiesData, allPartiesData]) => {
                // ğŸš¨ ì¤‘ìš”: ì•ˆì „í•œ ë°°ì—´ ì„¤ì •
                setMyParties(Array.isArray(myPartiesData) ? myPartiesData : []);
                setAllParties(Array.isArray(allPartiesData) ? allPartiesData : []);
            }).catch(console.error).finally(() => setIsLoading(false));
        });
    }, [global.newPartyData])); // ğŸš¨ ì¤‘ìš”: global.newPartyData ë³€ê²½ ê°ì§€

    const renderPartyItem = ({ item }) => {
        // ğŸš¨ ì¤‘ìš”: itemì´ ìœ íš¨í•œì§€ í™•ì¸
        if (!item || typeof item !== 'object') {
                            // console.log('ğŸ” [ì¼ë°˜íŒŒí‹°] renderPartyItem: ìœ íš¨í•˜ì§€ ì•Šì€ item:', item);
            return null;
        }
        
        return (
        <TouchableOpacity style={{
            backgroundColor: currentColors.surface,
            borderRadius: 20,
            padding: 20,
            marginHorizontal: 16,
            marginBottom: 16,
            elevation: 3,
            shadowColor: currentColors.primary,
            shadowOffset: { width: 0, height: 4 },
            shadowOpacity: 0.1,
            shadowRadius: 8,
            borderWidth: 1,
            borderColor: 'rgba(59, 130, 246, 0.1)'
            }} onPress={() => navigation.navigate('PartyDetail', { partyId: item.id, partyData: item })}>
                <Text style={{fontSize: 18, fontWeight: 'bold', color: currentColors.text, marginBottom: 8}}>{item.title || 'ì œëª© ì—†ìŒ'}</Text>
                <Text style={{fontSize: 14, color: currentColors.textSecondary, marginBottom: 4}}>ğŸ—“ï¸ {item.party_date || 'ë‚ ì§œ ì—†ìŒ'} {item.party_time || 'ì‹œê°„ ì—†ìŒ'}</Text>
                <Text style={{fontSize: 14, color: currentColors.textSecondary}}>ğŸ‘¥ {item.current_members || 0} / {item.max_members || 0}ëª… @ {item.restaurant_name || 'ì‹ë‹¹ ì—†ìŒ'}</Text>
        </TouchableOpacity>
    );
    };

    const renderMyPartyItem = ({ item }) => {
        // ğŸš¨ ì¤‘ìš”: itemì´ ìœ íš¨í•œì§€ í™•ì¸
        if (!item || typeof item !== 'object') {
                            // console.log('ğŸ” [ì¼ë°˜íŒŒí‹°] renderMyPartyItem: ìœ íš¨í•˜ì§€ ì•Šì€ item:', item);
            return null;
        }
        
        return (
        <TouchableOpacity style={{
            backgroundColor: currentColors.surface,
            borderRadius: 20,
            padding: 20,
            marginHorizontal: 6,
            width: SCREEN_WIDTH * 0.5,
            height: 160,
            borderWidth: 1,
            borderColor: 'rgba(59, 130, 246, 0.1)',
            justifyContent: 'flex-start',
            elevation: 3,
            shadowColor: currentColors.primary,
            shadowOffset: { width: 0, height: 4 },
            shadowOpacity: 0.1,
            shadowRadius: 8
            }} onPress={() => navigation.navigate('PartyDetail', { partyId: item.id, partyData: item })}>
                <Text style={{fontSize: 16, fontWeight: 'bold', color: currentColors.text, marginBottom: 6, numberOfLines: 1}}>{item.title || 'ì œëª© ì—†ìŒ'}</Text>
                <Text style={{fontSize: 13, color: currentColors.textSecondary, marginBottom: 6}}>ğŸ—“ï¸ {item.party_date || 'ë‚ ì§œ ì—†ìŒ'} {item.party_time || 'ì‹œê°„ ì—†ìŒ'}</Text>
            <View style={{flexDirection: 'row', justifyContent: 'space-between', marginTop: 6, alignItems: 'center'}}>
                    <Text style={{fontSize: 12, color: currentColors.textSecondary}}>ğŸ‘¥ {item.current_members || 0}/{item.max_members || 0}ëª…</Text>
                    <Text style={{fontSize: 12, color: currentColors.textSecondary, numberOfLines: 1}}>ğŸ“ {item.restaurant_name || 'ì‹ë‹¹ ì—†ìŒ'}</Text>
            </View>
        </TouchableOpacity>
    );
    };

    if (isLoading) return <ActivityIndicator style={{flex: 1}} size="large" color={currentColors.primary} />;

    // ğŸš¨ ì¤‘ìš”: ì•ˆì „í•œ ë°°ì—´ ì ‘ê·¼ì„ ìœ„í•œ ê¸°ë³¸ê°’ ì„¤ì • ë° ì¶”ê°€ ê²€ì¦
    const safeMyParties = Array.isArray(myParties) ? myParties : [];
    const safeAllParties = Array.isArray(allParties) ? allParties : [];
    
    // ğŸš¨ ì¤‘ìš”: ë””ë²„ê¹…ì„ ìœ„í•œ ìƒíƒœ ë¡œê¹…
                    // console.log('ğŸ” [ì¼ë°˜íŒŒí‹°] ë Œë”ë§ ì‹œ ìƒíƒœ:', { myParties, allParties, safeMyParties, safeAllParties });

    return (
        <ScrollView style={styles.safeArea}>
            <Text style={{fontSize: 20, fontWeight: 'bold', marginBottom: 12, color: currentColors.primary, paddingHorizontal: 16, marginTop: 16}}>ë‚´ ì¼ë°˜íŒŒí‹°</Text>
            {safeMyParties.length > 0 ? (
                <FlatList 
                    data={safeMyParties.filter(item => item && typeof item === 'object')} 
                    renderItem={renderMyPartyItem} 
                    keyExtractor={item => `my-${item?.id || 'unknown'}`} 
                    horizontal 
                    showsHorizontalScrollIndicator={false}
                    contentContainerStyle={{ paddingHorizontal: 16, paddingVertical: 5 }}
                />
            ) : <Text style={{fontSize: 16, color: currentColors.textSecondary, textAlign: 'center', marginTop: 50, paddingHorizontal: 16}}>ì°¸ì—¬í•œ ì¼ë°˜íŒŒí‹°ê°€ ì—†ìŠµë‹ˆë‹¤.</Text>}
            
            <Text style={{fontSize: 20, fontWeight: 'bold', marginBottom: 12, color: currentColors.primary, paddingHorizontal: 16, marginTop: 16}}>ì „ì²´ íŒŒí‹°</Text>
            {safeAllParties.length > 0 ? (
                <FlatList 
                    data={safeAllParties.filter(item => item && typeof item === 'object')} 
                    renderItem={renderPartyItem} 
                    keyExtractor={item => `all-${item?.id || 'unknown'}`} 
                    scrollEnabled={false} 
                />
            ) : <Text style={{fontSize: 16, color: currentColors.textSecondary, textAlign: 'center', marginTop: 50, paddingHorizontal: 16}}>ë“±ë¡ëœ íŒŒí‹°ê°€ ì—†ìŠµë‹ˆë‹¤.</Text>}
        </ScrollView>
    );
}
function DangolPotContainerScreen({ navigation }) {
    const [myPots, setMyPots] = useState([]);
    const [allPots, setAllPots] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    
    // MissionContext ì‚¬ìš©
    const { handleActionCompletion } = useMission();

    useFocusEffect(useCallback(() => {
        setIsLoading(true);
        Promise.all([
            fetch(`${RENDER_SERVER_URL}/my_dangolpots/${global.myEmployeeId || '1'}`).then(res => res.json()),
            fetch(`${RENDER_SERVER_URL}/dangolpots`).then(res => res.json())
        ]).then(([myPotsData, allPotsData]) => {
            if(Array.isArray(myPotsData)) setMyPots(myPotsData);
            if(Array.isArray(allPotsData)) setAllPots(allPotsData);
        }).catch(console.error).finally(() => setIsLoading(false));
    }, []));

    const renderPotItem = ({ item }) => (
        <TouchableOpacity style={{
            backgroundColor: currentColors.surface,
            borderRadius: 20,
            marginHorizontal: 16,
            marginBottom: 16,
            padding: 20,
            elevation: 3,
            shadowColor: currentColors.primary,
            shadowOffset: { width: 0, height: 4 },
            shadowOpacity: 0.1,
            shadowRadius: 8,
            borderWidth: 1,
            borderColor: 'rgba(59, 130, 246, 0.1)'
        }} onPress={() => navigation.navigate('DangolPotDetail', { potId: item.id })}>
            <View style={{flexDirection: 'row', justifyContent: 'space-between', marginBottom: 8}}>
                <Text style={{fontSize: 18, fontWeight: 'bold', color: currentColors.text}}>{item.name}</Text>
                <View style={{
                    backgroundColor: currentColors.primaryLight,
                    borderRadius: 20,
                    paddingVertical: 6,
                    paddingHorizontal: 12,
                    alignSelf: 'flex-start'
                }}>
                    <Text style={{color: currentColors.primary, fontWeight: 'bold', fontSize: 12}}>{item.category}</Text>
                </View>
            </View>
            <Text style={{fontSize: 14, color: currentColors.textSecondary, marginBottom: 4, numberOfLines: 1}}>{item.description}</Text>
            <Text style={{fontSize: 14, color: currentColors.textSecondary, marginBottom: 8}}>{item.tags}</Text>
            <View style={{flexDirection: 'row', justifyContent: 'space-between', marginTop: 10, alignItems: 'center'}}>
                <Text style={{fontSize: 14, color: currentColors.textSecondary}}>ğŸ‘¥ {item.member_count}ëª…</Text>
                <Text style={{fontSize: 14, color: currentColors.textSecondary}}>ê°œì„¤ì¼: {item.created_at}</Text>
            </View>
        </TouchableOpacity>
    );

    const renderMyPotItem = ({ item }) => (
        <TouchableOpacity style={{
            backgroundColor: currentColors.surface,
            borderRadius: 20,
            padding: 20,
            marginHorizontal: 6,
            width: SCREEN_WIDTH * 0.5,
            height: 160,
            borderWidth: 1,
            borderColor: 'rgba(59, 130, 246, 0.1)',
            justifyContent: 'flex-start',
            elevation: 3,
            shadowColor: currentColors.primary,
            shadowOffset: { width: 0, height: 4 },
            shadowOpacity: 0.1,
            shadowRadius: 8
        }} onPress={() => navigation.navigate('DangolPotDetail', { potId: item.id })}>
            <Text style={{fontSize: 16, fontWeight: 'bold', color: currentColors.text, marginBottom: 6, numberOfLines: 1}}>{item.name}</Text>
            <View style={{marginBottom: 6}}>
                <View style={{
                    backgroundColor: currentColors.primaryLight,
                    borderRadius: 20,
                    paddingVertical: 6,
                    paddingHorizontal: 12,
                    alignSelf: 'flex-start'
                }}>
                    <Text style={{color: currentColors.primary, fontWeight: 'bold', fontSize: 12}}>{item.category}</Text>
                </View>
            </View>
            <Text style={{fontSize: 13, color: currentColors.textSecondary, marginBottom: 6, numberOfLines: 2}}>{item.description}</Text>
            <View style={{flexDirection: 'row', justifyContent: 'space-between', marginTop: 6, alignItems: 'center'}}>
                <Text style={{fontSize: 12, color: currentColors.textSecondary}}>ğŸ‘¥ {item.member_count}ëª…</Text>
                <Text style={{fontSize: 12, color: currentColors.textSecondary}}>{item.created_at}</Text>
            </View>
        </TouchableOpacity>
    );

    if (isLoading) return <ActivityIndicator style={{flex: 1}} size="large" color={currentColors.primary} />;

    return (
        <ScrollView style={styles.safeArea}>
            <Text style={{fontSize: 20, fontWeight: 'bold', marginBottom: 12, color: currentColors.primary, paddingHorizontal: 16, marginTop: 16}}>ë‚´ ë‹¨ê³¨íŒŒí‹°</Text>
            {myPots.length > 0 ? (
                <FlatList 
                    data={myPots} 
                    renderItem={renderMyPotItem} 
                    keyExtractor={item => `my-${item.id}`} 
                    horizontal 
                    showsHorizontalScrollIndicator={false}
                    contentContainerStyle={{ paddingHorizontal: 16, paddingVertical: 5 }}
                />
            ) : <Text style={{fontSize: 16, color: currentColors.textSecondary, textAlign: 'center', marginTop: 50, paddingHorizontal: 16}}>ê°€ì…í•œ ë‹¨ê³¨íŒŒí‹°ê°€ ì—†ìŠµë‹ˆë‹¤.</Text>}
            
            <Text style={{fontSize: 20, fontWeight: 'bold', marginBottom: 12, color: currentColors.primary, paddingHorizontal: 16, marginTop: 16}}>ì „ì²´ ë‹¨ê³¨íŒŒí‹°</Text>
            <FlatList data={allPots} renderItem={renderPotItem} keyExtractor={item => `all-${item.id}`} scrollEnabled={false} />
        </ScrollView>
    );
}

function PartiesContainerScreen({ navigation, route }) {
    const { user } = useAuth();
    const [tabIndex, setTabIndex] = useState(0);
    const currentTabIndexRef = useRef(0);
    const isProcessingSwitchToTab = useRef(false);
    
    // useNavigationState ì œê±°í•˜ê³  useStateë§Œ ì‚¬ìš©
    // const currentTabIndex = useNavigationState(state => { ... });
    
    // currentTabIndexRef ì—…ë°ì´íŠ¸
    useEffect(() => {
        currentTabIndexRef.current = tabIndex;
    }, [tabIndex]);
    
    // route.paramsì—ì„œ switchToTab í™•ì¸í•˜ì—¬ íŠ¹ì • íƒ­ìœ¼ë¡œ ì´ë™
    useEffect(() => {
                    // console.log('ğŸ” PartiesContainerScreen - route.params ë³€ê²½ ê°ì§€:', route.params);
        if (route.params?.switchToTab !== undefined) {
            const targetTabIndex = route.params.switchToTab;
            // console.log('ğŸ” PartiesContainerScreen - switchToTab íŒŒë¼ë¯¸í„° ë°›ìŒ:', targetTabIndex);
            
            // switchToTab ì²˜ë¦¬ ì¤‘ì„ì„ í‘œì‹œ
            isProcessingSwitchToTab.current = true;
            // console.log('ğŸ” PartiesContainerScreen - isProcessingSwitchToTab = true');
            
            setTabIndex(targetTabIndex);
            currentTabIndexRef.current = targetTabIndex;
            // console.log('ğŸ” PartiesContainerScreen - tabIndex ìƒíƒœ ì—…ë°ì´íŠ¸ë¨:', targetTabIndex);
            
            // íŒŒë¼ë¯¸í„° ì´ˆê¸°í™”
            navigation.setParams({ switchToTab: undefined });
            
            // 500ms í›„ì— ì²˜ë¦¬ ì™„ë£Œ í‘œì‹œ
            setTimeout(() => {
                isProcessingSwitchToTab.current = false;
                // console.log('ğŸ” PartiesContainerScreen - isProcessingSwitchToTab = false');
            }, 500);
        }
    }, [route.params?.switchToTab, navigation]);
    
    // tabIndexê°€ ë³€ê²½ë  ë•Œ TopTab.Navigatorê°€ ìë™ìœ¼ë¡œ í•´ë‹¹ íƒ­ìœ¼ë¡œ ì´ë™
    // key={tabIndex}ë¥¼ ì‚¬ìš©í•˜ì—¬ Navigatorë¥¼ ë‹¤ì‹œ ë Œë”ë§í•˜ë¯€ë¡œ ë³„ë„ ë¡œì§ ë¶ˆí•„ìš”
    useEffect(() => {
                    // console.log('ğŸ” PartiesContainerScreen - tabIndex ë³€ê²½ ê°ì§€:', tabIndex);
            // console.log('ğŸ” PartiesContainerScreen - currentTabIndexRef.current:', currentTabIndexRef.current);
    }, [tabIndex]);
    
    // ğŸš¨ ì¤‘ìš”: ìƒˆ íŒŒí‹° ìƒì„± ê°ì§€í•˜ì—¬ íŒŒí‹° íƒ­ ìƒˆë¡œê³ ì¹¨
    useEffect(() => {
        if (global.refreshPartyTab && global.newPartyData) {
            // console.log('ğŸ” [íŒŒí‹°íƒ­] ìƒˆ íŒŒí‹° ìƒì„± ê°ì§€, íƒ­ ìƒˆë¡œê³ ì¹¨ ì‹œì‘');
            
            // ğŸš¨ ì¤‘ìš”: ì „ì—­ ë³€ìˆ˜ëŠ” ìœ ì§€ (PartyListScreenì—ì„œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡)
            global.refreshPartyTab = false;
            // global.newPartyDataëŠ” PartyListScreenì—ì„œ ì²˜ë¦¬ í›„ ì´ˆê¸°í™”
            
            // ì¼ë°˜íŒŒí‹° íƒ­ìœ¼ë¡œ ì´ë™í•˜ì—¬ ìƒˆë¡œê³ ì¹¨
            setTabIndex(1);
            currentTabIndexRef.current = 1;
            
            // console.log('ğŸ” [íŒŒí‹°íƒ­] ì¼ë°˜íŒŒí‹° íƒ­ìœ¼ë¡œ ì´ë™ ì™„ë£Œ');
        }
    }, []);
    
    const handleAddPress = () => {
        const currentIndex = currentTabIndexRef.current;
        
        if (currentIndex === 0) {
            // ëœë¤ëŸ°ì¹˜ íƒ­ì—ì„œëŠ” ì œì•ˆ ê¸°ë°˜ ì‹œìŠ¤í…œìœ¼ë¡œ ì´ë™
            navigation.navigate('RandomLunch');
        } else if (currentIndex === 1) {
            // ì¼ë°˜íŒŒí‹° íƒ­ì—ì„œëŠ” ìƒˆ íŒŒí‹° ë§Œë“¤ê¸° í™”ë©´ìœ¼ë¡œ ì´ë™
            navigation.navigate('CreateParty');
        } else if (currentIndex === 2) {
            // ë‹¨ê³¨íŒŒí‹° íƒ­ì—ì„œëŠ” ìƒˆ ë‹¨ê³¨íŒŒí‹° ë§Œë“¤ê¸° í™”ë©´ìœ¼ë¡œ ì´ë™
            navigation.navigate('CreateDangolPot');
        }
    };
    
    return (
        <SafeAreaView style={{flex: 1, backgroundColor: currentColors.background}}>
            <TopTab.Navigator
                key={tabIndex} // tabIndexê°€ ë³€ê²½ë  ë•Œë§ˆë‹¤ Navigatorë¥¼ ë‹¤ì‹œ ë Œë”ë§
                initialRouteName={tabIndex === 0 ? "ëœë¤ëŸ°ì¹˜" : tabIndex === 1 ? "ì¼ë°˜íŒŒí‹°" : "ë‹¨ê³¨íŒŒí‹°"}
                // ë””ë²„ê¹…ì„ ìœ„í•œ ë¡œê·¸ ì¶”ê°€
                onStateChange={(state) => {
                    // console.log('ğŸ” TopTab.Navigator - ìƒíƒœ ë³€ê²½:', state);
                }}
                screenOptions={{
                    tabBarActiveTintColor: currentColors.primary,
                    tabBarInactiveTintColor: currentColors.gray,
                    tabBarIndicatorStyle: { backgroundColor: currentColors.primary },
                    tabBarLabelStyle: { fontWeight: '600', fontSize: 16, marginTop: 2 },
                    tabBarIconStyle: { marginBottom: 4 }
                }}
                screenListeners={{
                    tabPress: (e) => {
                        const routeName = e.target.split('-')[0];
                        // console.log('ğŸ” TopTab.Navigator - íƒ­ í´ë¦­ ê°ì§€:', routeName);
                        
                        // switchToTab ì²˜ë¦¬ ì¤‘ì¸ ê²½ìš° tabPress ì´ë²¤íŠ¸ë¥¼ ë¬´ì‹œ
                        if (isProcessingSwitchToTab.current) {
                            // console.log('ğŸ” TopTab.Navigator - switchToTab ì²˜ë¦¬ ì¤‘ì´ì–´ì„œ tabPress ì´ë²¤íŠ¸ ë¬´ì‹œ');
                            return;
                        }
                        
                        if (routeName === 'ëœë¤ëŸ°ì¹˜') {
                            setTabIndex(0);
                            currentTabIndexRef.current = 0;
                        } else if (routeName === 'ì¼ë°˜íŒŒí‹°') {
                            setTabIndex(1);
                            currentTabIndexRef.current = 1;
                        } else if (routeName === 'ë‹¨ê³¨íŒŒí‹°') {
                            setTabIndex(2);
                            currentTabIndexRef.current = 2;
                        }
                    },
                    focus: (e) => {
                        const routeName = e.target.split('-')[0];
                        // íƒ­ í¬ì»¤ìŠ¤ ê°ì§€ (ë¡œê·¸ ê°„ì†Œí™”)
                        
                        // switchToTab ì²˜ë¦¬ ì¤‘ì¸ ê²½ìš° focus ì´ë²¤íŠ¸ë¥¼ ë¬´ì‹œ
                        if (isProcessingSwitchToTab.current) {
                            return;
                        }
                        
                        if (routeName === 'ëœë¤ëŸ°ì¹˜') {
                            setTabIndex(0);
                            currentTabIndexRef.current = 0;
                        } else if (routeName === 'ì¼ë°˜íŒŒí‹°') {
                            setTabIndex(1);
                            currentTabIndexRef.current = 1;
                        } else if (routeName === 'ë‹¨ê³¨íŒŒí‹°') {
                            setTabIndex(2);
                            currentTabIndexRef.current = 2;
                        }
                    }
                }}
            >
                <TopTab.Screen name="ëœë¤ëŸ°ì¹˜" component={MyProposalsScreen} />
                <TopTab.Screen name="ì¼ë°˜íŒŒí‹°" component={PartyListScreen} />
                <TopTab.Screen name="ë‹¨ê³¨íŒŒí‹°" component={DangolPotContainerScreen} />
            </TopTab.Navigator>
            <TouchableOpacity
                style={{
                    position: 'absolute',
                    right: 24,
                    bottom: 32,
                    width: 56,
                    height: 56,
                    borderRadius: 28,
                    backgroundColor: currentColors.primary,
                    justifyContent: 'center',
                    alignItems: 'center',
                    zIndex: 10,
                    elevation: 8,
                    shadowColor: currentColors.primary,
                    shadowOffset: { width: 0, height: 4 },
                    shadowOpacity: 0.3,
                    shadowRadius: 8
                }}
                activeOpacity={0.85}
                onPress={handleAddPress}
            >
                <Ionicons name="add" size={32} color="#fff" />
            </TouchableOpacity>
        </SafeAreaView>
    );
}



// PartyDetailScreen ê´€ë ¨ í•¨ìˆ˜ë“¤ì€ ë³„ë„ íŒŒì¼ë¡œ ì´ë™ë¨



function DangolPotDetailScreen({ route, navigation }) {
    const { user } = useAuth();
    const { potId } = route.params;
    const [pot, setPot] = useState(null);
    const [isMember, setIsMember] = useState(false);
    
    // MissionContext ì‚¬ìš©
    const { handleActionCompletion } = useMission();

    const fetchDetails = useCallback(() => {
        fetch(`${RENDER_SERVER_URL}/dangolpots/${potId}`).then(res => res.json()).then(data => {
            setPot(data);
            setIsMember(data.members.some(m => m.employee_id === global.myEmployeeId || '1'));
        }).catch(console.error);
    }, [potId]);

    useFocusEffect(useCallback(() => {
        fetchDetails();
    }, [fetchDetails]));

    const handleJoin = async () => {
        const response = await fetch(`${RENDER_SERVER_URL}/dangolpots/${pot.id}/join`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ employee_id: global.myEmployeeId || '1' }) });
        if (response.ok) { 
            Alert.alert("ì„±ê³µ", "ë‹¨ê³¨íŒŒí‹°ì— ê°€ì…í–ˆìŠµë‹ˆë‹¤!");
            
            // ë¯¸ì…˜ ë‹¬ì„± ì²´í¬: ë‹¨ê³¨íŒŒí‹° ì°¸ì—¬
            handleActionCompletion('dangol_party_join');
                            // console.log('ğŸ” DangolPotDetailScreen - ë‹¨ê³¨íŒŒí‹° ì°¸ì—¬ ë¯¸ì…˜ ë‹¬ì„±');
            
            fetchDetails(); 
        } else { 
            Alert.alert("ì˜¤ë¥˜", "ê°€ì…ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."); 
        }
    };

    const handleDeletePot = async () => {
        Alert.alert(
            'ë‹¨ê³¨íŒŒí‹° ì‚­ì œ',
            'ì •ë§ë¡œ ì´ ë‹¨ê³¨íŒŒí‹°ë¥¼ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?',
            [
                { text: 'ì·¨ì†Œ', style: 'cancel' },
                { text: 'ì‚­ì œ', style: 'destructive', onPress: async () => {
                    try {
                        const response = await fetch(`${RENDER_SERVER_URL}/dangolpots/${pot.id}?employee_id=${global.myEmployeeId || '1'}`, { method: 'DELETE' });
                        const data = await response.json();
                        if (response.ok) {
                            Alert.alert('ì„±ê³µ', 'ë‹¨ê³¨íŒŒí‹°ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.');
                            navigation.goBack();
                        } else {
                            Alert.alert('ì˜¤ë¥˜', data.message || 'ë‹¨ê³¨íŒŒí‹° ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                        }
                    } catch (e) {
                        Alert.alert('ì˜¤ë¥˜', 'ë‹¨ê³¨íŒŒí‹° ì‚­ì œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                    }
                }}
            ]
        );
    };
    
    if (!pot) return <View style={styles.centerView}><ActivityIndicator size="large" color={currentColors.primary} /></View>;

    const isHost = pot.host_id === (global.myEmployeeId || '1');

    const renderActionButtons = () => {
        if (isMember) {
            return (
                <View>
                    <TouchableOpacity style={styles.submitButton} onPress={() => safeNavigateToTab(navigation, 'ì†Œí†µ', 'ChatRoom', { chatId: pot.id, chatType: 'dangolpot', chatTitle: pot.name })}>
                        <Text style={styles.textStyle}>ì±„íŒ…ë°©ìœ¼ë¡œ ì´ë™</Text>
                    </TouchableOpacity>
                    {isHost && (
                        <>
                            <TouchableOpacity style={[styles.submitButton, {marginTop: 10, backgroundColor: currentColors.gray}]} onPress={() => navigation.navigate('EditDangolPot', { potData: pot })}>
                                <Text style={[styles.submitButtonText, {color: currentColors.white}]}>ë‹¨ê³¨íŒŒí‹° ì •ë³´ ìˆ˜ì •</Text>
                            </TouchableOpacity>
                            <TouchableOpacity style={[styles.submitButton, {marginTop: 10, backgroundColor: currentColors.red}]} onPress={handleDeletePot}>
                                <Text style={[styles.submitButtonText, {color: currentColors.white}]}>ë‹¨ê³¨íŒŒí‹° ì‚­ì œ</Text>
                            </TouchableOpacity>
                        </>
                    )}
                </View>
            );
        }
        return (
            <TouchableOpacity style={styles.submitButton} onPress={handleJoin}>
                <Text style={styles.submitButtonText}>ê°€ì…í•˜ê¸°</Text>
            </TouchableOpacity>
        );
    };

    return (
        <SafeAreaView style={styles.safeArea}>
            <ScrollView contentContainerStyle={styles.detailContainer}>
                {/* ë‹¨ê³¨íŒŒí‹° ì œëª© ì¹´ë“œ */}
                <View style={styles.partyDetailCard}>
                    <View style={styles.titleRow}>
                        <Text style={styles.title}>{pot.name}</Text>
                        <View style={styles.categoryChip}>
                            <Text style={styles.categoryChipText}>{pot.category}</Text>
                        </View>
                    </View>
                </View>

                {/* ë‹¨ê³¨íŒŒí‹° ì •ë³´ ì¹´ë“œ */}
                <View style={styles.partyDetailCard}>
                    <Text style={styles.cardTitle}>ğŸ“‹ ë‹¨ê³¨íŒŒí‹° ì •ë³´</Text>
                    <Text style={styles.descriptionText}>{pot.description}</Text>
                    <View style={styles.tagsContainer}>
                        <Text style={styles.tagsText}>#ï¸âƒ£ {pot.tags}</Text>
                    </View>
                </View>

                {/* ë©¤ë²„ ëª©ë¡ ì¹´ë“œ */}
                <View style={styles.partyDetailCard}>
                    <Text style={styles.cardTitle}>ğŸ‘¥ ë©¤ë²„ ëª©ë¡ ({pot.members.length}ëª…)</Text>
                    
                    {/* íŒŸì¥(í˜¸ìŠ¤íŠ¸) í‘œì‹œ */}
                    {(() => {
                        const leader = pot.members.find(m => m.is_host);
                        if (!leader) return null;
                        return (
                            <TouchableOpacity 
                                style={styles.memberCard}
                                onPress={() => safeNavigateToTab(navigation, 'ì¹œêµ¬', 'UserProfile', { employeeId: leader.employee_id })}
                            >
                                <View style={styles.memberContent}>
                                    {/* ì•„ë°”íƒ€ */}
                                    <View style={[styles.memberAvatar, { backgroundColor: COLORS.yellow }]}>
                                        <Text style={[styles.avatarText, { color: COLORS.deepBlue }]}>
                                            {leader.nickname ? leader.nickname.charAt(0) : '?'}
                                        </Text>
                                    </View>
                                    
                                    {/* ë©¤ë²„ ì •ë³´ */}
                                    <View style={styles.memberInfo}>
                                        <View style={styles.memberHeader}>
                                            <Text style={styles.memberName}>
                                                {leader.nickname || 'ì•Œ ìˆ˜ ì—†ìŒ'} ğŸ‘‘
                                            </Text>
                                            <View style={styles.hostBadge}>
                                                <Text style={styles.hostBadgeText}>íŒŸì¥</Text>
                                            </View>
                                        </View>
                                    </View>
                                </View>
                            </TouchableOpacity>
                        );
                    })()}

                    {/* ì¼ë°˜ ë©¤ë²„ë“¤ í‘œì‹œ */}
                    {pot.members.filter(m => {
                        const leader = pot.members.find(x => x.is_host);
                        return !leader || m.employee_id !== leader.employee_id;
                    }).map((item, index) => (
                        <TouchableOpacity 
                            key={`member-${item.employee_id}-${index}`} 
                            style={styles.memberCard}
                            onPress={() => safeNavigateToTab(navigation, 'ì¹œêµ¬', 'UserProfile', { employeeId: item.employee_id })}
                        >
                            <View style={styles.memberContent}>
                                {/* ì•„ë°”íƒ€ */}
                                <View style={styles.memberAvatar}>
                                    <Text style={styles.avatarText}>
                                        {item.nickname ? item.nickname.charAt(0) : '?'}
                                    </Text>
                                </View>
                                
                                {/* ë©¤ë²„ ì •ë³´ */}
                                <View style={styles.memberInfo}>
                                    <View style={styles.memberHeader}>
                                        <Text style={styles.memberName}>
                                            {item.nickname || 'ì•Œ ìˆ˜ ì—†ìŒ'}
                                        </Text>
                                    </View>
                                </View>
                            </View>
                        </TouchableOpacity>
                    ))}
                </View>

                {/* ì•¡ì…˜ ë²„íŠ¼ë“¤ */}
                <View style={styles.actionContainer}>
                    {renderActionButtons()}
                </View>
            </ScrollView>
        </SafeAreaView>
    );
}

// CreatePartyScreenì€ ë³„ë„ íŒŒì¼ë¡œ ì´ë™ë¨


function CreateDangolPotScreen({ navigation }) {
    const { user } = useAuth();
    const [name, setName] = useState('');
    const [description, setDescription] = useState('');
    const [tags, setTags] = useState('');
    const [category, setCategory] = useState('');
    const [isCategoryModalVisible, setCategoryModalVisible] = useState(false);
    const CATEGORY_OPTIONS = ['í•œì‹', 'ì¤‘ì‹', 'ì¼ì‹', 'ì–‘ì‹', 'ë¶„ì‹', 'ì¹´í˜', 'ì•„ì‹œì•ˆ', 'í“¨ì „', 'ê¸°íƒ€'];
    
    // MissionContext ì‚¬ìš©
    const { handleActionCompletion } = useMission();

    const handleSubmit = async () => {
        if (!name || !category) { Alert.alert("ì…ë ¥ ì˜¤ë¥˜", "ë‹¨ê³¨íŒŒí‹° ì´ë¦„ê³¼ ì¹´í…Œê³ ë¦¬ëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤."); return; }
        const response = await fetch(`${RENDER_SERVER_URL}/dangolpots`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name, description, tags, category, host_id: global.myEmployeeId || '1' }) });
        if (response.ok) { 
            Alert.alert("ì„±ê³µ", "ë‹¨ê³¨íŒŒí‹°ê°€ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤!");
            
            // ë¯¸ì…˜ ë‹¬ì„± ì²´í¬: ë‹¨ê³¨íŒŒí‹° ì°¸ì—¬
            handleActionCompletion('dangol_party_join');
                            // console.log('ğŸ” CreateDangolPotScreen - ë‹¨ê³¨íŒŒí‹° ì°¸ì—¬ ë¯¸ì…˜ ë‹¬ì„±');
            
            navigation.goBack(); 
        } else { 
            Alert.alert("ì˜¤ë¥˜", "ë‹¨ê³¨íŒŒí‹° ìƒì„±ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."); 
        }
    };
    return (
        <SafeAreaView style={styles.safeArea}>
            <ScrollView contentContainerStyle={styles.formContainer}>
                <Text style={styles.inputLabel}>ë‹¨ê³¨íŒŒí‹° ì´ë¦„</Text>
                <TextInput 
                    style={styles.input} 
                    value={name} 
                    onChangeText={setName}
                    returnKeyType="done"
                    onSubmitEditing={() => {
                        Keyboard.dismiss();
                    }}
                    blurOnSubmit={true}
                />
                <Text style={styles.inputLabel}>ìŒì‹ ì¹´í…Œê³ ë¦¬</Text>
                <TouchableOpacity style={styles.input} onPress={() => setCategoryModalVisible(true)}><Text style={category ? styles.inputText : styles.placeholderText}>{category || "ì¹´í…Œê³ ë¦¬ ì„ íƒ"}</Text></TouchableOpacity>
                <Text style={styles.inputLabel}>ì†Œê°œ</Text>
                <TextInput 
                    style={[styles.input, {height: 100, textAlignVertical: 'top'}]} 
                    placeholder="ì–´ë–¤ ëª¨ì„ì¸ì§€ ì†Œê°œí•´ì£¼ì„¸ìš”" 
                    value={description} 
                    onChangeText={setDescription} 
                    multiline
                    returnKeyType="done"
                    onSubmitEditing={() => {
                        Keyboard.dismiss();
                    }}
                    blurOnSubmit={true}
                />
                <Text style={styles.inputLabel}>ê´€ì‹¬ì‚¬ íƒœê·¸</Text>
                <TextInput 
                    style={styles.input} 
                    placeholder="ì˜ˆ: #ë§¤ìš´ë§› #ë§›ì§‘íƒë°©" 
                    value={tags} 
                    onChangeText={setTags}
                    returnKeyType="done"
                    onSubmitEditing={() => {
                        Keyboard.dismiss();
                    }}
                    blurOnSubmit={true}
                />
                <TouchableOpacity style={styles.submitButton} onPress={handleSubmit}><Text style={[styles.submitButtonText, {color: currentColors.white}]}>ë§Œë“¤ê¸°</Text></TouchableOpacity>
                <SelectionModal visible={isCategoryModalVisible} title="ì¹´í…Œê³ ë¦¬ ì„ íƒ" options={CATEGORY_OPTIONS} selected={category} onSelect={setCategory} onClose={() => setCategoryModalVisible(false)} styles={styles} colors={currentColors} />
            </ScrollView>
        </SafeAreaView>
    );
}

function EditDangolPotScreen({ route, navigation }) {
    const { potData } = route.params;
    const [name, setName] = useState(potData.name);
    const [description, setDescription] = useState(potData.description);
    const [tags, setTags] = useState(potData.tags);
    const [category, setCategory] = useState(potData.category);
    const [isCategoryModalVisible, setCategoryModalVisible] = useState(false);
    const CATEGORY_OPTIONS = ['í•œì‹', 'ì¤‘ì‹', 'ì¼ì‹', 'ì–‘ì‹', 'ë¶„ì‹', 'ì¹´í˜', 'ì•„ì‹œì•ˆ', 'í“¨ì „', 'ê¸°íƒ€'];

    const handleUpdate = async () => {
        if (!name || !category) { Alert.alert("ì…ë ¥ ì˜¤ë¥˜", "ë‹¨ê³¨íŒŒí‹° ì´ë¦„ê³¼ ì¹´í…Œê³ ë¦¬ëŠ” í•„ìˆ˜ì…ë‹ˆë‹¤."); return; }
        const response = await fetch(`${RENDER_SERVER_URL}/dangolpots/${potData.id}`, { 
            method: 'PUT', 
            headers: { 'Content-Type': 'application/json' }, 
            body: JSON.stringify({ name, description, tags, category, employee_id: global.myEmployeeId || '1' }) 
        });
        if (response.ok) { Alert.alert("ì„±ê³µ", "ë‹¨ê³¨íŒŒí‹° ì •ë³´ê°€ ìˆ˜ì •ë˜ì—ˆìŠµë‹ˆë‹¤!"); navigation.goBack(); } 
        else { Alert.alert("ì˜¤ë¥˜", "ë‹¨ê³¨íŒŒí‹° ìˆ˜ì •ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤."); }
    };

    return (
        <SafeAreaView style={styles.safeArea}>
            <ScrollView contentContainerStyle={styles.formContainer}>
                    <Text style={styles.inputLabel}>ë‹¨ê³¨íŒŒí‹° ì´ë¦„</Text>
                    <TextInput 
                        style={styles.input} 
                        value={name} 
                        onChangeText={setName}
                        returnKeyType="done"
                        onSubmitEditing={() => {
                            Keyboard.dismiss();
                        }}
                        blurOnSubmit={true}
                    />
                <Text style={styles.inputLabel}>ìŒì‹ ì¹´í…Œê³ ë¦¬</Text>
                <TouchableOpacity style={styles.input} onPress={() => setCategoryModalVisible(true)}><Text style={category ? styles.inputText : styles.placeholderText}>{category || "ì¹´í…Œê³ ë¦¬ ì„ íƒ"}</Text></TouchableOpacity>
                    <Text style={styles.inputLabel}>ì†Œê°œ</Text>
                    <TextInput 
                        style={[styles.input, {height: 100, textAlignVertical: 'top'}]} 
                        placeholder="ì–´ë–¤ ëª¨ì„ì¸ì§€ ì†Œê°œí•´ì£¼ì„¸ìš”" 
                        value={description} 
                        onChangeText={setDescription} 
                        multiline
                        returnKeyType="done"
                        onSubmitEditing={() => {
                            Keyboard.dismiss();
                        }}
                        blurOnSubmit={true}
                    />
                    <Text style={styles.inputLabel}>ê´€ì‹¬ì‚¬ íƒœê·¸</Text>
                    <TextInput 
                        style={styles.input} 
                        placeholder="ì˜ˆ: #ë§¤ìš´ë§› #ë§›ì§‘íƒë°©" 
                        value={tags} 
                        onChangeText={setTags}
                        returnKeyType="done"
                        onSubmitEditing={() => {
                            Keyboard.dismiss();
                        }}
                        blurOnSubmit={true}
                    />
                <TouchableOpacity style={styles.submitButton} onPress={handleUpdate}><Text style={[styles.submitButtonText, {color: currentColors.white}]}>ìˆ˜ì •í•˜ê¸°</Text></TouchableOpacity>
                <SelectionModal visible={isCategoryModalVisible} title="ì¹´í…Œê³ ë¦¬ ì„ íƒ" options={CATEGORY_OPTIONS} selected={category} onSelect={setCategory} onClose={() => setCategoryModalVisible(false)} styles={styles} colors={currentColors} />
            </ScrollView>
        </SafeAreaView>
    );
}
// --- ì†Œí†µ íƒ­ ---
function ChatListScreen({ navigation }) {
    const { user } = useAuth();
    const [chats, setChats] = useState([]);
    const [filteredChats, setFilteredChats] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [activeFilter, setActiveFilter] = useState('all');
    const [refreshing, setRefreshing] = useState(false);

    const fetchChats = async () => {
        try {
            const employeeId = user.employee_id;
            
            if (!employeeId) {
                console.log('âš ï¸ ì‚¬ìš©ì IDê°€ ì—†ì–´ì„œ ì±„íŒ… ëª©ë¡ì„ ê°€ì ¸ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤');
                return;
            }
            
            console.log('ğŸ’¬ ì±„íŒ… ëª©ë¡ ì¡°íšŒ ì‹œì‘:', employeeId);
            const response = await fetch(`${RENDER_SERVER_URL}/chats/${employeeId}`);
            const data = await response.json();
            if(Array.isArray(data)) {
                setChats(data);
                setFilteredChats(data);
                console.log('âœ… ì±„íŒ… ëª©ë¡ ë¡œë“œ ì™„ë£Œ:', data.length + 'ê°œ');
            }
        } catch (error) {
            console.error('ì±„íŒ… ëª©ë¡ ì¡°íšŒ ì˜¤ë¥˜:', error);
        }
    };

    useFocusEffect(useCallback(() => {
        setIsLoading(true);
        fetchChats().finally(() => setIsLoading(false));
    }, []));

    const onRefresh = async () => {
        setRefreshing(true);
        await fetchChats();
        setRefreshing(false);
    };

    const handleFilterChange = (filter) => {
        setActiveFilter(filter);
        if (filter === 'all') {
            setFilteredChats(chats);
        } else if (filter === 'party') {
            setFilteredChats(chats.filter(chat => chat.type === 'party'));
        } else if (filter === 'dangolpot') {
            setFilteredChats(chats.filter(chat => chat.type === 'dangolpot'));
        } else if (filter === 'custom') {
            setFilteredChats(chats.filter(chat => chat.type === 'custom'));
        }
    };

    if (isLoading) return <ActivityIndicator style={{flex: 1}} size="large" color={currentColors.primary} />;
    
    return (
        <SafeAreaView style={styles.safeArea}>
            {/* ì±„íŒ… í•„í„° */}
            <View style={{paddingHorizontal: 16, paddingVertical: 12, backgroundColor: currentColors.background}}>
                <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                    <TouchableOpacity
                        style={{
                            backgroundColor: activeFilter === 'all' ? currentColors.primary : currentColors.surface,
                            borderRadius: 20,
                            paddingVertical: 8,
                            paddingHorizontal: 16,
                            marginRight: 8,
                            elevation: activeFilter === 'all' ? 2 : 1,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: activeFilter === 'all' ? 0.2 : 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: activeFilter === 'all' ? currentColors.primary : currentColors.lightGray
                        }}
                        onPress={() => handleFilterChange('all')}
                    >
                        <Text style={{
                            color: activeFilter === 'all' ? '#FFFFFF' : currentColors.text,
                            fontWeight: activeFilter === 'all' ? 'bold' : '600',
                            fontSize: 14
                        }}>
                            ì „ì²´
                        </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                        style={{
                            backgroundColor: activeFilter === 'party' ? currentColors.primary : currentColors.surface,
                            borderRadius: 20,
                            paddingVertical: 8,
                            paddingHorizontal: 16,
                            marginRight: 8,
                            elevation: activeFilter === 'party' ? 2 : 1,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: activeFilter === 'party' ? 0.2 : 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: activeFilter === 'party' ? currentColors.primary : currentColors.lightGray
                        }}
                        onPress={() => handleFilterChange('party')}
                    >
                        <Text style={{
                            color: activeFilter === 'party' ? '#FFFFFF' : currentColors.text,
                            fontWeight: activeFilter === 'party' ? 'bold' : '600',
                            fontSize: 14
                        }}>
                            íŒŒí‹°
                        </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                        style={{
                            backgroundColor: activeFilter === 'dangolpot' ? currentColors.primary : currentColors.surface,
                            borderRadius: 20,
                            paddingVertical: 8,
                            paddingHorizontal: 16,
                            marginRight: 8,
                            elevation: activeFilter === 'dangolpot' ? 2 : 1,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: activeFilter === 'dangolpot' ? 0.2 : 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: activeFilter === 'dangolpot' ? currentColors.primary : currentColors.lightGray
                        }}
                        onPress={() => handleFilterChange('dangolpot')}
                    >
                        <Text style={{
                            color: activeFilter === 'dangolpot' ? '#FFFFFF' : currentColors.text,
                            fontWeight: activeFilter === 'dangolpot' ? 'bold' : '600',
                            fontSize: 14
                        }}>
                            ë‹¨ê³¨íŒŒí‹°
                        </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                        style={{
                            backgroundColor: activeFilter === 'custom' ? currentColors.primary : currentColors.surface,
                            borderRadius: 20,
                            paddingVertical: 8,
                            paddingHorizontal: 16,
                            marginRight: 8,
                            elevation: activeFilter === 'custom' ? 2 : 1,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: activeFilter === 'custom' ? 0.2 : 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: activeFilter === 'custom' ? currentColors.primary : currentColors.lightGray
                        }}
                        onPress={() => handleFilterChange('custom')}
                    >
                        <Text style={{
                            color: activeFilter === 'custom' ? '#FFFFFF' : currentColors.text,
                            fontWeight: activeFilter === 'custom' ? 'bold' : '600',
                            fontSize: 14
                        }}>
                            ê°œì¸ì±„íŒ…
                        </Text>
                    </TouchableOpacity>
                </ScrollView>
            </View>

            <FlatList 
                data={filteredChats} 
                keyExtractor={item => `${item.type}-${item.id}`} 
                refreshing={refreshing}
                onRefresh={onRefresh}
                ListEmptyComponent={<Text style={{fontSize: 16, color: currentColors.textSecondary, textAlign: 'center', marginTop: 50, paddingHorizontal: 16}}>ì°¸ì—¬ ì¤‘ì¸ ì±„íŒ…ë°©ì´ ì—†ìŠµë‹ˆë‹¤.</Text>} 
                renderItem={({ item }) => (
                    <TouchableOpacity 
                        style={{
                            backgroundColor: currentColors.surface,
                            borderRadius: 16,
                            marginHorizontal: 16,
                            marginBottom: 12,
                            padding: 16,
                            flexDirection: 'row',
                            alignItems: 'center',
                            elevation: 2,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: 'rgba(99, 102, 241, 0.2)'
                        }} 
                        onPress={() => navigation.navigate('ChatRoom', { chatId: item.id, chatType: item.type, chatTitle: item.title })}
                    >
                        <View style={{
                            backgroundColor: currentColors.primary,
                            borderRadius: 12,
                            width: 48,
                            height: 48,
                            justifyContent: 'center',
                            alignItems: 'center',
                            marginRight: 12
                        }}>
                            <Ionicons 
                                name={item.type === 'dangolpot' ? 'heart-circle' : (item.is_from_match ? 'shuffle' : 'restaurant')} 
                                size={24} 
                                color="white" 
                            />
                        </View>
                        <View style={{flex: 1}}>
                            <Text style={{fontSize: 16, fontWeight: 'bold', color: currentColors.text, marginBottom: 4}}>{item.title}</Text>
                            <Text style={{fontSize: 14, color: currentColors.textSecondary}}>{item.subtitle}</Text>
                            {item.last_message && (
                                <Text style={{fontSize: 12, color: currentColors.textSecondary, marginTop: 2}} numberOfLines={1}>
                                    {item.last_message}
                                </Text>
                            )}
                        </View>
                        <Ionicons name="chevron-forward" size={24} color={currentColors.textSecondary} />
                    </TouchableOpacity>
                )} 
                contentContainerStyle={{paddingTop: 16}} 
            />
            
            {/* í”Œë¡œíŒ… ì±„íŒ…ë°© ìƒì„± ë²„íŠ¼ */}
            <TouchableOpacity
                style={{
                    position: 'absolute',
                    right: 24,
                    bottom: 32,
                    width: 56,
                    height: 56,
                    borderRadius: 28,
                    backgroundColor: currentColors.primary,
                    justifyContent: 'center',
                    alignItems: 'center',
                    zIndex: 10,
                    elevation: 8,
                    shadowColor: currentColors.primary,
                    shadowOffset: { width: 0, height: 4 },
                    shadowOpacity: 0.3,
                    shadowRadius: 8
                }}
                activeOpacity={0.85}
                onPress={() => navigation.navigate('CreateChatRoom')}
            >
                <Ionicons name="chatbubbles" size={28} color="#fff" />
            </TouchableOpacity>
        </SafeAreaView>
    );
}
function ChatRoomScreen({ route, navigation }) {
    const { chatId, chatType, chatTitle: initialChatTitle } = route.params;
    const { handleActionCompletion } = useMission();
    const [chatDetails, setChatDetails] = useState(null);
    const [messages, setMessages] = useState([]);
    const [newMessage, setNewMessage] = useState('');
    const [socket, setSocket] = useState(null);
    const [isConnected, setIsConnected] = useState(false);
    const [isSearchVisible, setIsSearchVisible] = useState(false);
    const [searchQuery, setSearchQuery] = useState('');
    const [searchResults, setSearchResults] = useState([]);
    const [isSearching, setIsSearching] = useState(false);
    const [isImagePickerVisible, setIsImagePickerVisible] = useState(false);
    const [chatMembers, setChatMembers] = useState([]);
    const [isTitleEditVisible, setIsTitleEditVisible] = useState(false);
    const [isMembersVisible, setIsMembersVisible] = useState(false);
    const [newTitle, setNewTitle] = useState('');
    const [chatTitle, setChatTitle] = useState(initialChatTitle);
    const flatListRef = useRef(null);
    const [isMenuVisible, setIsMenuVisible] = useState(false);
    useEffect(() => {
        navigation.setOptions({
          headerRight: () => (
            <View style={{ flexDirection: 'row', marginRight: 10 }}>
              <TouchableOpacity onPress={() => setIsSearchVisible(!isSearchVisible)} style={{ marginRight: 16 }}>
                <Ionicons name="search" size={24} color={currentColors.text} />
              </TouchableOpacity>
              <TouchableOpacity onPress={() => setIsMenuVisible(true)}>
                <Ionicons name="menu" size={28} color={currentColors.text} />
              </TouchableOpacity>
            </View>
          ),
        });
      }, [navigation, setIsSearchVisible, setIsMenuVisible, currentColors.text]);

    // WebSocket ì—°ê²° ë° ì‹¤ì‹œê°„ ì½ìŒ ì²˜ë¦¬ (ì„ì‹œë¡œ ë¹„í™œì„±í™”)
    useEffect(() => {
        // WebSocket ì—°ê²°ì´ ì„¤ì •ë˜ì§€ ì•Šì€ ê²½ìš°ë¥¼ ëŒ€ë¹„í•´ ì„ì‹œë¡œ ì—°ê²°ëœ ê²ƒìœ¼ë¡œ ì²˜ë¦¬
        setIsConnected(true);
        
        // ì‹¤ì œ WebSocket ì—°ê²°ì€ ë°±ì—”ë“œ êµ¬í˜„ í›„ í™œì„±í™”
        /*
        // WebSocket URL ìƒì„±
        let wsUrl = RENDER_SERVER_URL;
        if (wsUrl.startsWith('https://')) {
            wsUrl = wsUrl.replace('https://', 'wss://');
        } else if (wsUrl.startsWith('http://')) {
            wsUrl = wsUrl.replace('http://', 'ws://');
        }
        
        console.log('Attempting to connect to WebSocket:', wsUrl);
        
        const newSocket = io(wsUrl, {
            transports: ['polling', 'websocket'],
            timeout: 30000,
            forceNew: true,
            reconnection: true,
            reconnectionAttempts: 5,
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000
        });
        
        newSocket.on('connect', () => {
            console.log('Connected to WebSocket');
            setIsConnected(true);
            
            // ì±„íŒ…ë°©ì— ì°¸ì—¬
            newSocket.emit('join_chat', {
                chat_type: chatType,
                chat_id: chatId
            });
        });

        newSocket.on('disconnect', (reason) => {
            console.log('Disconnected from WebSocket:', reason);
            setIsConnected(false);
        });

        newSocket.on('connect_error', (error) => {
            console.log('WebSocket connection error:', error);
            setIsConnected(false);
        });

        newSocket.on('reconnect', (attemptNumber) => {
            console.log('Reconnected to WebSocket after', attemptNumber, 'attempts');
            setIsConnected(true);
            
            // ì¬ì—°ê²° ì‹œ ì±„íŒ…ë°©ì— ë‹¤ì‹œ ì°¸ì—¬
            newSocket.emit('join_chat', {
                chat_type: chatType,
                chat_id: chatId
            });
        });

        newSocket.on('reconnect_error', (error) => {
            console.log('WebSocket reconnection error:', error);
            setIsConnected(false);
        });

        newSocket.on('new_message', (message) => {
            console.log('New message received:', message);
            setMessages(prev => [...prev, message]);
        });

        // ì‹¤ì‹œê°„ ì½ìŒ ì²˜ë¦¬ ì´ë²¤íŠ¸
        newSocket.on('message_read', (data) => {
            console.log('Message read event received:', data);
            setMessages(prev => 
                prev.map(msg => 
                    msg.id === data.message_id 
                        ? { ...msg, unread_count: data.unread_count }
                        : msg
                )
            );
        });

        setSocket(newSocket);

        return () => {
            if (newSocket) {
                newSocket.emit('leave_chat', {
                    chat_type: chatType,
                    chat_id: chatId
                });
                newSocket.disconnect();
            }
        };
        */
    }, [chatId, chatType]);

    // ì±„íŒ…ë°© ì •ë³´ ë° ë©”ì‹œì§€ ë¡œë“œ
    useFocusEffect(useCallback(() => { 
        const loadChatData = async () => {
            try {
                // ì±„íŒ…ë°© ì •ë³´ ë¡œë“œ
                if (chatType === 'party') {
                    const response = await fetch(`${RENDER_SERVER_URL}/parties/${chatId}`);
                    const data = await response.json();
                    setChatDetails(data);
                    
                    // íŒŒí‹° ì°¸ê°€ì ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                    const membersResponse = await fetch(`${RENDER_SERVER_URL}/parties/${chatId}/members`);
                    if (membersResponse.ok) {
                        const membersData = await membersResponse.json();
                        setChatMembers(membersData);
                    }
                } else if (chatType === 'dangolpot') {
                    const response = await fetch(`${RENDER_SERVER_URL}/dangolpots/${chatId}`);
                    const data = await response.json();
                    setChatDetails(data);
                    
                    // ë‹¨ê³¨íŒŒí‹° ì°¸ê°€ì ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                    const membersResponse = await fetch(`${RENDER_SERVER_URL}/dangolpots/${chatId}/members`);
                    if (membersResponse.ok) {
                        const membersData = await membersResponse.json();
                        setChatMembers(membersData);
                    }
                } else if (chatType === 'custom') {
                    // ê°œì¸ ì±„íŒ…ì˜ ê²½ìš° ê¸°ë³¸ ì±„íŒ…ë°© ì •ë³´ ì„¤ì •
                    setChatDetails({
                        id: chatId,
                        title: chatTitle,
                        type: 'custom',
                        created_at: new Date().toISOString()
                    });
                    
                    // ê°œì¸ ì±„íŒ…ì˜ ê²½ìš° ì¹œêµ¬ ëª©ë¡ì—ì„œ ì°¸ê°€ì ê°€ì ¸ì˜¤ê¸°
                    const membersResponse = await fetch(`${RENDER_SERVER_URL}/friends?employee_id=${myEmployeeId}`);
                    if (membersResponse.ok) {
                        const friendsData = await membersResponse.json();
                        // ì±„íŒ…ë°© ì œëª©ì—ì„œ ì¹œêµ¬ ì´ë¦„ ì¶”ì¶œ (ì˜ˆ: "í™ê¸¸ë™ë‹˜ê³¼ì˜ ì±„íŒ…" -> "í™ê¸¸ë™")
                        const friendName = chatTitle.replace('ë‹˜ê³¼ì˜ ì±„íŒ…', '');
                        const friend = friendsData.find(f => f.nickname === friendName);
                        if (friend) {
                            setChatMembers([friend]);
                        }
                    }
                }

                // ë©”ì‹œì§€ ë¡œë“œ
                const messagesResponse = await fetch(`${RENDER_SERVER_URL}/chat/messages/${chatType}/${chatId}`);
                const messagesData = await messagesResponse.json();
                setMessages(messagesData);
                
                // ë©”ì‹œì§€ê°€ ë¡œë“œëœ í›„ ê°€ì¥ ì•„ë˜ë¡œ ìŠ¤í¬ë¡¤
                setTimeout(() => {
                    if (flatListRef.current && messagesData.length > 0) {
                        flatListRef.current.scrollToEnd({ animated: false });
                    }
                }, 200);
            } catch (error) {
                console.error('Error loading chat data:', error);
        }
        };

        loadChatData();
        
        // ì‹¤ì‹œê°„ ë©”ì‹œì§€ ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•œ ì¸í„°ë²Œ ì„¤ì • (3ì´ˆë§ˆë‹¤)
        const messageInterval = setInterval(async () => {
            try {
                const messagesResponse = await fetch(`${RENDER_SERVER_URL}/chat/messages/${chatType}/${chatId}`);
                const messagesData = await messagesResponse.json();
                
                // ë©”ì‹œì§€ ê°œìˆ˜ë‚˜ ë‚´ìš©ì´ ë‹¤ë¥´ë©´ ì—…ë°ì´íŠ¸
                const currentMessageIds = messages.map(m => m.id).join(',');
                const newMessageIds = messagesData.map(m => m.id).join(',');
                
                if (currentMessageIds !== newMessageIds) {
                    // ìƒˆë¡œìš´ ë©”ì‹œì§€ê°€ ìˆëŠ”ì§€ í™•ì¸
                    const newMessages = messagesData.filter(newMsg => 
                        !messages.some(oldMsg => oldMsg.id === newMsg.id)
                    );
                    
                    // íˆ¬í‘œ ì•Œë¦¼ ë©”ì‹œì§€ê°€ ìˆëŠ”ì§€ í™•ì¸
                    const votingNotifications = newMessages.filter(msg => msg.message_type === 'voting_notification');
                    if (votingNotifications.length > 0) {
                        console.log('ìƒˆë¡œìš´ íˆ¬í‘œ ì•Œë¦¼ ê°ì§€:', votingNotifications);
                        // ì‚¬ìš©ìì—ê²Œ íˆ¬í‘œ ì•Œë¦¼
                        Alert.alert(
                            'ğŸ“Š ìƒˆë¡œìš´ íˆ¬í‘œ',
                            'ìƒˆë¡œìš´ íˆ¬í‘œê°€ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤! ì±„íŒ…ì°½ì˜ íˆ¬í‘œ ë©”ì‹œì§€ë¥¼ í„°ì¹˜í•˜ì—¬ ì°¸ì—¬í•˜ì„¸ìš”.',
                            [{ text: 'í™•ì¸' }]
                        );
                    }
                    
                    // íˆ¬í‘œ ì‚­ì œ ì•Œë¦¼ ë©”ì‹œì§€ê°€ ìˆëŠ”ì§€ í™•ì¸
                    const votingCancellations = newMessages.filter(msg => msg.message_type === 'voting_cancelled');
                    if (votingCancellations.length > 0) {
                        console.log('íˆ¬í‘œ ì‚­ì œ ì•Œë¦¼ ê°ì§€:', votingCancellations);
                        // ì‚¬ìš©ìì—ê²Œ íˆ¬í‘œ ì‚­ì œ ì•Œë¦¼
                        Alert.alert(
                            'ğŸš« íˆ¬í‘œ ì‚­ì œ',
                            'íˆ¬í‘œê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.',
                            [{ text: 'í™•ì¸' }]
                        );
                    }
                    
                    // íˆ¬í‘œ ì™„ë£Œ ì•Œë¦¼ ë©”ì‹œì§€ê°€ ìˆëŠ”ì§€ í™•ì¸
                    const votingCompletions = newMessages.filter(msg => msg.message_type === 'voting_completed');
                    if (votingCompletions.length > 0) {
                        console.log('íˆ¬í‘œ ì™„ë£Œ ì•Œë¦¼ ê°ì§€:', votingCompletions);
                        // ì‚¬ìš©ìì—ê²Œ íˆ¬í‘œ ì™„ë£Œ ì•Œë¦¼
                        Alert.alert(
                            'ğŸ‰ íˆ¬í‘œ ì™„ë£Œ',
                            'íˆ¬í‘œê°€ ì™„ë£Œë˜ì–´ ì¼ì •ì´ í™•ì •ë˜ì—ˆìŠµë‹ˆë‹¤! ì¼ì •ì— ìë™ìœ¼ë¡œ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.',
                            [{ text: 'í™•ì¸' }]
                        );
                    }
                    
                    setMessages(messagesData);
                    
                    // ìƒˆë¡œìš´ ë©”ì‹œì§€ê°€ ìˆì„ ë•Œ ìŠ¤í¬ë¡¤
                    setTimeout(() => {
                        if (flatListRef.current) {
                            flatListRef.current.scrollToEnd({ animated: true });
                        }
                    }, 100);
                }
            } catch (error) {
                console.error('ì‹¤ì‹œê°„ ë©”ì‹œì§€ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜:', error);
            }
        }, 3000);
        
        // í´ë¦°ì—… í•¨ìˆ˜
        return () => {
            if (messageInterval) {
                clearInterval(messageInterval);
            }
        };
    }, [chatId, chatType, messages.length]));

    // ë©”ì‹œì§€ ëª©ë¡ì´ ë³€ê²½ë  ë•Œë§ˆë‹¤ ìë™ ìŠ¤í¬ë¡¤
    useEffect(() => {
        if (messages.length > 0) {
            setTimeout(() => {
                if (flatListRef.current) {
                    flatListRef.current.scrollToEnd({ animated: true });
                }
            }, 100);
        }
    }, [messages.length]);

    // ë©”ì‹œì§€ ì „ì†¡
    const sendMessage = async () => {
        if (!newMessage.trim()) return;

        const messageText = newMessage.trim();
        setNewMessage(''); // ì¦‰ì‹œ ì…ë ¥ì°½ ë¹„ìš°ê¸°

        try {
            console.log('Sending message:', messageText);
            
            // HTTP APIë¡œ ë©”ì‹œì§€ ì „ì†¡ (WebSocket ì—°ê²° ë¬¸ì œë¡œ ì¸í•´ HTTPë§Œ ì‚¬ìš©)
            console.log('Sending via HTTP API');
            const response = await fetch(`${RENDER_SERVER_URL}/chat/messages`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
            chat_type: chatType,
            chat_id: chatId,
            sender_employee_id: myEmployeeId,
                    message: messageText
                })
            });

            if (response.ok) {
                const responseData = await response.json();
                console.log('Message sent via HTTP:', responseData);
                
                // ì„œë²„ì—ì„œ ë°›ì€ ë©”ì‹œì§€ ë°ì´í„°ë¡œ ë¡œì»¬ì— ì¶”ê°€
                const newMsg = {
                    id: responseData.id || Date.now(),
                    sender_employee_id: myEmployeeId,
                    sender_nickname: myNickname,
                    message: messageText,
                    created_at: responseData.created_at || new Date().toISOString(),
                    chat_type: chatType,
                    chat_id: chatId,
                    unread_count: 0
                };
                setMessages(prev => [...prev, newMsg]);
                
                // ì†Œí†µì˜ ì‹œì‘ ë¯¸ì…˜ ì™„ë£Œ ì²˜ë¦¬
                handleActionCompletion('chat_with_friend');
                
                // ë©”ì‹œì§€ë¥¼ ë³´ë‚¸ í›„ ìŠ¤í¬ë¡¤
                setTimeout(() => {
                    if (flatListRef.current) {
                        flatListRef.current.scrollToEnd({ animated: true });
                    }
                }, 100);
            } else {
                const errorData = await response.json();
                console.error('Message send failed:', errorData);
                Alert.alert('ì˜¤ë¥˜', errorData.message || 'ë©”ì‹œì§€ ì „ì†¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                setNewMessage(messageText); // ì‹¤íŒ¨ ì‹œ ë‹¤ì‹œ ì…ë ¥ì°½ì— ë³µì›
            }
        } catch (error) {
            console.error('ë©”ì‹œì§€ ì „ì†¡ ì˜¤ë¥˜:', error);
            Alert.alert('ì˜¤ë¥˜', 'ë„¤íŠ¸ì›Œí¬ì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            setNewMessage(messageText); // ì‹¤íŒ¨ ì‹œ ë‹¤ì‹œ ì…ë ¥ì°½ì— ë³µì›
        }
    };

    // ë©”ì‹œì§€ ê²€ìƒ‰
    const searchMessages = async () => {
        if (!searchQuery.trim()) {
            setSearchResults([]);
            return;
        }

        try {
            setIsSearching(true);
            const response = await fetch(`${RENDER_SERVER_URL}/chat/messages/search?employee_id=${myEmployeeId}&chat_type=${chatType}&chat_id=${chatId}&query=${encodeURIComponent(searchQuery.trim())}`);
            
            // ì‘ë‹µ ìƒíƒœ í™•ì¸
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            // ì‘ë‹µ íƒ€ì… í™•ì¸
            const contentType = response.headers.get('content-type');
            if (!contentType || !contentType.includes('application/json')) {
                throw new Error('ì„œë²„ì—ì„œ JSONì´ ì•„ë‹Œ ì‘ë‹µì„ ë°›ì•˜ìŠµë‹ˆë‹¤.');
            }
            
            const data = await response.json();
                setSearchResults(data);
        } catch (error) {
            console.error('ë©”ì‹œì§€ ê²€ìƒ‰ ì˜¤ë¥˜:', error);
            
            // ì‚¬ìš©ìì—ê²Œ ë” ëª…í™•í•œ ì˜¤ë¥˜ ë©”ì‹œì§€ í‘œì‹œ
            if (error.message.includes('JSON')) {
                Alert.alert('ì˜¤ë¥˜', 'ì„œë²„ ì‘ë‹µ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.');
            } else if (error.message.includes('HTTP')) {
                Alert.alert('ì˜¤ë¥˜', 'ì„œë²„ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ë„¤íŠ¸ì›Œí¬ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.');
            } else {
                Alert.alert('ì˜¤ë¥˜', 'ë©”ì‹œì§€ ê²€ìƒ‰ ì¤‘ ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
            
            setSearchResults([]);
        } finally {
            setIsSearching(false);
        }
    };

    // ì±„íŒ…ë°© ë‚˜ê°€ê¸°
    const leaveChat = async () => {
        Alert.alert('ì±„íŒ…ë°© ë‚˜ê°€ê¸°', 'ì •ë§ë¡œ ì´ ì±„íŒ…ë°©ì„ ë‚˜ê°€ì‹œê² ìŠµë‹ˆê¹Œ?', [
            { text: 'ì·¨ì†Œ', style: 'cancel' },
            { 
                text: 'ë‚˜ê°€ê¸°', 
                style: 'destructive', 
                onPress: async () => {
                    try {
                        const response = await fetch(`${RENDER_SERVER_URL}/chat/leave`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                employee_id: myEmployeeId,
                                chat_type: chatType,
                                chat_id: chatId
                            })
                        });
                        const data = await response.json();
                        if (response.ok) {
                            Alert.alert('ì„±ê³µ', data.message);
                            navigation.goBack();
                        } else {
                            Alert.alert('ì˜¤ë¥˜', data.message || 'ì±„íŒ…ë°©ì„ ë‚˜ê°€ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                        }
                    } catch (error) {
                        console.error('ì±„íŒ…ë°© ë‚˜ê°€ê¸° ì˜¤ë¥˜:', error);
                        Alert.alert('ì˜¤ë¥˜', 'ë„¤íŠ¸ì›Œí¬ì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                    }
                }
            }
        ]);
    };
    // ì ì‹¬ ì•½ì† ì¡ê¸°
    const handleLunchScheduling = async () => {
        if (chatMembers.length === 0) {
            // ì°¸ê°€ì ì •ë³´ê°€ ì—†ìœ¼ë©´ ë¨¼ì € ê°€ì ¸ì˜¤ê¸°
            try {
                const response = await fetch(`${RENDER_SERVER_URL}/chat/room/members/${chatType}/${chatId}`);
                const data = await response.json();
                if (response.ok) {
                    setChatMembers(data);
                    // ì°¸ê°€ì ì •ë³´ë¥¼ ê°€ì ¸ì˜¨ í›„ ì§€ëŠ¥í˜• ìŠ¤ì¼€ì¤„ë§ í™”ë©´ìœ¼ë¡œ ì´ë™
                    navigation.navigate('IntelligentScheduling', { 
                        chatMembers: data,
                        chatType: chatType,
                        chatId: chatId
                    });
                } else {
                    Alert.alert('ì˜¤ë¥˜', data.message || 'ì°¸ê°€ì ëª©ë¡ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                }
            } catch (error) {
                console.error('ì°¸ê°€ì ëª©ë¡ ì¡°íšŒ ì˜¤ë¥˜:', error);
                Alert.alert('ì˜¤ë¥˜', 'ë„¤íŠ¸ì›Œí¬ì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
            }
        } else {
            // ì°¸ê°€ì ì •ë³´ê°€ ì´ë¯¸ ìˆìœ¼ë©´ ë°”ë¡œ ì´ë™
        navigation.navigate('IntelligentScheduling', { 
            chatMembers: chatMembers,
            chatType: chatType,
            chatId: chatId
        });
        }
    };

    // ì±„íŒ…ë°© ì œëª© ë³€ê²½
    const handleTitleChange = async () => {
        if (!newTitle.trim()) {
            Alert.alert('ì˜¤ë¥˜', 'ìƒˆ ì œëª©ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
            return;
        }

        try {
            const response = await fetch(`${RENDER_SERVER_URL}/chat/room/title`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    chat_type: chatType,
                    chat_id: chatId,
                    title: newTitle.trim(),
                    user_id: myEmployeeId
                })
            });

            const data = await response.json();
            if (response.ok) {
                Alert.alert('ì„±ê³µ', data.message);
                setChatTitle(newTitle.trim());
                setIsTitleEditVisible(false);
                setNewTitle('');
            } else {
                Alert.alert('ì˜¤ë¥˜', data.message || 'ì œëª© ë³€ê²½ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }
        } catch (error) {
            console.error('ì œëª© ë³€ê²½ ì˜¤ë¥˜:', error);
            Alert.alert('ì˜¤ë¥˜', 'ë„¤íŠ¸ì›Œí¬ì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        }
    };

    // ì°¸ê°€ì ëª©ë¡ ì¡°íšŒ
    const fetchMembers = async () => {
        try {
            const response = await fetch(`${RENDER_SERVER_URL}/chat/room/members/${chatType}/${chatId}`);
            const data = await response.json();
            if (response.ok) {
                setChatMembers(data);
                setIsMembersVisible(true);
            } else {
                Alert.alert('ì˜¤ë¥˜', data.message || 'ì°¸ê°€ì ëª©ë¡ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
            }
        } catch (error) {
            console.error('ì°¸ê°€ì ëª©ë¡ ì¡°íšŒ ì˜¤ë¥˜:', error);
            Alert.alert('ì˜¤ë¥˜', 'ë„¤íŠ¸ì›Œí¬ì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
        }
    };

    // ì´ë¯¸ì§€ ì „ì†¡
    const sendImage = async (imageUri) => {
        try {
            // ì´ë¯¸ì§€ë¥¼ base64ë¡œ ë³€í™˜
            const response = await fetch(imageUri);
            const blob = await response.blob();
            const reader = new FileReader();
            
            reader.onload = async () => {
                const base64Data = reader.result;
                
                // ì„œë²„ì— ì´ë¯¸ì§€ ì—…ë¡œë“œ
                const uploadResponse = await fetch(`${RENDER_SERVER_URL}/chat/upload-image`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image_data: base64Data,
                        chat_type: chatType,
                        chat_id: chatId,
                        sender_employee_id: myEmployeeId
                    })
                });
                
                const uploadData = await uploadResponse.json();
                if (uploadResponse.ok) {
                    // WebSocketìœ¼ë¡œ ì´ë¯¸ì§€ ë©”ì‹œì§€ ì „ì†¡
                    socket.emit('send_message', {
                        chat_type: chatType,
                        chat_id: chatId,
                        sender_employee_id: myEmployeeId,
                        message: '[ì´ë¯¸ì§€]',
                        message_type: 'image',
                        file_url: uploadData.file_url
                    });
                } else {
                    Alert.alert('ì˜¤ë¥˜', uploadData.message || 'ì´ë¯¸ì§€ ì—…ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                }
            };
            
            reader.readAsDataURL(blob);
        } catch (error) {
            console.error('ì´ë¯¸ì§€ ì „ì†¡ ì˜¤ë¥˜:', error);
            Alert.alert('ì˜¤ë¥˜', 'ì´ë¯¸ì§€ ì „ì†¡ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
        }
    };
    // ë©”ì‹œì§€ ë Œë”ë§
    const renderMessage = ({ item }) => {
        const isMyMessage = item.sender_employee_id === myEmployeeId;
        
        // ì‹ë‹¹ ê³µìœ  ë©”ì‹œì§€ì¸ì§€ í™•ì¸
        const isRestaurantShareMessage = item.message && item.message.includes('[ì‹ë‹¹ì •ë³´:');
        let restaurantData = null;
        
        if (isRestaurantShareMessage) {
            try {
                // [ì‹ë‹¹ì •ë³´:ë¡œ ì‹œì‘í•˜ê³  ]ë¡œ ëë‚˜ëŠ” ë¶€ë¶„ì„ ì°¾ê¸°
                const startIndex = item.message.indexOf('[ì‹ë‹¹ì •ë³´:');
                const endIndex = item.message.lastIndexOf(']');
                
                if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {
                    const jsonString = item.message.substring(startIndex + 6, endIndex);
                    console.log('íŒŒì‹±í•  JSON ë¬¸ìì—´:', jsonString);
                    restaurantData = JSON.parse(jsonString);
                    console.log('íŒŒì‹±ëœ ì‹ë‹¹ ë°ì´í„°:', restaurantData);
                }
            } catch (error) {
                console.error('ì‹ë‹¹ ì •ë³´ íŒŒì‹± ì˜¤ë¥˜:', error);
                // íŒŒì‹± ì‹¤íŒ¨ ì‹œ ê¸°ë³¸ ë°ì´í„°ë¡œ ëŒ€ì²´
                restaurantData = {
                    id: 1,
                    name: 'ë§›ìˆëŠ” í•œì‹ë‹¹',
                    rating: '4.5',
                    address: '',
                    tags: ['í•œì‹', 'ì˜¤ì°¬í•˜ê¸° ì¢‹ì•„ìš”'],
                    image: '',
                    shared_at: new Date().toISOString()
                };
            }
        }
        
        // ë‚´ê°€ ë³´ë‚¸ ë©”ì‹œì§€ê°€ ì•„ë‹ˆê³  ì•„ì§ ì½ì§€ ì•Šì€ ë©”ì‹œì§€ì¸ ê²½ìš° ì½ìŒ ì²˜ë¦¬
        if (!isMyMessage && item.unread_count > 0) {
            // HTTP APIë¥¼ ì‚¬ìš©í•˜ì—¬ ì½ìŒ ì²˜ë¦¬
            fetch(`${RENDER_SERVER_URL}/chat/messages/read`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    message_id: item.id,
                    user_id: myEmployeeId,
                    chat_type: chatType,
                    chat_id: chatId
                })
            }).catch(error => {
                console.error('ì½ìŒ ì²˜ë¦¬ ì˜¤ë¥˜:', error);
            });
        }
        
        return (
            <View style={[styles.messageContainer, isMyMessage ? styles.myMessage : styles.otherMessage]}>
                {!isMyMessage && item.sender_nickname && (
                    <Text style={styles.messageSender}>{item.sender_nickname}</Text>
                )}
                <View style={[
                    styles.messageBubble,
                    isMyMessage ? styles.myMessageBubble : styles.otherMessageBubble,
                    { backgroundColor: isMyMessage ? currentColors.primary : currentColors.surface }
                ]}>
                    {item.message_type === 'voting_notification' ? (
                        <TouchableOpacity
                            style={{
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                borderColor: currentColors.primary,
                                borderWidth: 2,
                                borderRadius: 16,
                                padding: 12,
                                margin: 0,
                                maxWidth: '95%',
                                width: '100%'
                            }}
                            onPress={() => {
                                console.log('íˆ¬í‘œ ë©”ì‹œì§€ í„°ì¹˜ë¨:', {
                                    voting_session_id: item.voting_session_id,
                                    chatRoomId: chatId,
                                    item: item
                                });
                                
                                // íˆ¬í‘œ í™”ë©´ìœ¼ë¡œ ì´ë™
                                if (item.voting_session_id) {
                                    navigation.navigate('VotingParticipateScreen', {
                                        votingSessionId: item.voting_session_id,
                                        chatRoomId: chatId
                                    });
                                } else {
                                    Alert.alert('ì˜¤ë¥˜', 'íˆ¬í‘œ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                                }
                            }}
                            activeOpacity={0.7}
                        >
                            <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 8 }}>
                                <Text style={{ fontSize: 24, marginRight: 8 }}>ğŸ“Š</Text>
                                <Text style={{
                                    fontSize: 16,
                                    fontWeight: 'bold',
                                    color: currentColors.primary,
                                    flex: 1
                                }}>
                                    ìƒˆë¡œìš´ íˆ¬í‘œ
                                </Text>
                                <View style={{
                                    backgroundColor: currentColors.primary,
                                    borderRadius: 12,
                                    paddingHorizontal: 8,
                                    paddingVertical: 4
                                }}>
                                    <Text style={{
                                        color: 'white',
                                        fontSize: 12,
                                        fontWeight: 'bold'
                                    }}>
                                        í„°ì¹˜í•˜ì—¬ ì°¸ì—¬
                                    </Text>
                                </View>
                            </View>
                            <Text style={{
                                fontSize: 14,
                                color: currentColors.text,
                                lineHeight: 20
                            }}>
                                {item.message}
                            </Text>
                        </TouchableOpacity>
                    ) : item.message_type === 'voting_cancelled' ? (
                        <View
                            style={{
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                borderColor: '#EF4444',
                                borderWidth: 2,
                                borderRadius: 16,
                                padding: 12,
                                margin: 0,
                                maxWidth: '95%',
                                width: '100%'
                            }}
                        >
                            <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 8 }}>
                                <Text style={{ fontSize: 24, marginRight: 8 }}>ğŸš«</Text>
                                <Text style={{
                                    fontSize: 16,
                                    fontWeight: 'bold',
                                    color: '#EF4444',
                                    flex: 1
                                }}>
                                    íˆ¬í‘œ ì‚­ì œë¨
                                </Text>
                                <View style={{
                                    backgroundColor: '#EF4444',
                                    borderRadius: 12,
                                    paddingHorizontal: 8,
                                    paddingVertical: 4
                                }}>
                                    <Text style={{
                                        color: 'white',
                                        fontSize: 12,
                                        fontWeight: 'bold'
                                    }}>
                                        ì‚­ì œë¨
                                    </Text>
                                </View>
                            </View>
                            <Text style={{
                                fontSize: 14,
                                color: currentColors.text,
                                lineHeight: 20
                            }}>
                                {item.message}
                            </Text>
                                                 </View>
                     ) : item.message_type === 'voting_completed' ? (
                        <TouchableOpacity
                            style={{
                                backgroundColor: 'rgba(46, 213, 115, 0.1)',
                                borderColor: '#2ed573',
                                borderWidth: 2,
                                borderRadius: 16,
                                padding: 12,
                                margin: 0,
                                maxWidth: '95%',
                                width: '100%'
                            }}
                            onPress={() => {
                                // íˆ¬í‘œ í™”ë©´ìœ¼ë¡œ ì´ë™ (ì™„ë£Œëœ íˆ¬í‘œë„ ë³¼ ìˆ˜ ìˆë„ë¡)
                                if (item.voting_session_id) {
                                    navigation.navigate('VotingParticipateScreen', {
                                        votingSessionId: item.voting_session_id,
                                        chatRoomId: chatId
                                    });
                                } else {
                                    Alert.alert('ì˜¤ë¥˜', 'íˆ¬í‘œ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                                }
                            }}
                            activeOpacity={0.7}
                        >
                            <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 8 }}>
                                <Text style={{ fontSize: 24, marginRight: 8 }}>ğŸ‰</Text>
                                <Text style={{
                                    fontSize: 16,
                                    fontWeight: 'bold',
                                    color: '#2ed573',
                                    flex: 1
                                }}>
                                    íˆ¬í‘œ ì™„ë£Œ
                                </Text>
                                <View style={{
                                    backgroundColor: '#2ed573',
                                    borderRadius: 12,
                                    paddingHorizontal: 8,
                                    paddingVertical: 4
                                }}>
                                    <Text style={{
                                        color: 'white',
                                        fontSize: 12,
                                        fontWeight: 'bold'
                                    }}>
                                        í™•ì •ë¨
                                    </Text>
                                </View>
                            </View>
                            <Text style={{
                                fontSize: 14,
                                color: currentColors.text,
                                lineHeight: 20
                            }}>
                                {item.message}
                            </Text>
                        </TouchableOpacity>
                     ) : isRestaurantShareMessage ? (
                        <TouchableOpacity
                            style={{
                                backgroundColor: '#fff',
                                shadowColor: '#000',
                                shadowOffset: { width: 0, height: 2 },
                                shadowOpacity: 0.06,
                                shadowRadius: 8,
                                elevation: 2,
                                borderRadius: 16,
                                padding: 12,
                                margin: 0,
                                maxWidth: '95%',
                                width: '100%'
                            }}
                            onPress={() => {
                                if (restaurantData) {
                                    // ì‹ë‹¹ ìƒì„¸ í˜ì´ì§€ë¡œ ì´ë™
                                    navigation.navigate('RestaurantDetail', {
                                        restaurant: restaurantData
                                    });
                                } else {
                                    Alert.alert('ì˜¤ë¥˜', 'ì‹ë‹¹ ì •ë³´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                                }
                            }}
                            activeOpacity={0.7}
                        >
                            <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 8 }}>
                                <Text style={{ fontSize: 24, marginRight: 8 }}>ğŸ½ï¸</Text>
                                <Text style={{
                                    fontSize: 16,
                                    fontWeight: 'bold',
                                    color: '#1E293B',
                                    flex: 1
                                }}>
                                    ë§›ì§‘ ê³µìœ 
                                </Text>
                                <View style={{
                                    backgroundColor: '#3B82F6',
                                    borderRadius: 12,
                                    paddingHorizontal: 8,
                                    paddingVertical: 4
                                }}>
                                    <Text style={{
                                        color: 'white',
                                        fontSize: 12,
                                        fontWeight: 'bold'
                                    }}>
                                        í„°ì¹˜í•˜ì—¬ ë³´ê¸°
                                    </Text>
                                </View>
                            </View>
                            <Text style={{
                                fontSize: 14,
                                color: currentColors.text,
                                lineHeight: 20
                            }}>
                                {item.message.replace(/\[ì‹ë‹¹ì •ë³´:.*?\]/, '').replace(/ğŸ½ï¸ ë§›ì§‘ ê³µìœ \n\n/, '')}
                            </Text>
                        </TouchableOpacity>
                     ) : item.message_type === 'image' && item.file_url ? (
                        <TouchableOpacity
                            onPress={() => {
                                Alert.alert('ì´ë¯¸ì§€ ë³´ê¸°', 'ì´ë¯¸ì§€ í™•ëŒ€ ë³´ê¸° ê¸°ëŠ¥ì€ ì¶”í›„ êµ¬í˜„ ì˜ˆì •ì…ë‹ˆë‹¤.');
                            }}
                        >
                            <Image
                                source={{ uri: `${RENDER_SERVER_URL}${item.file_url}` }}
                                style={{ width: 200, height: 150, borderRadius: 12, marginBottom: 4 }}
                                resizeMode="cover"
                            />
                        </TouchableOpacity>
                    ) : (
                        <TouchableOpacity
                            onPress={() => {
                                // ì¼ë°˜ ë©”ì‹œì§€ë„ í´ë¦­ ì‹œ ì‹ë‹¹ ìƒì„¸ í˜ì´ì§€ë¡œ ì´ë™
                                const defaultRestaurantData = {
                                    id: 1,
                                    name: 'ë§›ìˆëŠ” í•œì‹ë‹¹',
                                    rating: '4.5',
                                    address: '',
                                    tags: ['í•œì‹', 'ì˜¤ì°¬í•˜ê¸° ì¢‹ì•„ìš”'],
                                    image: '',
                                    shared_at: new Date().toISOString()
                                };
                                navigation.navigate('RestaurantDetail', {
                                    restaurant: defaultRestaurantData
                                });
                            }}
                            activeOpacity={0.7}
                        >
                            <Text style={[
                                styles.messageText,
                                isMyMessage ? styles.myMessageText : styles.otherMessageText,
                                isMyMessage ? { color: '#FFFFFF' } : null
                            ]}>
                                {item.message}
                            </Text>
                        </TouchableOpacity>
                    )}
                </View>
                <View style={{ flexDirection: 'row', alignItems: 'center', marginTop: 2 }}>
                    <Text style={styles.messageTime}>{item.created_at}</Text>
                    {isMyMessage && item.unread_count > 0 && (
                        <Text style={{ fontSize: 12, color: '#4FC3F7', marginLeft: 4 }}>{item.unread_count}</Text>
                    )}
                </View>
            </View>
        );
    };

    if (!chatDetails) {
    return (
        <SafeAreaView style={styles.safeArea}>
                <View style={{flex: 1, justifyContent: 'center', alignItems: 'center'}}>
                    <ActivityIndicator size="large" color={currentColors.primary}/>
            </View>
            </SafeAreaView>
        );
    }
    return (
        <SafeAreaView style={styles.safeArea}>
            <KeyboardAvoidingView 
                style={{flex: 1, backgroundColor: currentColors.background}}
                behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
                keyboardVerticalOffset={Platform.OS === 'ios' ? 90 : 0}
            >
                {/* í—¤ë” ì•¡ì…˜ ë²„íŠ¼ë“¤ */}

                {/* ì‚¼ì„ (ë©”ë‰´) ì•„ì´ì½˜ì„ ëˆ„ë¥´ë©´ ì—´ë¦¬ëŠ” ë©”ë‰´ ëª¨ë‹¬ ì¶”ê°€ */}
                <Modal
                    visible={isMenuVisible}
                    transparent={true}
                    animationType="fade"
                    onRequestClose={() => setIsMenuVisible(false)}
                >
                    <TouchableOpacity style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.3)' }} activeOpacity={1} onPress={() => setIsMenuVisible(false)}>
                        <View style={{ position: 'absolute', top: 60, right: 16, backgroundColor: currentColors.surface, borderRadius: 12, padding: 12, minWidth: 160, elevation: 8 }}>
                            <TouchableOpacity style={{ paddingVertical: 12 }} onPress={async () => { 
                                setIsMenuVisible(false);
                                
                                let membersToPass = chatMembers;
                                
                                // chatMembersê°€ ë¹„ì–´ìˆìœ¼ë©´ ë¨¼ì € ë¡œë“œ
                                if (chatMembers.length === 0) {
                                    try {
                                        const response = await fetch(`${RENDER_SERVER_URL}/chat/room/members/${chatType}/${chatId}`);
                                        const data = await response.json();
                                        if (response.ok) {
                                            setChatMembers(data);
                                            membersToPass = data;
                                        } else {
                                            Alert.alert('ì˜¤ë¥˜', data.message || 'ì°¸ê°€ì ëª©ë¡ ì¡°íšŒì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                                            return;
                                        }
                                    } catch (error) {
                                        console.error('ì°¸ê°€ì ëª©ë¡ ì¡°íšŒ ì˜¤ë¥˜:', error);
                                        Alert.alert('ì˜¤ë¥˜', 'ë„¤íŠ¸ì›Œí¬ì— ë¬¸ì œê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                                        return;
                                    }
                                }
                                
                                navigation.navigate('VotingScreen', { 
                                    chatRoomId: chatId,
                                    chatTitle: chatTitle, // ì±„íŒ…ë°© ì œëª© ì¶”ê°€
                                    participants: membersToPass.map(member => ({
                                        employee_id: member.employee_id,
                                        nickname: member.nickname
                                    }))
                                }); 
                            }}>
                                <Text style={{ fontSize: 16, color: currentColors.primary, fontWeight: 'bold' }}>ğŸ—³ï¸ ìƒˆë¡œìš´ ì•½ì† ì¡ê¸°</Text>
                            </TouchableOpacity>
                            <View style={{ height: 1, backgroundColor: currentColors.lightGray, marginVertical: 4 }} />
                            <TouchableOpacity style={{ paddingVertical: 12 }} onPress={() => { setIsMenuVisible(false); setIsTitleEditVisible(true); }}>
                                <Text style={{ fontSize: 16, color: currentColors.text }}>ì±„íŒ…ë°© ì œëª© ë³€ê²½</Text>
                            </TouchableOpacity>
                            <View style={{ height: 1, backgroundColor: currentColors.lightGray, marginVertical: 4 }} />
                            <TouchableOpacity style={{ paddingVertical: 12 }} onPress={() => { setIsMenuVisible(false); fetchMembers(); }}>
                                <Text style={{ fontSize: 16, color: currentColors.text }}>ì°¸ê°€ì ëª©ë¡</Text>
                            </TouchableOpacity>
                            <View style={{ height: 1, backgroundColor: currentColors.lightGray, marginVertical: 4 }} />
                            <TouchableOpacity style={{ paddingVertical: 12 }} onPress={() => { 
                                setIsMenuVisible(false); 
                                Alert.alert(
                                    'ì±„íŒ…ë°© ë‚˜ê°€ê¸°',
                                    'ì •ë§ë¡œ ì´ ì±„íŒ…ë°©ì„ ë‚˜ê°€ì‹œê² ìŠµë‹ˆê¹Œ?',
                                    [
                                        {
                                            text: 'ì·¨ì†Œ',
                                            style: 'cancel'
                                        },
                                        {
                                            text: 'ë‚˜ê°€ê¸°',
                                            style: 'destructive',
                                            onPress: async () => {
                                                try {
                                                    const response = await fetch(`${API_BASE_URL}/chat/leave`, {
                                                        method: 'POST',
                                                        headers: { 'Content-Type': 'application/json' },
                                                        body: JSON.stringify({
                                                            chat_type: chatType,
                                                            chat_id: chatId,
                                                            employee_id: myEmployeeId
                                                        })
                                                    });
                                                    
                                                    if (response.ok) {
                                                        Alert.alert('ì™„ë£Œ', 'ì±„íŒ…ë°©ì„ ë‚˜ê°”ìŠµë‹ˆë‹¤.', [
                                                            { text: 'í™•ì¸', onPress: () => navigation.goBack() }
                                                        ]);
                                                    } else {
                                                        const errorData = await response.json();
                                                        Alert.alert('ì˜¤ë¥˜', errorData.error || 'ì±„íŒ…ë°© ë‚˜ê°€ê¸°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.');
                                                    }
                                                } catch (error) {
                                                    console.error('ì±„íŒ…ë°© ë‚˜ê°€ê¸° ì˜¤ë¥˜:', error);
                                                    Alert.alert('ì˜¤ë¥˜', 'ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                                                }
                                            }
                                        }
                                    ]
                                );
                            }}>
                                <Text style={{ fontSize: 16, color: currentColors.red }}>ğŸšª ì±„íŒ…ë°© ë‚˜ê°€ê¸°</Text>
                    </TouchableOpacity>
                </View>
                    </TouchableOpacity>
                </Modal>

                {/* ê²€ìƒ‰ ì˜ì—­ */}
                {isSearchVisible && (
                    <View style={{
                        backgroundColor: currentColors.surface,
                        paddingHorizontal: 16,
                        paddingVertical: 12,
                        borderBottomWidth: 1,
                        borderBottomColor: currentColors.lightGray
                    }}>
                        <View style={{
                            flexDirection: 'row',
                            alignItems: 'center'
                        }}>
                            <TextInput
                                style={{
                                    flex: 1,
                                    backgroundColor: currentColors.background,
                                    borderRadius: 20,
                                    paddingHorizontal: 16,
                                    paddingVertical: 8,
                                    marginRight: 8,
                                    fontSize: 14,
                                    color: currentColors.text,
                                    borderWidth: 1,
                                    borderColor: currentColors.lightGray
                                }}
                                value={searchQuery}
                                onChangeText={setSearchQuery}
                                placeholder="ë©”ì‹œì§€ ê²€ìƒ‰..."
                                placeholderTextColor={currentColors.textSecondary}
                                onSubmitEditing={searchMessages}
                            />
                            <TouchableOpacity
                                style={{
                                    backgroundColor: currentColors.primary,
                                    borderRadius: 20,
                                    paddingHorizontal: 12,
                                    paddingVertical: 8
                                }}
                                onPress={searchMessages}
                                disabled={isSearching}
                            >
                                {isSearching ? (
                                    <ActivityIndicator size="small" color="#FFFFFF" />
                                ) : (
                                    <Ionicons name="search" size={16} color="#FFFFFF" />
                                )}
                            </TouchableOpacity>
                            <TouchableOpacity
                                style={{
                                    backgroundColor: currentColors.lightGray,
                                    borderRadius: 20,
                                    paddingHorizontal: 12,
                                    paddingVertical: 8,
                                    marginLeft: 8
                                }}
                                onPress={() => {
                                    setIsSearchVisible(false);
                                    setSearchQuery('');
                                    setSearchResults([]);
                                }}
                            >
                                <Ionicons name="close" size={16} color={currentColors.text} />
                            </TouchableOpacity>
                        </View>
                        
                        {/* ê²€ìƒ‰ ê²°ê³¼ */}
                        {searchResults.length > 0 && (
                            <View style={{marginTop: 8}}>
                                <Text style={{fontSize: 12, color: currentColors.textSecondary, marginBottom: 4}}>
                                    ê²€ìƒ‰ ê²°ê³¼: {searchResults.length}ê°œ
                                </Text>
                                <FlatList
                                    data={searchResults}
                                    keyExtractor={(item, index) => `search-${item.id}-${index}`}
                                    renderItem={renderMessage}
                                    style={{maxHeight: 200}}
                                    showsVerticalScrollIndicator={false}
                                />
                            </View>
                        )}
                    </View>
                )}

                {/* ë©”ì‹œì§€ ëª©ë¡ */}
                <FlatList
                    ref={flatListRef}
                    data={messages}
                    keyExtractor={(item, index) => `${item.id}-${index}`}
                    renderItem={renderMessage}
                    style={{flex: 1, backgroundColor: currentColors.background}}
                    contentContainerStyle={{paddingHorizontal: 16, paddingVertical: 8}}
                    onContentSizeChange={() => {
                        if (messages.length > 0) {
                            flatListRef.current?.scrollToEnd({ animated: true });
                        }
                    }}
                    onLayout={() => {
                        if (messages.length > 0) {
                            flatListRef.current?.scrollToEnd({ animated: true });
                        }
                    }}
                    onViewableItemsChanged={({ viewableItems }) => {
                        // í™”ë©´ì— ë³´ì´ëŠ” ë©”ì‹œì§€ë“¤ ì¤‘ ë‚´ê°€ ë³´ë‚¸ ë©”ì‹œì§€ê°€ ì•„ë‹Œ ê²ƒë“¤ì„ ì½ìŒ ì²˜ë¦¬
                        const unreadMessages = viewableItems
                            .map(item => item.item)
                            .filter(msg => msg.sender_employee_id !== myEmployeeId && msg.unread_count > 0);
                        
                        unreadMessages.forEach(msg => {
                            // HTTP APIë¥¼ ì‚¬ìš©í•˜ì—¬ ì½ìŒ ì²˜ë¦¬
                            fetch(`${RENDER_SERVER_URL}/chat/messages/read`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    message_id: msg.id,
                                    user_id: myEmployeeId,
                                    chat_type: chatType,
                                    chat_id: chatId
                                })
                            }).catch(error => {
                                console.error('ì½ìŒ ì²˜ë¦¬ ì˜¤ë¥˜:', error);
                            });
                        });
                    }}
                    viewabilityConfig={{
                        itemVisiblePercentThreshold: 50
                    }}
                />

                {/* ì œëª© ë³€ê²½ ëª¨ë‹¬ */}
                <Modal
                    visible={isTitleEditVisible}
                    transparent={true}
                    animationType="slide"
                    onRequestClose={() => setIsTitleEditVisible(false)}
                >
                    <View style={{
                        flex: 1,
                        backgroundColor: 'rgba(0, 0, 0, 0.5)',
                        justifyContent: 'center',
                        alignItems: 'center',
                        paddingHorizontal: 20
                    }}>
                        <View style={{
                            backgroundColor: currentColors.surface,
                            borderRadius: 12,
                            padding: 20,
                            width: '100%',
                            maxWidth: 300
                        }}>
                            <Text style={{
                                fontSize: 18,
                                fontWeight: 'bold',
                                color: currentColors.text,
                                marginBottom: 16,
                                textAlign: 'center'
                            }}>
                                ì±„íŒ…ë°© ì œëª© ë³€ê²½
                            </Text>
                            
                            <TextInput
                                style={{
                                    backgroundColor: currentColors.background,
                                    borderRadius: 8,
                                    paddingHorizontal: 12,
                                    paddingVertical: 8,
                                    fontSize: 16,
                                    color: currentColors.text,
                                    borderWidth: 1,
                                    borderColor: currentColors.lightGray,
                                    marginBottom: 16
                                }}
                                value={newTitle}
                                onChangeText={setNewTitle}
                                placeholder="ìƒˆ ì œëª©ì„ ì…ë ¥í•˜ì„¸ìš”"
                                placeholderTextColor={currentColors.textSecondary}
                            />
                            
                            <View style={{
                                flexDirection: 'row',
                                justifyContent: 'space-between'
                            }}>
                                <TouchableOpacity
                                    style={{
                                        backgroundColor: currentColors.lightGray,
                                        borderRadius: 8,
                                        paddingHorizontal: 16,
                                        paddingVertical: 8,
                                        flex: 1,
                                        marginRight: 8
                                    }}
                                    onPress={() => {
                                        setIsTitleEditVisible(false);
                                        setNewTitle('');
                                    }}
                                >
                                    <Text style={{
                                        color: currentColors.text,
                                        fontSize: 14,
                                        fontWeight: '600',
                                        textAlign: 'center'
                                    }}>
                                        ì·¨ì†Œ
                                    </Text>
                                </TouchableOpacity>
                                
                                <TouchableOpacity
                                    style={{
                                        backgroundColor: currentColors.primary,
                                        borderRadius: 8,
                                        paddingHorizontal: 16,
                                        paddingVertical: 8,
                                        flex: 1,
                                        marginLeft: 8
                                    }}
                                    onPress={handleTitleChange}
                                >
                                    <Text style={{
                                        color: '#FFFFFF',
                                        fontSize: 14,
                                        fontWeight: '600',
                                        textAlign: 'center'
                                    }}>
                                        ë³€ê²½
                                    </Text>
                                </TouchableOpacity>
                            </View>
                        </View>
                    </View>
                </Modal>

                {/* ì°¸ê°€ì ëª©ë¡ ëª¨ë‹¬ */}
                <Modal
                    visible={isMembersVisible}
                    transparent={true}
                    animationType="slide"
                    onRequestClose={() => setIsMembersVisible(false)}
                >
                    <View style={{
                        flex: 1,
                        backgroundColor: 'rgba(0, 0, 0, 0.5)',
                        justifyContent: 'center',
                        alignItems: 'center',
                        paddingHorizontal: 20
                    }}>
                        <View style={{
                            backgroundColor: currentColors.surface,
                            borderRadius: 12,
                            padding: 20,
                            width: '100%',
                            maxWidth: 350,
                            maxHeight: '80%'
                        }}>
                            {/* ì°¸ê°€ì ëª©ë¡ íƒ€ì´í‹€ ì¸ì›ìˆ˜ ê³„ì‚° */}
                            {(() => {
                                const leader = chatMembers.find(m => m.is_host);
                                const memberCount = (leader ? 1 : 0) + chatMembers.filter(m => !leader || m.employee_id !== leader.employee_id).length;
                                return (
                                    <Text style={{
                                        fontSize: 18,
                                        fontWeight: 'bold',
                                        color: currentColors.text,
                                        marginBottom: 16,
                                        textAlign: 'center'
                                    }}>
                                        ì°¸ê°€ì ëª©ë¡ ({memberCount}ëª…)
                                    </Text>
                                );
                            })()}
                            
                            {/* íŒŸì¥(í˜¸ìŠ¤íŠ¸)ë§Œ ë§¨ ìœ„ì— í•œ ë²ˆ í‘œì‹œ */}
                            {(() => {
                                const leader = chatMembers.find(m => m.is_host);
                                if (!leader) return null;
                                return (
                                    <View style={{
                                        flexDirection: 'row',
                                        alignItems: 'center',
                                        paddingVertical: 8,
                                        paddingHorizontal: 12,
                                        backgroundColor: currentColors.background,
                                        borderRadius: 8,
                                        marginBottom: 8
                                    }}>
                                        <View style={{
                                            width: 40,
                                            height: 40,
                                            borderRadius: 20,
                                            backgroundColor: currentColors.yellow,
                                            justifyContent: 'center',
                                            alignItems: 'center',
                                            marginRight: 12
                                        }}>
                                            <Text style={{
                                                color: currentColors.deepBlue,
                                                fontSize: 16,
                                                fontWeight: 'bold'
                                            }}>
                                                {leader.nickname ? leader.nickname.charAt(0) : '?'}
                                            </Text>
                                        </View>
                                        <View style={{ flex: 1 }}>
                                            <Text style={{
                                                fontSize: 16,
                                                fontWeight: '600',
                                                color: currentColors.text
                                            }}>
                                                {leader.nickname || 'ì•Œ ìˆ˜ ì—†ìŒ'}
                                            </Text>
                                        </View>
                                        <View style={{
                                            backgroundColor: currentColors.yellow,
                                            borderRadius: 12,
                                            paddingHorizontal: 8,
                                            paddingVertical: 4
                                        }}>
                                            <Text style={{
                                                fontSize: 10,
                                                fontWeight: 'bold',
                                                color: currentColors.deepBlue
                                            }}>
                                                íŒŸì¥
                                            </Text>
                                        </View>
                                    </View>
                                );
                            })()}
                            {/* ì¼ë°˜ ë©¤ë²„ë§Œ ë¦¬ìŠ¤íŠ¸ë¡œ í‘œì‹œ (íŒŸì¥ employee_idì™€ ë‹¤ë¥¸ ë©¤ë²„ë§Œ) */}
                            <FlatList
                                data={chatMembers.filter(m => {
                                    const leader = chatMembers.find(x => x.is_host);
                                    return !leader || m.employee_id !== leader.employee_id;
                                })}
                                keyExtractor={(item, index) => `member-${item.employee_id}-${index}`}
                                renderItem={({ item }) => (
                                    <View style={{
                                        flexDirection: 'row',
                                        alignItems: 'center',
                                        paddingVertical: 8,
                                        paddingHorizontal: 12,
                                        backgroundColor: currentColors.background,
                                        borderRadius: 8,
                                        marginBottom: 8
                                    }}>
                                        <View style={{
                                            width: 40,
                                            height: 40,
                                            borderRadius: 20,
                                            backgroundColor: currentColors.primary,
                                            justifyContent: 'center',
                                            alignItems: 'center',
                                            marginRight: 12
                                        }}>
                                            <Text style={{
                                                color: '#FFFFFF',
                                                fontSize: 16,
                                                fontWeight: 'bold'
                                            }}>
                                                {item.nickname ? item.nickname.charAt(0) : '?'}
                                            </Text>
                                        </View>
                                        <View style={{ flex: 1 }}>
                                            <Text style={{
                                                fontSize: 16,
                                                fontWeight: '600',
                                                color: currentColors.text
                                            }}>
                                                {item.nickname || 'ì•Œ ìˆ˜ ì—†ìŒ'}
                                            </Text>
                                        </View>
                                    </View>
                                )}
                                showsVerticalScrollIndicator={false}
                            />
                            
                            <TouchableOpacity
                                style={{
                                    backgroundColor: currentColors.primary,
                                    borderRadius: 8,
                                    paddingHorizontal: 16,
                                    paddingVertical: 12,
                                    marginTop: 16
                                }}
                                onPress={() => setIsMembersVisible(false)}
                            >
                                <Text style={{
                                    color: '#FFFFFF',
                                    fontSize: 16,
                                    fontWeight: '600',
                                    textAlign: 'center'
                                }}>
                                    ë‹«ê¸°
                                </Text>
                            </TouchableOpacity>
                        </View>
                    </View>
                </Modal>

                {/* ë©”ì‹œì§€ ì…ë ¥ ì˜ì—­ */}
                <View style={{
                    backgroundColor: currentColors.surface,
                    borderTopWidth: 1,
                    borderTopColor: currentColors.lightGray,
                    paddingHorizontal: 16,
                    paddingVertical: 12,
                    flexDirection: 'row',
                    alignItems: 'flex-end'
                }}>
                    <TouchableOpacity
                        style={{
                            backgroundColor: currentColors.primary,
                            borderRadius: 20,
                            width: 40,
                            height: 40,
                            justifyContent: 'center',
                            alignItems: 'center',
                            marginRight: 8
                        }}
                        onPress={() => setIsImagePickerVisible(true)}
                    >
                        <Ionicons 
                            name="camera" 
                            size={20} 
                            color="#FFFFFF" 
                        />
                    </TouchableOpacity>
                    
                    <TextInput
                        style={{
                            flex: 1,
                            backgroundColor: currentColors.background,
                            borderRadius: 20,
                            paddingHorizontal: 16,
                            paddingVertical: 10,
                            marginRight: 8,
                            fontSize: 16,
                            color: currentColors.text,
                            maxHeight: 100,
                            borderWidth: 1,
                            borderColor: currentColors.lightGray
                        }}
                        value={newMessage}
                        onChangeText={setNewMessage}
                        placeholder="ë©”ì‹œì§€ë¥¼ ì…ë ¥í•˜ì„¸ìš”..."
                        placeholderTextColor={currentColors.textSecondary}
                        multiline
                        maxLength={500}
                    />
                    <TouchableOpacity
                        style={{
                            backgroundColor: !newMessage.trim() ? currentColors.lightGray : currentColors.primary,
                            borderRadius: 20,
                            width: 40,
                            height: 40,
                            justifyContent: 'center',
                            alignItems: 'center'
                        }}
                        onPress={sendMessage}
                        disabled={!newMessage.trim()}
                    >
                        <Ionicons 
                            name="send" 
                            size={20} 
                            color={!newMessage.trim() ? currentColors.textSecondary : '#FFFFFF'} 
                        />
                    </TouchableOpacity>
                </View>

                {/* ì—°ê²° ìƒíƒœ í‘œì‹œ (ì„ì‹œë¡œ ë¹„í™œì„±í™”) */}
                {false && !isConnected && (
                    <View style={{
                        backgroundColor: currentColors.warning,
                        paddingVertical: 8,
                        paddingHorizontal: 16,
                        alignItems: 'center'
                    }}>
                        <Text style={{color: '#FFFFFF', fontSize: 14, fontWeight: '600'}}>ì—°ê²° ì¤‘...</Text>
                    </View>
                )}

                {/* ì´ë¯¸ì§€ ì„ íƒ ëª¨ë‹¬ */}
                <Modal
                    visible={isImagePickerVisible}
                    transparent={true}
                    animationType="slide"
                    onRequestClose={() => setIsImagePickerVisible(false)}
                >
                    <View style={{
                        flex: 1,
                        backgroundColor: 'rgba(0, 0, 0, 0.5)',
                        justifyContent: 'flex-end'
                    }}>
                        <View style={{
                            backgroundColor: currentColors.surface,
                            borderTopLeftRadius: 20,
                            borderTopRightRadius: 20,
                            padding: 20
                        }}>
                            <Text style={{
                                fontSize: 18,
                                fontWeight: 'bold',
                                color: currentColors.text,
                                marginBottom: 20,
                                textAlign: 'center'
                            }}>
                                ì´ë¯¸ì§€ ì„ íƒ
                            </Text>
                            
                            <View style={{
                                flexDirection: 'row',
                                justifyContent: 'space-around',
                                marginBottom: 20
                            }}>
                                <TouchableOpacity
                                    style={{
                                        backgroundColor: currentColors.primary,
                                        borderRadius: 12,
                                        paddingVertical: 12,
                                        paddingHorizontal: 20,
                                        alignItems: 'center',
                                        flex: 1,
                                        marginRight: 10
                                    }}
                                    onPress={() => {
                                        setIsImagePickerVisible(false);
                                        // ì¹´ë©”ë¼ë¡œ ì´¬ì˜ (êµ¬í˜„ ì˜ˆì •)
                                        Alert.alert('ì¹´ë©”ë¼', 'ì¹´ë©”ë¼ ê¸°ëŠ¥ì€ ì¶”í›„ êµ¬í˜„ ì˜ˆì •ì…ë‹ˆë‹¤.');
                                    }}
                                >
                                    <Ionicons name="camera" size={24} color="#FFFFFF" />
                                    <Text style={{color: '#FFFFFF', marginTop: 4, fontSize: 12}}>ì¹´ë©”ë¼</Text>
                                </TouchableOpacity>
                                
                                <TouchableOpacity
                                    style={{
                                        backgroundColor: currentColors.primary,
                                        borderRadius: 12,
                                        paddingVertical: 12,
                                        paddingHorizontal: 20,
                                        alignItems: 'center',
                                        flex: 1,
                                        marginLeft: 10
                                    }}
                                    onPress={() => {
                                        setIsImagePickerVisible(false);
                                        // ê°¤ëŸ¬ë¦¬ì—ì„œ ì„ íƒ (êµ¬í˜„ ì˜ˆì •)
                                        Alert.alert('ê°¤ëŸ¬ë¦¬', 'ê°¤ëŸ¬ë¦¬ ì„ íƒ ê¸°ëŠ¥ì€ ì¶”í›„ êµ¬í˜„ ì˜ˆì •ì…ë‹ˆë‹¤.');
                                    }}
                                >
                                    <Ionicons name="images" size={24} color="#FFFFFF" />
                                    <Text style={{color: '#FFFFFF', marginTop: 4, fontSize: 12}}>ê°¤ëŸ¬ë¦¬</Text>
                                </TouchableOpacity>
                            </View>
                            
                            <TouchableOpacity
                                style={{
                                    backgroundColor: currentColors.gray,
                                    borderRadius: 12,
                                    paddingVertical: 12,
                                    alignItems: 'center'
                                }}
                                onPress={() => setIsImagePickerVisible(false)}
                            >
                                <Text style={{color: currentColors.white, fontSize: 16, fontWeight: '600'}}>ì·¨ì†Œ</Text>
                            </TouchableOpacity>
                        </View>
                    </View>
                </Modal>
            </KeyboardAvoidingView>
        </SafeAreaView>
    );
}

// --- ì˜¨ë³´ë”© í™”ë©´ ---
function OnboardingScreen() {
    const { user } = useAuth();
    const [currentStep, setCurrentStep] = useState(0);
    const [userPreferences, setUserPreferences] = useState({
        nickname: '',
        foodPreferences: [],
        lunchStyle: [],
        allergies: [],
        preferredTime: ''
    });
    const [nicknameError, setNicknameError] = useState('');
    const [checkingNickname, setCheckingNickname] = useState(false);
    const onboardingSteps = [
        {
            title: 'ë‹‰ë„¤ì„ ì„¤ì •',
            description: 'ì•±ì—ì„œ ì‚¬ìš©í•  ë‹‰ë„¤ì„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”',
            type: 'input',
            key: 'nickname'
        },
        {
            title: 'ì ì‹¬ ì„ í˜¸ë„ ì„¤ì •',
            description: 'ì¢‹ì•„í•˜ëŠ” ìŒì‹ ì¢…ë¥˜ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”',
            type: 'multiSelect',
            options: ['í•œì‹', 'ì¤‘ì‹', 'ì¼ì‹', 'ì–‘ì‹', 'ë¶„ì‹', 'ì¹´í˜', 'íŒ¨ìŠ¤íŠ¸í‘¸ë“œ'],
            key: 'foodPreferences'
        },
        {
            title: 'ì ì‹¬ ì„±í–¥',
            description: 'ë‹¹ì‹ ì˜ ì ì‹¬ ìŠ¤íƒ€ì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”',
            type: 'multiSelect',
            options: ['ê°€ì„±ë¹„ ì¢‹ì€ ê³³', 'ë§›ì§‘ íƒë°©', 'ê±´ê°•í•œ ì‹ì‚¬', 'ë¹ ë¥¸ ì‹ì‚¬', 'ìƒˆë¡œìš´ ë©”ë‰´ ë„ì „', 'ì¹œêµ¬ë“¤ê³¼ í•¨ê»˜', 'í˜¼ì ì¡°ìš©íˆ', 'ë¶„ìœ„ê¸° ì¢‹ì€ ê³³'],
            key: 'lunchStyle'
        },
        {
            title: 'ì•Œë ˆë¥´ê¸° ì •ë³´',
            description: 'ì•Œë ˆë¥´ê¸°ê°€ ìˆëŠ” ìŒì‹ì„ ì„ íƒí•´ì£¼ì„¸ìš”',
            type: 'multiSelect',
            options: ['ì—†ìŒ', 'ê°‘ê°ë¥˜', 'ê²¬ê³¼ë¥˜', 'ìš°ìœ ', 'ê³„ë€', 'ë°€', 'ëŒ€ë‘', 'ìƒì„ '],
            key: 'allergies'
        },
        {
            title: 'ì„ í˜¸ ì‹œê°„ëŒ€',
            description: 'ì£¼ë¡œ ì ì‹¬ì„ ë¨¹ëŠ” ì‹œê°„ëŒ€ë¥¼ ì„ íƒí•´ì£¼ì„¸ìš”',
            type: 'singleSelect',
            options: ['11:30', '11:45', '12:00', '12:15', '12:30'],
            key: 'preferredTime'
        }
    ];
    const handleNext = async () => {
        if (onboardingSteps[currentStep].key === 'nickname') {
            // ë‹‰ë„¤ì„ ì¤‘ë³µ ì²´í¬
            setCheckingNickname(true);
            setNicknameError('');
            const nickname = userPreferences.nickname.trim();
            if (!nickname) {
                setNicknameError('ë‹‰ë„¤ì„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                setCheckingNickname(false);
                return;
            }
            try {
                const res = await fetch(`${RENDER_SERVER_URL}/users/check-nickname?nickname=${encodeURIComponent(nickname)}`);
                const data = await res.json();
                if (data.exists) {
                    setNicknameError('ì´ë¯¸ ì‚¬ìš© ì¤‘ì¸ ë‹‰ë„¤ì„ì…ë‹ˆë‹¤. ë‹¤ë¥¸ ë‹‰ë„¤ì„ì„ ì…ë ¥í•´ì£¼ì„¸ìš”.');
                    setCheckingNickname(false);
                    return;
                }
            } catch (e) {
                setNicknameError('ë‹‰ë„¤ì„ ì¤‘ë³µ í™•ì¸ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.');
                setCheckingNickname(false);
                return;
            }
            setCheckingNickname(false);
        }
        if (currentStep < onboardingSteps.length - 1) {
            setCurrentStep(currentStep + 1);
        } else {
            // ì˜¨ë³´ë”© ì™„ë£Œ, ì‚¬ìš©ì ì„¤ì • ì €ì¥
            await saveUserPreferences();
            // AsyncStorageì— ì˜¨ë³´ë”© ì™„ë£Œ ìƒíƒœ ì €ì¥
            await AsyncStorage.setItem('onboardingCompleted', 'true');
            global.hasCompletedOnboarding = true;
            
            // ì˜¨ë³´ë”© ì™„ë£Œ í›„ ë©”ì¸ ì•±ìœ¼ë¡œ ì´ë™
            // AsyncStorageì— ì˜¨ë³´ë”© ì™„ë£Œ ìƒíƒœê°€ ì €ì¥ë˜ì—ˆìœ¼ë¯€ë¡œ 
            // MainAppì˜ useEffectì—ì„œ ìë™ìœ¼ë¡œ hasCompletedOnboardingì´ trueë¡œ ì„¤ì •ë¨
        }
    };
    const handleBack = () => {
        if (currentStep > 0) {
            setCurrentStep(currentStep - 1);
        }
    };
    const handleOptionSelect = (option) => {
        const currentKey = onboardingSteps[currentStep].key;
        const currentStepData = onboardingSteps[currentStep];
        if (currentStepData.type === 'multiSelect') {
            setUserPreferences(prev => ({
                ...prev,
                [currentKey]: prev[currentKey].includes(option)
                    ? prev[currentKey].filter(item => item !== option)
                    : [...prev[currentKey], option]
            }));
        } else {
            setUserPreferences(prev => ({
                ...prev,
                [currentKey]: option
            }));
        }
    };
    const saveUserPreferences = async () => {
        try {
            // ì‚¬ìš©ì ê¸°ë³¸ ì •ë³´ ì €ì¥
            const userData = {
                nickname: userPreferences.nickname,
                lunch_preference: userPreferences.lunchStyle?.join(', ') || '',
                main_dish_genre: userPreferences.foodPreferences?.join(', ') || '',
                main_dish: userPreferences.foodPreferences?.join(', ') || '', // ì£¼ì¢…ëª©ìœ¼ë¡œ ìŒì‹ ì„ í˜¸ë„ ì €ì¥
            };
            await fetch(`${RENDER_SERVER_URL}/users/${user.employee_id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(userData)
            });
            // ì‚¬ìš©ì ì„ í˜¸ë„ ì •ë³´ ì €ì¥
            const preferencesData = {
                foodPreferences: userPreferences.foodPreferences || [],
                allergies: userPreferences.allergies || [],
                preferredTime: userPreferences.preferredTime || '',
                frequentAreas: []
            };
            await fetch(`${RENDER_SERVER_URL}/users/${user.employee_id}/preferences`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(preferencesData)
            });
            
            // AsyncStorageì— ì˜¨ë³´ë”© ì™„ë£Œ ìƒíƒœ ì €ì¥
            await AsyncStorage.setItem('onboardingCompleted', 'true');
            global.hasCompletedOnboarding = true;
        } catch (error) {
            console.error('ì‚¬ìš©ì ì„¤ì • ì €ì¥ ì‹¤íŒ¨:', error);
        }
    };
    const currentStepData = onboardingSteps[currentStep];
    const selectedOptions = userPreferences[currentStepData.key] || [];
    return (
        <SafeAreaView style={{flex: 1, backgroundColor: COLORS.light.background}}>
            <View style={{padding: 20, alignItems: 'center'}}>
                <View style={{flexDirection: 'row', marginBottom: 20}}>
                    {onboardingSteps.map((_, index) => (
                        <View
                            key={index}
                            style={{
                                width: 8,
                                height: 8,
                                borderRadius: 4,
                                backgroundColor: index <= currentStep ? COLORS.light.primary : COLORS.light.lightGray,
                                marginHorizontal: 4
                            }}
                        />
                    ))}
                </View>
                <Text style={{color: COLORS.light.textSecondary, fontSize: 14}}>
                    {currentStep + 1} / {onboardingSteps.length}
                </Text>
            </View>
            <View style={{flex: 1, padding: 20}}>
                <Text style={{fontSize: 24, fontWeight: 'bold', color: COLORS.light.text, marginBottom: 10, textAlign: 'center'}}>{currentStepData.title}</Text>
                <Text style={{fontSize: 16, color: COLORS.light.textSecondary, marginBottom: 30, textAlign: 'center'}}>{currentStepData.description}</Text>
                {currentStepData.type === 'input' ? (
                    <View style={{alignItems: 'center'}}>
                        <TextInput
                            style={{
                                width: '100%',
                                borderWidth: 1,
                                borderColor: nicknameError ? COLORS.red : COLORS.light.border,
                                borderRadius: 12,
                                padding: 16,
                                fontSize: 18,
                                marginBottom: 8,
                                color: COLORS.light.text,
                                backgroundColor: '#FFFFFF'
                            }}
                            placeholder="ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”"
                            placeholderTextColor={COLORS.light.textSecondary}
                            value={userPreferences.nickname}
                            onChangeText={text => setUserPreferences(prev => ({ ...prev, nickname: text }))}
                            editable={!checkingNickname}
                        />
                        {nicknameError ? <Text style={{color: COLORS.red, marginBottom: 8}}>{nicknameError}</Text> : null}
                    </View>
                ) : (
                    <ScrollView style={{flex: 1}} showsVerticalScrollIndicator={false}>
                        {currentStepData.options.map((option) => (
                            <TouchableOpacity
                                key={option}
                                style={{
                                    backgroundColor: selectedOptions.includes(option) ? COLORS.light.primary : COLORS.light.surface,
                                    padding: 16,
                                    borderRadius: 12,
                                    marginBottom: 10,
                                    flexDirection: 'row',
                                    justifyContent: 'space-between',
                                    alignItems: 'center',
                                    borderWidth: 1,
                                    borderColor: selectedOptions.includes(option) ? COLORS.light.primary : COLORS.light.border
                                }}
                                onPress={() => handleOptionSelect(option)}
                            >
                                <Text style={{
                                    fontSize: 16,
                                    color: selectedOptions.includes(option) ? COLORS.light.surface : COLORS.light.text
                                }}>
                                    {option}
                                </Text>
                                {selectedOptions.includes(option) && (
                                    <Ionicons name="checkmark-circle" size={20} color={COLORS.light.surface} />
                                )}
                            </TouchableOpacity>
                        ))}
                    </ScrollView>
                )}
            </View>
            <View style={{flexDirection: 'row', justifyContent: 'space-between', padding: 20, backgroundColor: COLORS.light.surface}}>
                {currentStep > 0 && (
                    <TouchableOpacity style={{padding: 12, borderRadius: 8, borderWidth: 1, borderColor: COLORS.light.border}} onPress={handleBack}>
                        <Text style={{fontSize: 16, color: COLORS.light.textSecondary}}>ì´ì „</Text>
                    </TouchableOpacity>
                )}
                <TouchableOpacity style={{padding: 12, borderRadius: 8, backgroundColor: COLORS.light.primary, flex: 1, marginLeft: currentStep > 0 ? 12 : 0, alignItems: 'center'}} onPress={handleNext} disabled={checkingNickname}>
                    <Text style={{fontSize: 16, color: COLORS.light.surface, fontWeight: 'bold'}}>{currentStep === onboardingSteps.length - 1 ? 'ì™„ë£Œ' : 'ë‹¤ìŒ'}</Text>
                </TouchableOpacity>
            </View>
        </SafeAreaView>
    );
}

// Stack Navigatorë“¤ ì •ì˜
const commonScreenOptions = {
    headerStyle: { backgroundColor: COLORS.light.primary },
    headerTintColor: '#fff',
    headerTitleStyle: { fontWeight: 'bold' }
};

const HomeStack = () => (
    <Stack.Navigator screenOptions={commonScreenOptions}>
        <Stack.Screen 
            name="HomeScreen" 
            component={HomeScreen} 
            options={({ navigation, route }) => ({
                title: 'ë°¥í”Œë–¼ê¸°',
                headerLeft: () => (
                    <TouchableOpacity 
                        style={{ marginLeft: 15, position: 'relative' }} 
                        onPress={() => {
                            // í™ˆ í™”ë©´ìœ¼ë¡œ ì´ë™í•˜ì—¬ ë¯¸ì…˜ ëª¨ë‹¬ì„ ì—´ê¸°
                            navigation.navigate('HomeScreen', { openMissionModal: true });
                        }}
                    >
                        <Ionicons name="trophy-outline" size={24} color={'#fff'} />
                        {/* ë¯¸ì…˜ ì™„ë£Œ í›„ ìˆ˜ë ¹í•˜ì§€ ì•Šì€ ë¯¸ì…˜ì´ ìˆì„ ë•Œ ë¹¨ê°„ ì  í‘œì‹œ */}
                        {route.params?.hasUnclaimedMissions && (
                            <View style={{
                                position: 'absolute',
                                top: -2,
                                right: -2,
                                width: 8,
                                height: 8,
                                borderRadius: 4,
                                backgroundColor: '#EF4444'
                            }} />
                        )}
                    </TouchableOpacity>
                ),
                headerRight: () => (
                    <View style={{ flexDirection: 'row', marginRight: 15 }}>
                        <TouchableOpacity 
                            style={{ marginRight: 15 }} 
                            onPress={() => {
                                // ë§ˆì´í˜ì´ì§€ë¡œ ì´ë™
                                safeNavigateToTab(navigation, 'ì¹œêµ¬', 'MyPageMain');
                            }}
                        >
                            <Ionicons name="person-circle-outline" size={24} color={'#fff'} />
                        </TouchableOpacity>
                        <TouchableOpacity 
                            onPress={() => safeNavigateToTab(navigation, 'ì†Œí†µ', 'Notifications')}
                            style={{ position: 'relative' }}
                        >
                            <Ionicons name="notifications-outline" size={24} color={'#fff'} />
                            {route.params?.unreadCount > 0 && (
                                <View style={{
                                    position: 'absolute',
                                    top: -5,
                                    right: -5,
                                    backgroundColor: '#EF4444',
                                    borderRadius: 10,
                                    minWidth: 20,
                                    height: 20,
                                    justifyContent: 'center',
                                    alignItems: 'center',
                                    paddingHorizontal: 4,
                                }}>
                                    <Text style={{
                                        color: '#fff',
                                        fontSize: 12,
                                        fontWeight: 'bold',
                                    }}>
                                        {route.params.unreadCount > 99 ? '99+' : route.params.unreadCount}
                                    </Text>
                                </View>
                            )}
                        </TouchableOpacity>
                    </View>
                )
            })}
        />
    </Stack.Navigator>
);

const RestaurantStack = () => (
    <Stack.Navigator screenOptions={commonScreenOptions}>
        <Stack.Screen name="RestaurantsList" component={RestaurantTab} options={{ headerShown: false }}/>
        
        <Stack.Screen name="WriteReview" component={WriteReview} options={{ title: 'ë¦¬ë·° ì‘ì„±' }} />
        <Stack.Screen name="PhotoGallery" component={PhotoGallery} options={{ headerShown: false }} />
    </Stack.Navigator>
);

const PartiesStack = () => (
    <Stack.Navigator screenOptions={commonScreenOptions}>
        <Stack.Screen name="PartiesScreen" component={PartiesContainerScreen} options={{ title: 'íŒŒí‹°' }}/>
        <Stack.Screen name="PartyDetail" component={PartyDetailScreen} options={{ title: 'íŒŒí‹° ì •ë³´' }}/>
        <Stack.Screen name="CreateParty" component={CreatePartyScreen} options={{ title: 'ìƒˆ íŒŒí‹° ë§Œë“¤ê¸°' }}/>
        <Stack.Screen name="CreatePersonalSchedule" component={CreatePersonalScheduleScreen} options={{ title: 'ê¸°íƒ€ ì¼ì • ì¶”ê°€' }} />
        <Stack.Screen name="SearchUsers" component={SearchUsersScreen} options={{ title: 'ì¹œêµ¬ ì°¾ê¸°' }} />
                
        <Stack.Screen name="EditPersonalSchedule" component={EditPersonalScheduleScreen} options={{ title: 'ê¸°íƒ€ ì¼ì • ìˆ˜ì •' }} />
        <Stack.Screen name="EditParty" component={EditPartyScreen} options={{ title: 'íŒŒí‹° ì •ë³´ ìˆ˜ì •' }} />
        <Stack.Screen name="RandomLunch" component={RandomLunchScreen} options={{ title: 'ëœë¤ ëŸ°ì¹˜' }} />
        <Stack.Screen name="IntelligentScheduling" component={IntelligentSchedulingScreen} options={{ title: 'ì§€ëŠ¥í˜• ìŠ¤ì¼€ì¤„ë§' }} />
        <Stack.Screen name="SuggestedDatesScreen" component={SuggestedDatesScreen} options={{ title: 'ì œì•ˆëœ ë‚ ì§œ' }} />
        <Stack.Screen name="RestaurantSelectionScreen" component={RestaurantSelectionScreen} options={{ title: 'ì‹ë‹¹ ì„ íƒ' }} />
        <Stack.Screen name="TimeSelectionScreen" component={TimeSelectionScreen} options={{ title: 'ì‹œê°„ ì„ íƒ' }} />
        <Stack.Screen name="PartyConfirmationScreen" component={PartyConfirmationScreen} options={{ title: 'íŒŒí‹° í™•ì •' }} />
        <Stack.Screen name="VotingScreen" component={VotingScreen} options={{ title: 'íˆ¬í‘œ' }} />
        <Stack.Screen name="VotingParticipateScreen" component={VotingParticipateScreen} options={{ title: 'íˆ¬í‘œ ì°¸ì—¬' }} />
        <Stack.Screen name="VotingEditScreen" component={VotingEditScreen} options={{ title: 'íˆ¬í‘œ ìˆ˜ì •' }} />
        <Stack.Screen name="FriendProfile" component={FriendProfileScreen} options={{ title: 'ë™ë£Œ í”„ë¡œí•„' }} />
        <Stack.Screen name="UserProfile" component={UserProfileScreen} options={{ title: 'ì‚¬ìš©ì í”„ë¡œí•„' }} />
    </Stack.Navigator>
);

const CommunicationStack = () => (
    <Stack.Navigator screenOptions={commonScreenOptions}>
        <Stack.Screen name="ChatList" component={ChatListScreen} options={{ title: 'ì†Œí†µ' }}/>
        <Stack.Screen name="ChatRoom" component={ChatRoomScreen} options={({ route }) => ({ title: route.params?.chatTitle || 'ì±„íŒ…' })} />
        <Stack.Screen name="CreateChatRoom" component={CreateChatRoomScreen} options={{ title: 'ì±„íŒ…ë°© ë§Œë“¤ê¸°' }} />
        <Stack.Screen name="Notifications" component={NotificationScreen} options={{ title: 'ì•Œë¦¼' }}/>
        <Stack.Screen name="ReviewDetail" component={ReviewDetailScreen} options={{ title: 'ë¦¬ë·° ìƒì„¸' }}/>
    </Stack.Navigator>
);

const FriendStack = () => {
    const { colors } = useTheme();
    return (
        <Stack.Navigator screenOptions={commonScreenOptions}>
            <Stack.Screen 
                name="FriendMain" 
                component={FriendMainScreen} 
                options={({ navigation, route }) => ({
                    title: 'ì¹œêµ¬',
                    headerRight: () => (
                        <View style={{ flexDirection: 'row', marginRight: 15 }}>
                            <TouchableOpacity 
                                style={{ marginRight: 15 }} 
                                onPress={() => {
                                    navigation.setParams({ toggleSearch: true });
                                }}
                            >
                                <Ionicons name="search" size={26} color={'#fff'} />
                            </TouchableOpacity>
                            <TouchableOpacity 
                                onPress={() => Alert.alert('ì„¤ì •', 'ì„¤ì • ê¸°ëŠ¥ì€ ê³§ ì¶œì‹œë©ë‹ˆë‹¤!')}
                            >
                                <Ionicons name="settings-outline" size={26} color={'#fff'} />
                            </TouchableOpacity>
                        </View>
                    )
                })} 
            />
            <Stack.Screen name="FriendList" component={FriendListScreen} options={{ title: 'ì¹œêµ¬ ëª©ë¡' }}/>
            <Stack.Screen name="SearchUsers" component={SearchUsersScreen} options={{ title: 'ì¹œêµ¬ ì°¾ê¸°' }}/>
            <Stack.Screen name="FriendProfile" component={FriendProfileScreen} options={{ title: 'ì¹œêµ¬ í”„ë¡œí•„' }}/>
            <Stack.Screen name="UserProfile" component={UserProfileScreen} options={{ title: 'ì‚¬ìš©ì í”„ë¡œí•„' }}/>
            <Stack.Screen name="MyProfile" component={MyProfileScreen} options={{ title: 'ë‚´ í”„ë¡œí•„' }}/>
            <Stack.Screen name="ProfileSection" component={ProfileSection} options={{ title: 'í”„ë¡œí•„' }}/>
            <Stack.Screen name="ProfileEdit" component={ProfileEditScreen} options={{ title: 'í”„ë¡œí•„ ìˆ˜ì •' }}/>
            <Stack.Screen name="RankingScreen" component={RankingScreen} options={{ title: 'ë­í‚¹' }}/>
            <Stack.Screen name="MyPageMain" component={MyPageMain} options={{ title: 'ë§ˆì´í˜ì´ì§€' }}/>
            <Stack.Screen name="LevelSystemScreen" component={LevelSystemScreen} options={{ title: 'ë ˆë²¨ ì‹œìŠ¤í…œ' }}/>
            <Stack.Screen name="ChallengesScreen" component={ChallengesScreen} options={{ title: 'ë„ì „ê³¼ì œ' }}/>
            <Stack.Screen name="FriendInvite" component={FriendInviteScreen} options={{ title: 'ì¹œêµ¬ ì´ˆëŒ€' }}/>
        </Stack.Navigator>
    );
};

// ë©”ì¸ íƒ­ ë„¤ë¹„ê²Œì´í„° ì»´í¬ë„ŒíŠ¸
function TabNavigator() {
    const { colors } = useTheme();
    const { hasUnclaimedMissions } = useMission();
    
    return (
        <Tab.Navigator screenOptions={({ route }) => ({
            tabBarIcon: ({ focused, color, size }) => {
                const icons = { 'í™ˆ': 'home', 'ë§›ì§‘': 'restaurant', 'íŒŒí‹°': 'people', 'ì†Œí†µ': 'chatbubbles', 'ì¹œêµ¬': 'people-circle' };
                const iconName = focused ? icons[route.name] : `${icons[route.name]}-outline`;
                
                // í™ˆíƒ­ì— ë¯¸ì…˜ ì•Œë¦¼ ì  ì¶”ê°€
                if (route.name === 'í™ˆ' && hasUnclaimedMissions) {
                    return (
                        <View style={{ position: 'relative' }}>
                            <Ionicons name={iconName} size={size} color={color} />
                            <View style={{
                                position: 'absolute',
                                top: -2,
                                right: -2,
                                width: 8,
                                height: 8,
                                borderRadius: 4,
                                backgroundColor: '#EF4444',
                                borderWidth: 1,
                                borderColor: colors.surface
                            }} />
                        </View>
                    );
                }
                
                return <Ionicons name={iconName} size={size} color={color} />;
            },
            tabBarActiveTintColor: colors.primary,
            tabBarInactiveTintColor: colors.gray,
            headerShown: false,
            tabBarStyle: { 
                backgroundColor: colors.surface, 
                borderTopColor: colors.lightGray,
                height: 85,
                paddingBottom: 18,
                paddingTop: 10,
                elevation: 8,
                shadowColor: colors.primary,
                shadowOffset: { width: 0, height: -2 },
                shadowOpacity: 0.1,
                shadowRadius: 4
            },
            tabBarLabelStyle: { fontWeight: '600', fontSize: 12, marginTop: 2 },
            tabBarIconStyle: { marginBottom: 4 }
        })}>
            <Tab.Screen name="í™ˆ" component={HomeStack} />
            <Tab.Screen name="ë§›ì§‘" component={RestaurantStack} />
            <Tab.Screen name="íŒŒí‹°" component={PartiesStack} />
            <Tab.Screen name="ì†Œí†µ" component={CommunicationStack} />
            <Tab.Screen name="ì¹œêµ¬" component={FriendStack} />
        </Tab.Navigator>
    );
}

// ë©”ì¸ ì•± í™”ë©´ ì»´í¬ë„ŒíŠ¸
function MainApp() {
    const [hasCompletedOnboarding, setHasCompletedOnboarding] = useState(false);
    const { authState, user } = useAuth();

    useEffect(() => {
        checkOnboardingStatus();
        
        // ì£¼ê¸°ì ìœ¼ë¡œ ì˜¨ë³´ë”© ìƒíƒœ í™•ì¸ (1ì´ˆë§ˆë‹¤)
        const interval = setInterval(() => {
            checkOnboardingStatus();
        }, 1000);
        
        return () => {
            clearInterval(interval);
        };
    }, []);

    const checkOnboardingStatus = async () => {
        try {
            const onboardingCompleted = await AsyncStorage.getItem('onboardingCompleted');
            if (onboardingCompleted === 'true') {
                setHasCompletedOnboarding(true);
            }
        } catch (error) {
            console.error('ì˜¨ë³´ë”© ìƒíƒœ í™•ì¸ ì˜¤ë¥˜:', error);
        }
    };

    // ë¡œë”© ì¤‘
    if (authState === 'loading') {
    return (
            <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
                <ActivityIndicator size="large" color="#3B82F6" />
                <Text style={{ marginTop: 10 }}>ë¡œë”© ì¤‘...</Text>
            </View>
        );
    }

    // ì¸ì¦ë˜ì§€ ì•Šì€ ê²½ìš° ë¡œê·¸ì¸ í™”ë©´
    if (authState === 'unauthenticated') {
        return <LoginScreen />;
    }

    // ì˜¨ë³´ë”©ì´ ì™„ë£Œë˜ì§€ ì•Šì€ ê²½ìš° ì˜¨ë³´ë”© í™”ë©´
    if (!hasCompletedOnboarding) {
        return <OnboardingScreen />;
    }

    // ë©”ì¸ ì•± í™”ë©´ - NavigationContainerë¡œ ê°ì‹¸ì„œ TabNavigator ì‚¬ìš©
    return (
        <NavigationContainer>
            <TabNavigator />
        </NavigationContainer>
    );
}

// ë©”ì¸ App ì»´í¬ë„ŒíŠ¸
export default function App() {
    return (
        <AuthProvider>
        <ThemeProvider>
            <UserProvider>
                <PointsProvider>
                    <MissionProvider>
                        <AppointmentProvider>
                            <ScheduleProvider>
                                    <MainApp />
                            </ScheduleProvider>
                        </AppointmentProvider>
                    </MissionProvider>
                </PointsProvider>
            </UserProvider>
        </ThemeProvider>
        </AuthProvider>
    );
}

// --- ì „ì—­ ìŠ¤íƒ€ì¼ ì •ì˜ ---
const styles = StyleSheet.create({
    safeArea: { flex: 1, backgroundColor: COLORS.light.background },
    centerView: { flex: 1, justifyContent: 'center', alignItems: 'center', padding: 20, backgroundColor: COLORS.light.background },
    homeContainer: { paddingTop: 10 },
    header: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', paddingHorizontal: 16, paddingTop: 10, paddingBottom: 10, backgroundColor: COLORS.light.background },
    headerTitle: { fontSize: 32, fontWeight: 'bold', color: COLORS.light.primary, textAlign: 'center', width: '100%', letterSpacing: 1 },
    card: { 
        backgroundColor: COLORS.light.surface, 
        borderRadius: 20, 
        padding: 20, 
        marginHorizontal: 16, 
        marginBottom: 16, 
        elevation: 3, 
        shadowColor: COLORS.light.primary,
        shadowOffset: { width: 0, height: 4 }, 
        shadowOpacity: 0.1, 
        shadowRadius: 8,
        borderWidth: 1,
        borderColor: 'rgba(59, 130, 246, 0.1)'
    },
    cardTitle: { fontSize: 18, fontWeight: 'bold', color: COLORS.light.text, marginBottom: 12 },
    menuText: { fontSize: 16, color: COLORS.light.textSecondary, lineHeight: 22 },
    appointmentCard: { 
        backgroundColor: COLORS.light.surface, 
        borderRadius: 12, 
        padding: 18, 
        paddingVertical: 40,
        marginRight: 12,
        marginBottom: 5, 
        width: 220,
        minHeight: 160,
        alignItems: 'flex-start',
        borderLeftWidth: 4, 
        borderLeftColor: COLORS.light.primary,
        elevation: 2,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 3
    },
    appointmentDate: { fontSize: 16, fontWeight: 'bold', color: COLORS.light.primary, marginBottom: 8 },
    appointmentHeader: { 
        alignSelf: 'flex-start', 
        marginBottom: 12,
        position: 'absolute',
        top: 20,
        left: 20
    },
    eventItem: { marginBottom: 8 },
    eventTitle: { fontSize: 14, fontWeight: '600', color: COLORS.light.text, marginBottom: 4 },
    eventDetail: { fontSize: 12, color: COLORS.light.textSecondary, marginBottom: 2 },
    noAppointmentText: { fontSize: 14, color: COLORS.light.textSecondary, textAlign: 'center', fontStyle: 'italic' },
    modalDetailCard: { 
        backgroundColor: COLORS.light.background, 
        borderRadius: 12, 
        padding: 16, 
        marginBottom: 12,
        borderWidth: 1,
        borderColor: COLORS.light.border
    },
    modalDetailText: { fontSize: 14, color: COLORS.light.text, marginBottom: 4, lineHeight: 20 },
    // ì±„íŒ… ê´€ë ¨ ìŠ¤íƒ€ì¼
    messageContainer: { marginVertical: 4, paddingHorizontal: 8 },
    myMessage: { alignItems: 'flex-end' },
    otherMessage: { alignItems: 'flex-start' },
    messageBubble: { 
        maxWidth: '80%', 
        padding: 12, 
        borderRadius: 16,
        elevation: 1,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 1 },
        shadowOpacity: 0.1,
        shadowRadius: 2
    },
    myMessageBubble: { 
        backgroundColor: COLORS.light.primary,
        borderBottomRightRadius: 4
    },
    otherMessageBubble: { 
        backgroundColor: COLORS.light.surface,
        borderBottomLeftRadius: 4
    },
    messageText: { fontSize: 16, lineHeight: 20 },
    myMessageText: { color: '#FFFFFF' },
    otherMessageText: { color: COLORS.light.text },
    messageSender: { fontSize: 12, color: COLORS.light.textSecondary, marginBottom: 4 },
    messageTime: { fontSize: 11, color: COLORS.light.gray, marginTop: 2 },
    // ì…ë ¥ ê´€ë ¨ ìŠ¤íƒ€ì¼
    input: {
        backgroundColor: COLORS.light.surface,
        borderRadius: 12,
        paddingHorizontal: 16,
        paddingVertical: 12,
        fontSize: 16,
        color: COLORS.light.text,
        borderWidth: 1,
        borderColor: COLORS.light.border,
        marginBottom: 16
    },
    inputLabel: { fontSize: 16, fontWeight: '600', color: COLORS.light.text, marginBottom: 8 },
    submitButton: {
        backgroundColor: COLORS.light.primary,
        borderRadius: 12,
        paddingVertical: 16,
        alignItems: 'center',
        marginTop: 20
    },
    submitButtonText: { fontSize: 16, fontWeight: 'bold', color: '#FFFFFF' },
    // ì ì‹¬ ì•½ì† ì˜µì…˜ ëª¨ë‹¬ ìŠ¤íƒ€ì¼
    appointmentOptionsContainer: {
        width: '100%',
        gap: 12
    },
    appointmentOptionButton: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
        padding: 20,
        borderRadius: 16,
        elevation: 2,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4
    },
    optionContent: {
        flex: 1,
        marginRight: 12
    },
    optionTitle: {
        fontSize: 18,
        fontWeight: 'bold',
        marginBottom: 4
    },
    optionSubtitle: {
        fontSize: 14,
        opacity: 0.8,
        lineHeight: 18
    },
    modalView: { 
        margin: 20, 
        backgroundColor: 'white', 
        borderRadius: 24, 
        padding: 30, 
        alignItems: 'center', 
        width: '90%', 
        maxWidth: 400, 
        shadowColor: '#000', 
        shadowOffset: { width: 0, height: 8 }, 
        shadowOpacity: 0.3, 
        shadowRadius: 12, 
        elevation: 8 
    },
    centeredView: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
    },
    modalTitle: {
        fontSize: 20,
        fontWeight: 'bold',
        marginBottom: 20,
        color: COLORS.light.text,
    },
});
