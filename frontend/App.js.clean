import React, { useState, useEffect, useCallback, useRef, useMemo, createContext, useContext } from 'react';
import { Text, View, StyleSheet, FlatList, ActivityIndicator, TouchableOpacity, TextInput, SafeAreaView, Alert, Modal, Pressable, ScrollView, Dimensions, KeyboardAvoidingView, Platform, Switch, Image, RefreshControl } from 'react-native';
import { NavigationContainer, useFocusEffect, useNavigationState } from '@react-navigation/native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { createMaterialTopTabNavigator } from '@react-navigation/material-top-tabs';
import { createStackNavigator } from '@react-navigation/stack';
import Ionicons from 'react-native-vector-icons/Ionicons';
import { Calendar, LocaleConfig } from 'react-native-calendars';
import MapView, { Marker } from 'react-native-maps';
import DateTimePicker from '@react-native-community/datetimepicker';
import io from 'socket.io-client';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { RENDER_SERVER_URL } from './config';
import { getKoreanToday } from './components/common/Utils';
import RestaurantTab from './screens/RestaurantTab';
import ScheduleDetailModal from './components/schedule/ScheduleDetailModal';

import WriteReview from './screens/WriteReview';
import PhotoGallery from './screens/PhotoGallery';

import MyPageMain from './screens/MyPage/MyPageMain';
import PointsBadgesSection from './screens/MyPage/PointsBadgesSection';
import PointsStatus from './screens/PointsBadges/PointsStatus';
import PointsHistory from './screens/PointsBadges/PointsHistory';
import BadgeCollection from './screens/PointsBadges/BadgeCollection';
import AppointmentHistorySection from './screens/MyPage/AppointmentHistorySection';
import AppointmentDetail from './screens/MyPage/AppointmentDetail';
import ActivityStatsSection from './screens/MyPage/ActivityStatsSection';
import MissionModal from './components/MissionModal';
import ProfileSection from './screens/MyPage/ProfileSection';
import AppInfoSection from './screens/MyPage/AppInfoSection';
import AccountManagement from './screens/ProfileSettings/AccountManagement';
import PrivacySettings from './screens/ProfileSettings/PrivacySettings';
import NotificationSettings from './screens/ProfileSettings/NotificationSettings';

import { ThemeProvider, useTheme } from './contexts/ThemeContext';
import { UserProvider } from './contexts/UserContext';
import { PointsProvider, usePoints } from './contexts/PointsContext';
import { MissionProvider, useMission } from './contexts/MissionContext';
import { AppointmentProvider } from './contexts/AppointmentContext';
import { ScheduleProvider } from './contexts/ScheduleContext';
import dataCleanupManager from './utils/DataCleanupManager';

// 인증 관련
import { AuthProvider, useAuth, AUTH_STATES } from './auth/AuthContext';
import LoginScreen from './auth/LoginScreen';

// --- 추가 화면 컴포넌트 Import ---
import PartyDetailScreen from './screens/Party/PartyDetail/PartyDetailScreen';
import CreatePartyScreen from './screens/Party/CreateParty/CreatePartyScreen';
import CreatePersonalScheduleScreen from './screens/Schedule/CreatePersonalSchedule/CreatePersonalScheduleScreen';

import EditPersonalScheduleScreen from './screens/Schedule/EditPersonalSchedule/EditPersonalScheduleScreen';
import EditPartyScreen from './screens/Party/EditParty/EditPartyScreen';
import RandomLunchScreen from './screens/Party/RandomLunch/RandomLunchScreen';
import IntelligentSchedulingScreen from './screens/Voting/IntelligentScheduling/IntelligentSchedulingScreen';
import SuggestedDatesScreen from './screens/Voting/SuggestedDates/SuggestedDatesScreen';
import RestaurantSelectionScreen from './screens/Voting/RestaurantSelection/RestaurantSelectionScreen';
import TimeSelectionScreen from './screens/Voting/TimeSelection/TimeSelectionScreen';
import PartyConfirmationScreen from './screens/Voting/PartyConfirmation/PartyConfirmationScreen';
import VotingScreen from './screens/Voting/VotingScreen';
import VotingParticipateScreen from './screens/Voting/VotingParticipate/VotingParticipateScreen';
import VotingEditScreen from './screens/Voting/VotingEdit/VotingEditScreen';
import CreateChatRoomScreen from './screens/Chat/CreateChatRoom/CreateChatRoomScreen';
import NotificationScreen from './screens/Notification/NotificationScreen';
import ReviewDetailScreen from './screens/Review/ReviewDetail/ReviewDetailScreen';
import FriendMainScreen from './screens/Friend/FriendMain/FriendMainScreen';
import FriendListScreen from './screens/Friend/FriendList/FriendListScreen';
import SearchUsersScreen from './screens/Friend/SearchUsers/SearchUsersScreen';
import FriendProfileScreen from './screens/Friend/FriendProfile/FriendProfileScreen';
import UserProfileScreen from './screens/profile/UserProfileScreen';
import MyProfileScreen from './screens/MyPage/MyProfile/MyProfileScreen';
import ProfileEditScreen from './screens/MyPage/ProfileEdit/ProfileEditScreen';
import RankingScreen from './screens/RankingScreen';
import LevelSystemScreen from './screens/MyPage/LevelSystemScreen';
import ChallengesScreen from './screens/Challenges/ChallengesScreen';
import FriendInviteScreen from './screens/FriendInvite/FriendInviteScreen';

// API_BASE_URL과 API 호출 함수 정의
const API_BASE_URL = RENDER_SERVER_URL;

// 탭 간 이동 시 네비게이션 스택 문제를 해결하기 위한 함수
const safeNavigateToTab = (navigation, tabName, screenName, params = {}, skipDefaultScreen = false) => {
    try {
        // navigation 객체가 유효한지 확인
        if (!navigation || typeof navigation.navigate !== 'function') {
            console.warn('safeNavigateToTab: 유효하지 않은 navigation 객체입니다.');
            return false;
        }

        // 필수 매개변수 확인
        if (!tabName) {
            console.warn('safeNavigateToTab: tabName이 필요합니다.');
            return false;
        }

        // 각 탭의 기본 스크린 매핑
        const tabDefaultScreens = {
            '홈': 'HomeScreen',
            '맛집': 'RestaurantsList',
            '파티': 'PartiesScreen',
            '소통': 'ChatList',
            '친구': 'FriendMain'
        };

        const defaultScreen = tabDefaultScreens[tabName];
        
        if (!defaultScreen || skipDefaultScreen) {
            // 기본 스크린이 정의되지 않거나 건너뛰기 옵션이 있는 경우 직접 이동
            try {
                navigation.navigate(tabName, { screen: screenName, params });
                console.log(`✅ 직접 네비게이션 성공: ${tabName} -> ${screenName}`);
                return true;
            } catch (error) {
                console.warn('safeNavigateToTab: 직접 네비게이션 실패:', error);
                return false;
            }
        }

        // 안전한 네비게이션을 위한 단계별 처리
        try {
            // 1단계: 해당 탭의 기본 스크린으로 먼저 이동 (스택 초기화)
            navigation.navigate(tabName, { screen: defaultScreen });
            console.log(`✅ 1단계 네비게이션 성공: ${tabName} -> ${defaultScreen}`);
            
            // 2단계: 즉시 원하는 스크린으로 이동 (setTimeout 제거)
            try {
                navigation.navigate(tabName, { screen: screenName, params });
                console.log(`✅ 2단계 네비게이션 성공: ${tabName} -> ${screenName}`);
            } catch (error) {
                console.warn('safeNavigateToTab: 2단계 네비게이션 실패:', error);
                // 2단계 실패 시 fallback으로 직접 이동 시도
                try {
                    navigation.navigate(tabName, { screen: screenName, params });
                    console.log(`✅ fallback 네비게이션 성공: ${tabName} -> ${screenName}`);
                } catch (fallbackError) {
                    console.error('safeNavigateToTab: 모든 네비게이션 방법 실패:', fallbackError);
                }
            }
            
            return true;
        } catch (error) {
            console.warn('safeNavigateToTab: 1단계 네비게이션 실패:', error);
            return false;
        }
    } catch (error) {
        console.error('safeNavigateToTab: 예상치 못한 오류:', error);
        return false;
    }
};

// safeNavigateToTab 함수를 전역으로 사용할 수 있도록 설정
if (typeof global !== 'undefined') {
    global.safeNavigateToTab = safeNavigateToTab;
}

// 새로운 일정을 공유하기 위한 Context 생성
const NewScheduleContext = createContext();

// Context Provider 컴포넌트
const NewScheduleProvider = ({ children }) => {
    const [newSchedule, setNewSchedule] = useState(null);
    
    const addNewSchedule = useCallback((schedule) => {
        // console.log('🔍 [Context] 새로운 일정 추가:', schedule);
        setNewSchedule(schedule);
    }, []);
    
    const clearNewSchedule = useCallback(() => {
        // console.log('🔍 [Context] 새로운 일정 초기화');
        setNewSchedule(null);
    }, []);
    
    return (
        <NewScheduleContext.Provider value={{ newSchedule, addNewSchedule, clearNewSchedule }}>
            {children}
        </NewScheduleContext.Provider>
    );
};

// Context 사용을 위한 Hook
const useNewSchedule = () => {
    const context = useContext(NewScheduleContext);
    if (!context) {
        throw new Error('useNewSchedule must be used within a NewScheduleProvider');
    }
    return context;
};

// --- 실시간 알림 관리 함수들 ---
const addNotification = (setNotifications, setUnreadCount, type, message, data = {}) => {
    const newNotification = {
        id: Date.now(),
        type,
        message,
        data,
        timestamp: new Date(),
        read: false
    };
    setNotifications(prev => [newNotification, ...prev]);
    setUnreadCount(prev => prev + 1);
};

const markNotificationAsRead = (setNotifications, setUnreadCount, notificationId) => {
    setNotifications(prev => 
        prev.map(notif => 
            notif.id === notificationId ? { ...notif, read: true } : notif
        )
    );
    setUnreadCount(prev => Math.max(0, prev - 1));
};

const Tab = createBottomTabNavigator();
const Stack = createStackNavigator();
const TopTab = createMaterialTopTabNavigator();
const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');

// --- 기본 스타일 (임시) ---
const basicStyles = StyleSheet.create({
    centeredView: { 
        flex: 1, 
        justifyContent: 'center', 
        alignItems: 'center', 
        backgroundColor: 'rgba(0,0,0,0.6)' 
    },
    modalView: { 
        margin: 20, 
        backgroundColor: 'white', 
        borderRadius: 24, 
        padding: 30, 
        alignItems: 'center', 
        width: '90%', 
        maxWidth: 400,
        shadowColor: '#000', 
        shadowOffset: { width: 0, height: 8 }, 
        shadowOpacity: 0.3, 
        shadowRadius: 12, 
        elevation: 8 
    },
    modalTitle: { 
        fontSize: 24, 
        fontWeight: 'bold', 
        marginBottom: 28, 
        textAlign: 'center', 
        color: '#3B82F6', 
        letterSpacing: 0.5,
        lineHeight: 32
    },
    button: { 
        borderRadius: 16, 
        padding: 16, 
        elevation: 3, 
        width: '100%', 
        marginTop: 12,
        shadowColor: '#3B82F6',
        shadowOffset: { width: 0, height: 2 }, 
        shadowOpacity: 0.2, 
        shadowRadius: 4
    },
    buttonClose: { backgroundColor: '#E2E8F0' },
    textStyle: { color: 'white', fontWeight: 'bold', textAlign: 'center', fontSize: 16 },
    textStyleBlack: { color: 'black', fontWeight: 'bold', textAlign: 'center', fontSize: 16 },
    optionButton: { padding: 12, marginVertical: 4, borderRadius: 8, backgroundColor: '#F1F5F9' },
    optionButtonSelected: { backgroundColor: '#3B82F6' },
    optionButtonText: { fontSize: 16, color: '#1E293B' },
    optionButtonTextSelected: { color: 'white' },
    scrollerContainer: { height: 200, alignItems: 'center' },
    scroller: { width: 100 },
    scrollerItem: { height: 50, justifyContent: 'center', alignItems: 'center' },
    scrollerItemText: { fontSize: 18, fontWeight: 'bold' },
    scrollerIndicator: { position: 'absolute', top: 75, left: 0, right: 0, height: 50, backgroundColor: 'rgba(59, 130, 246, 0.1)', borderRadius: 8 }
});

// --- 홈 탭 직접 업데이트 함수 (컴포넌트 내부로 이동됨) ---

// --- 테마 관리 함수 ---

const COLORS = {
    // 라이트 모드
    light: {
        primary: '#3B82F6',      // 파란색 (메인 컬러)
        primaryLight: 'rgba(59, 130, 246, 0.1)',
        secondary: '#10B981',    // 에메랄드 (강조/파티생성)
        accent: '#8B5CF6',       // 보라 (성공/확인)
        background: '#F1F5F9',   // 연한 블루 그레이
        surface: '#FFFFFF',
        text: '#1E293B',
        textSecondary: '#64748B',
        border: '#E2E8F0',
        gray: '#64748B',
        lightGray: '#E2E8F0',
        red: '#EF4444',
        disabled: '#CBD5E0',
        blue: '#3B82F6',         // 파란색 (메인)
        indigo: '#6366F1',       // 인디고 (단골파티)
        cyan: '#06B6D4',         // 시안 (맛집)
        deepBlue: '#1D5D9B',      // 진한 파란색
        skyBlue: '#75C2F6',       // 연한 파란색
        yellow: '#F4D160',        // 밝은 노란색
        paleYellow: '#FBEEAC',     // 연한 노란색
        white: '#FFFFFF',         // 흰색
    },
    // 다크 모드
    dark: {
        primary: '#60A5FA',      // 밝은 파란색
        primaryLight: 'rgba(96, 165, 250, 0.1)',
        secondary: '#34D399',    // 밝은 에메랄드
        accent: '#A78BFA',       // 밝은 보라
        background: '#0F172A',   // 진한 네이비
        surface: '#1E293B',      // 어두운 그레이
        text: '#F8FAFC',         // 밝은 텍스트
        textSecondary: '#94A3B8', // 회색 텍스트
        border: '#334155',       // 어두운 보더
        gray: '#94A3B8',
        lightGray: '#334155',
        red: '#F87171',
        disabled: '#475569',
        blue: '#60A5FA',
        indigo: '#818CF8',
        cyan: '#22D3EE',
        deepBlue: '#3B82F6',
        skyBlue: '#7DD3FC',
        yellow: '#FCD34D',
        paleYellow: '#FEF3C7',
        white: '#FFFFFF',         // 흰색
    }
};



LocaleConfig.locales['ko'] = { monthNames: ['1월', '2월', '3월', '4월', '5월', '6월', '7월', '8월', '9월', '10월', '11월', '12월'], monthNamesShort: ['1.', '2.', '3.', '4.', '5.', '6.', '7.', '8.', '9.', '10.', '11.', '12.'], dayNames: ['일요일', '월요일', '화요일', '수요일', '목요일', '금요일', '토요일'], dayNamesShort: ['일', '월', '화', '수', '목', '금', '토'], today: '오늘' };
LocaleConfig.defaultLocale = 'ko';

// --- 재사용 컴포넌트 ---
const SelectionModal = ({ visible, title, options, selected, onSelect, onClose, isMultiSelect = false, styles = basicStyles, colors }) => {
    const handleSelect = (item) => {
        if (isMultiSelect) {
            let newSelected = [...selected];
            if (newSelected.includes(item)) {
                newSelected = newSelected.filter(i => i !== item);
            } else if (newSelected.length < 3) {
                newSelected.push(item);
            } else {
                Alert.alert("선택 제한", "최대 3개까지 선택할 수 있습니다.");
            }
            onSelect(newSelected);
        } else {
            onSelect(item);
            onClose();
        }
    };
    return (
        <Modal visible={visible} transparent={true} animationType="fade" onRequestClose={onClose}>
            <Pressable style={styles.centeredView} onPress={onClose}>
                <Pressable style={styles.modalView}>
                    <Text style={styles.modalTitle}>{title}</Text>
                    <ScrollView 
                        style={{width: '100%', maxHeight: 300}}
                        showsVerticalScrollIndicator={false}
                        contentContainerStyle={{paddingBottom: 10}}
                    >
                        {options.map(item => (
                            <TouchableOpacity key={item} style={[styles.optionButton, (isMultiSelect ? selected.includes(item) : selected === item) && styles.optionButtonSelected]} onPress={() => handleSelect(item)}>
                                <Text style={[styles.optionButtonText, (isMultiSelect ? selected.includes(item) : selected === item) && styles.optionButtonTextSelected]}>{item}</Text>
                            </TouchableOpacity>
                        ))}
                    </ScrollView>
                    {isMultiSelect && <Pressable style={[styles.button, styles.buttonClose]} onPress={onClose}><Text style={styles.textStyleBlack}>선택 완료</Text></Pressable>}
                </Pressable>
            </Pressable>
        </Modal>
    );
};

const NumberScroller = ({ onSelect, initialValue = 4, styles = basicStyles }) => {
    const numbers = Array.from({ length: 9 }, (_, i) => i + 2); // 2 to 10
    const scrollViewRef = useRef(null);

    useEffect(() => {
        const initialIndex = numbers.indexOf(initialValue);
        if (initialIndex !== -1 && scrollViewRef.current) {
            setTimeout(() => scrollViewRef.current.scrollTo({ y: initialIndex * 50, animated: false }), 100);
        }
    }, [initialValue]);

    return (
        <View style={styles.scrollerContainer}>
            <ScrollView
                ref={scrollViewRef}
                style={styles.scroller}
                onMomentumScrollEnd={(event) => {
                    const index = Math.round(event.nativeEvent.contentOffset.y / 50);
                    onSelect(numbers[index]);
                }}
                snapToInterval={50}
                showsVerticalScrollIndicator={false}
                decelerationRate="fast"
            >
                {numbers.map(num => (
                    <View key={num} style={styles.scrollerItem}>
                        <Text style={styles.scrollerItemText}>{num}명</Text>
                    </View>
                ))}
            </ScrollView>
            <View style={styles.scrollerIndicator} />
        </View>
    );
};

function parseRecipientIds(recipientIds) {
  // 빈 문자열이면 빈 배열 반환
  if (!recipientIds || recipientIds.trim() === '') {
    return [];
  }
  
  // 연속된 쉼표를 하나로 치환하고, 앞뒤 공백 제거
  const cleanedIds = recipientIds.replace(/,,+/g, ',').trim();
  
  // 쉼표로 분리하고 빈 문자열 제거
  const ids = cleanedIds
    .split(',')
    .map(id => id.trim())
    .filter(id => id.length > 0);
  
  // 만약 각 ID가 한 글자씩이라면 (예: "K,O,I,C,A,0,0,2"), 올바른 형태로 조합
  if (ids.length > 0 && ids[0].length === 1) {
    const combinedIds = [];
    let currentId = '';
    
    for (let i = 0; i < ids.length; i++) {
      currentId += ids[i];
      // 8글자가 되면 하나의 ID로 간주 (KOICA002 형태)
      if (currentId.length === 8) {
        combinedIds.push(currentId);
        currentId = '';
      }
    }
    
    // 남은 글자들도 ID로 추가 (8글자가 안 되더라도)
    if (currentId.length > 0) {
      combinedIds.push(currentId);
    }
    
    return combinedIds;
  }
  
  return ids;
}
// 날짜를 YYYY-MM-DD(로컬)로 반환하는 함수
function toLocalDateString(date) {
  const pad = n => n.toString().padStart(2, '0');
  const result = `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;
  

  return result;
}

// 가장 가까운 평일을 반환하는 함수
function getNextWeekday(date) {
  const day = date.getDay();
  if (day === 0) { // 일요일
    date.setDate(date.getDate() + 1); // 월요일로
  } else if (day === 6) { // 토요일
    date.setDate(date.getDate() + 2); // 월요일로
  }
  return date;
}

// 한국 시간 기준으로 날짜를 YYYY-MM-DD 형식으로 변환하는 함수
function toKoreanDateString(date) {
  // 한국 시간대 (UTC+9) 고려
  const koreanTime = new Date(date.getTime() + (9 * 60 * 60 * 1000));
  const year = koreanTime.getFullYear();
  const month = String(koreanTime.getMonth() + 1).padStart(2, '0');
  const day = String(koreanTime.getDate()).padStart(2, '0');
  const result = `${year}-${month}-${day}`;
  

  return result;
}


// --- 홈 탭 ---
function HomeScreen({ navigation, route }) {
    const [todayMenu, setTodayMenu] = useState([]);
    const [appointments, setAppointments] = useState([]);
    const [markedDates, setMarkedDates] = useState({});
    const [allEvents, setAllEvents] = useState(() => {
        // console.log('🔍 [App] allEvents 상태 초기화');
        return {};
    });
    
    // 🚨 중요: allEvents 상태에 안전하게 접근하는 헬퍼 함수
    const getSafeAllEvents = useCallback(() => {
        if (!allEvents || typeof allEvents !== 'object') {
            // console.log('🔍 [App] allEvents 상태 안전 접근 - 초기화 중:', allEvents);
            return {};
        }
        return allEvents;
    }, [allEvents]);
    
    // 🚨 중요: 특정 날짜의 이벤트를 안전하게 가져오는 헬퍼 함수
    const getSafeEventsForDate = useCallback((dateString) => {
        const safeAllEvents = getSafeAllEvents();
        const events = safeAllEvents[dateString] || [];
        return Array.isArray(events) ? events.filter(event => event && typeof event === 'object') : [];
    }, [getSafeAllEvents]);
    
    // 🚨 중요: 기존 이벤트 배열을 안전하게 검증하는 헬퍼 함수
    const getSafeValidEvents = useCallback((existingEvents) => {
        if (!existingEvents || !Array.isArray(existingEvents)) {
            return [];
        }
        
        const filteredEvents = existingEvents.filter(event => event && typeof event === 'object');
        return filteredEvents;
    }, []);
    const [modalData, setModalData] = useState({ visible: false, events: [] });
    
    // 🚨 중요: 중복 실행 방지를 위한 ref
    const isProcessingSchedule = useRef(false);
    
    // 🚨 중요: Context API와 연동하는 updateHomeSchedule 함수
    const { updateScheduleUnified, schedules } = useSchedule();
    
    // Context 상태와 로컬 상태 동기화
    useEffect(() => {
        console.log('🔍 [HomeScreen] Context 상태 동기화 시작');
        
        // appointments 동기화
        if (schedules.appointments && schedules.appointments.length > 0) {
            setAppointments(schedules.appointments);
            console.log('🔍 [HomeScreen] appointments Context 동기화:', schedules.appointments.length, '개');
        }
        
        // markedDates 동기화
        if (schedules.markedDates && Object.keys(schedules.markedDates).length > 0) {
            setMarkedDates(schedules.markedDates);
            console.log('🔍 [HomeScreen] markedDates Context 동기화:', Object.keys(schedules.markedDates).length, '개');
        }
        
        // allEvents 동기화
        if (schedules.allEvents && Object.keys(schedules.allEvents).length > 0) {
            setAllEvents(schedules.allEvents);
            console.log('🔍 [HomeScreen] allEvents Context 동기화:', Object.keys(schedules.allEvents).length, '개');
        }
    }, [schedules]);
    
    const updateHomeSchedule = useCallback((eventData, action) => {
        console.log('🔄 [홈탭] 일정 동기화:', action, eventData);
        
        // Context API를 통한 통합 업데이트
        updateScheduleUnified(eventData, action, 'personal');
        
        // 🚨 디버깅: 현재 상태 로깅
        console.log('🔍 [updateHomeSchedule] 현재 상태:', {
            appointmentsCount: appointments.length,
            markedDatesKeys: Object.keys(markedDates),
            allEventsKeys: Object.keys(allEvents)
        });
        
        // 로컬 상태도 동기화 (기존 로직 유지)
        if (action === 'add' || action === 'update') {
            // 새로운 일정 추가 또는 기존 일정 업데이트
            const eventDate = eventData.party_date || eventData.date;
            
            // allEvents 상태 업데이트
            setAllEvents(prev => {
                const newAllEvents = { ...prev };
                
                if (!newAllEvents[eventDate]) {
                    newAllEvents[eventDate] = [];
                }
                
                // 기존 일정이 있는지 확인하고 업데이트
                const existingIndex = newAllEvents[eventDate].findIndex(
                    event => event.id === eventData.id || event._id === eventData.id
                );
                
                if (existingIndex >= 0) {
                    newAllEvents[eventDate][existingIndex] = eventData;
                    console.log('🔍 [updateHomeSchedule] allEvents 업데이트:', eventDate, '이벤트 수:', newAllEvents[eventDate].length);
                } else {
                    newAllEvents[eventDate].push(eventData);
                    console.log('🔍 [updateHomeSchedule] allEvents 새 일정 추가:', eventDate, '이벤트 수:', newAllEvents[eventDate].length);
                }
                
                return newAllEvents;
            });
            
            // appointments 상태 업데이트
            setAppointments(prev => {
                const existingIndex = prev.findIndex(app => app.id === eventData.id || app._id === eventData.id);
                if (existingIndex >= 0) {
                    const newAppointments = [...prev];
                    newAppointments[existingIndex] = eventData;
                    console.log('🔍 [updateHomeSchedule] appointments 업데이트:', eventDate);
                    return newAppointments;
                } else {
                    console.log('🔍 [updateHomeSchedule] appointments 새 일정 추가:', eventDate);
                    return [...prev, eventData];
                }
            });
            
            // markedDates 상태 업데이트
            setMarkedDates(prev => {
                const newMarkedDates = { ...prev };
                newMarkedDates[eventDate] = {
                    selected: true,
                    selectedColor: '#64748B' // 기타 일정 색상
                };
                console.log('🔍 [updateHomeSchedule] markedDates 업데이트:', eventDate);
                return newMarkedDates;
            });
            
        } else if (action === 'remove' || action === 'delete') {
            // 일정 제거
            const eventDate = eventData.party_date || eventData.date;
            const eventId = eventData.id || eventData._id;
            
            console.log('🔍 [updateHomeSchedule] 일정 삭제 시작:', { eventId, eventDate });
            
            // allEvents 상태에서 제거
            setAllEvents(prev => {
                const newAllEvents = { ...prev };
                
                if (newAllEvents[eventDate]) {
                    const oldEventCount = newAllEvents[eventDate].length;
                    newAllEvents[eventDate] = newAllEvents[eventDate].filter(
                        event => event.id !== eventId && event._id !== eventId
                    );
                    
                    console.log('🔍 [updateHomeSchedule] allEvents 삭제:', eventDate, '이벤트 수:', oldEventCount, '->', newAllEvents[eventDate].length);
                    
                    // 해당 날짜에 일정이 없으면 날짜 자체도 제거
                    if (newAllEvents[eventDate].length === 0) {
                        delete newAllEvents[eventDate];
                        console.log('🔍 [updateHomeSchedule] allEvents에서 빈 날짜 제거:', eventDate);
                    }
                }
                
                return newAllEvents;
            });
            
            // appointments 상태에서도 제거
            setAppointments(prev => {
                const newAppointments = prev.filter(app => app.id !== eventId && app._id !== eventId);
                console.log('🔍 [updateHomeSchedule] appointments 삭제:', '이벤트 수:', prev.length, '->', newAppointments.length);
                return newAppointments;
            });
            
            // markedDates에서도 제거 (해당 날짜에 다른 일정이 없는 경우)
            setMarkedDates(prev => {
                const newMarkedDates = { ...prev };
                
                // 해당 날짜에 다른 일정이 있는지 확인
                const hasOtherEvents = appointments.some(app => 
                    app.date === eventDate && app.id !== eventId && app._id !== eventId
                );
                
                if (!hasOtherEvents) {
                    delete newMarkedDates[eventDate];
                    console.log('🔍 [updateHomeSchedule] markedDates에서 날짜 제거:', eventDate);
                }
                
                return newMarkedDates;
            });
        }
        
        // 🚨 디버깅: 상태 변경 후 최종 확인
        setTimeout(() => {
            console.log('🔍 [updateHomeSchedule] 상태 변경 후 최종 확인:', {
                action,
                eventId: eventData.id || eventData._id,
                eventDate: eventData.party_date || eventData.date
            });
        }, 100);
        
        console.log('✅ [updateHomeSchedule]', action, '완료');
    }, [appointments, markedDates, allEvents, updateScheduleUnified]);
    
    // 전역 함수 등록 (다른 화면에서 사용)
    useEffect(() => {
        global.updateHomeSchedule = updateHomeSchedule;
        return () => {
            global.updateHomeSchedule = undefined;
        };
    }, [updateHomeSchedule]);
    
    // 🚨 디버깅: 상태 변경 모니터링
    useEffect(() => {
        console.log('🔍 [HomeScreen] appointments 상태 변경:', {
            count: appointments.length,
            dates: appointments.map(item => ({ date: item.date, eventCount: item.events?.length || 0 }))
        });
    }, [appointments]);
    
    useEffect(() => {
        console.log('🔍 [HomeScreen] markedDates 상태 변경:', {
            count: Object.keys(markedDates).length,
            dates: Object.keys(markedDates)
        });
    }, [markedDates]);
    
    useEffect(() => {
        console.log('🔍 [HomeScreen] allEvents 상태 변경:', {
            count: Object.keys(allEvents).length,
            dates: Object.keys(allEvents),
            totalEvents: Object.values(allEvents).reduce((sum, events) => sum + events.length, 0)
        });
    }, [allEvents]);
    
    // 🚨 디버깅: 상태 일관성 검증 함수
    const validateStateConsistency = useCallback(() => {
        console.log('🔍 [HomeScreen] 상태 일관성 검증 시작');
        
        const appointmentsDates = appointments.map(item => item.date);
        const markedDatesKeys = Object.keys(markedDates);
        const allEventsKeys = Object.keys(allEvents);
        
        // 1. appointments와 markedDates 일치 확인
        const appointmentsMarkedMismatch = appointmentsDates.filter(date => !markedDatesKeys.includes(date));
        const markedAppointmentsMismatch = markedDatesKeys.filter(date => !appointmentsDates.includes(date));
        
        if (appointmentsMarkedMismatch.length > 0) {
            console.warn('⚠️ [HomeScreen] appointments에는 있지만 markedDates에는 없는 날짜:', appointmentsMarkedMismatch);
        }
        if (markedAppointmentsMismatch.length > 0) {
            console.warn('⚠️ [HomeScreen] markedDates에는 있지만 appointments에는 없는 날짜:', markedAppointmentsMismatch);
        }
        
        // 2. appointments와 allEvents 일치 확인
        const appointmentsAllEventsMismatch = appointmentsDates.filter(date => !allEventsKeys.includes(date));
        const allEventsAppointmentsMismatch = allEventsKeys.filter(date => !appointmentsDates.includes(date));
        
        if (appointmentsAllEventsMismatch.length > 0) {
            console.warn('⚠️ [HomeScreen] appointments에는 있지만 allEvents에는 없는 날짜:', appointmentsAllEventsMismatch);
        }
        if (allEventsAppointmentsMismatch.length > 0) {
            console.warn('⚠️ [HomeScreen] allEvents에는 있지만 appointments에는 없는 날짜:', allEventsAppointmentsMismatch);
        }
        
        // 3. 각 날짜별 이벤트 수 일치 확인
        appointments.forEach(item => {
            const allEventsCount = allEvents[item.date]?.length || 0;
            const itemEventsCount = item.events?.length || 0;
            if (itemEventsCount !== allEventsCount) {
                console.warn('⚠️ [HomeScreen] 날짜별 이벤트 수 불일치:', {
                    date: item.date,
                    appointmentsEvents: itemEventsCount,
                    allEventsCount: allEventsCount
                });
            }
        });
        
        console.log('🔍 [HomeScreen] 상태 일관성 검증 완료');
    }, [appointments, markedDates, allEvents]);
    
    // 🚨 디버깅: 주기적 상태 검증 (개발 모드에서만)
    useEffect(() => {
        if (__DEV__) {
            const interval = setInterval(validateStateConsistency, 5000); // 5초마다 검증
            return () => clearInterval(interval);
        }
    }, [validateStateConsistency]);
    
    // 🚨 중요: AsyncStorage를 사용한 일정 데이터 영구 저장 시스템
    const saveAppointmentsToStorage = async (appointmentsData, markedDatesData, allEventsData) => {
        try {
            await AsyncStorage.setItem('@home_appointments', JSON.stringify(appointmentsData));
            await AsyncStorage.setItem('@home_markedDates', JSON.stringify(markedDatesData));
            await AsyncStorage.setItem('@home_allEvents', JSON.stringify(allEventsData));
    
        } catch (error) {
            console.error('🔍 [로컬저장] 일정 데이터 저장 실패:', error);
        }
    };
    
    const loadAppointmentsFromStorage = async () => {
        try {
            const appointmentsData = await AsyncStorage.getItem('@home_appointments');
            const markedDatesData = await AsyncStorage.getItem('@home_markedDates');
            const allEventsData = await AsyncStorage.getItem('@home_allEvents');
            
            if (appointmentsData && markedDatesData && allEventsData) {
                const parsedAppointments = JSON.parse(appointmentsData);
                const parsedMarkedDates = JSON.parse(markedDatesData);
                const parsedAllEvents = JSON.parse(allEventsData);
                
                setAppointments(parsedAppointments);
                setMarkedDates(parsedMarkedDates);
                setAllEvents(parsedAllEvents);
                
                // Context에도 초기 데이터 설정
                if (setInitialData) {
                    setInitialData({
                        appointments: parsedAppointments,
                        markedDates: parsedMarkedDates,
                        allEvents: parsedAllEvents,
                        parties: [],
                        randomLunches: []
                    });
                    console.log('🔍 [fetchHomeData] Context 초기 데이터 설정 완료');
                }
                
                // 전역 백업에도 저장
                global.backupAppointments = parsedAppointments;
                global.backupMarkedDates = parsedMarkedDates;
                global.backupAllEvents = parsedAllEvents;
                
                return true;
            }
            return false;
        } catch (error) {
            console.error('🔍 [로컬저장] 일정 데이터 복원 실패:', error);
            return false;
        }
    };
    

    const [unreadCount, setUnreadCount] = useState(0);
    const [currentUser, setCurrentUser] = useState(null);
    const [missionModalVisible, setMissionModalVisible] = useState(false);

    
    // MissionContext에서 미션 상태를 직접 확인하여 헤더의 빨간 점 표시
    const { getTabMissionProgress, missionProgress } = useMission();
    
    // 미션 진행도 변화에 따라 헤더의 빨간 점 상태 계산 (route.params 사용하지 않음)
    const hasUnclaimedMissions = useMemo(() => {
        if (!missionProgress) return false;
        
        const dailyProgress = getTabMissionProgress('daily');
        const weeklyProgress = getTabMissionProgress('weekly');
        const monthlyProgress = getTabMissionProgress('monthly');
        
        return (
            Object.values(dailyProgress || {}).some(m => m.completed && !m.claimed) ||
            Object.values(weeklyProgress || {}).some(m => m.completed && !m.claimed) ||
            Object.values(monthlyProgress || {}).some(m => m.completed && !m.claimed)
        );
    }, [missionProgress, getTabMissionProgress]);
    

    
        // 사용자 정보 초기화
    useEffect(() => {
        const initUser = async () => {
            await userManager.initialize();
            setCurrentUser(userManager.getCurrentUser());
        };
        initUser();
    }, []);
    
    // hasUnclaimedMissions 상태를 route.params에 설정하여 헤더의 빨간 점 표시
    useEffect(() => {
        navigation.setParams({ hasUnclaimedMissions });
    }, [hasUnclaimedMissions, navigation]);
    
    // hasUnclaimedMissions 상태를 route.params에 설정하여 헤더의 빨간 점 표시
    useEffect(() => {
        navigation.setParams({ hasUnclaimedMissions });
    }, [hasUnclaimedMissions, navigation]);



    // route.params에서 미션 모달 열기 요청 확인
    useEffect(() => {
        if (route.params?.openMissionModal) {
            setMissionModalVisible(true);
            // 파라미터 초기화
            navigation.setParams({ openMissionModal: undefined });
        }
    }, [route.params?.openMissionModal]);
    

    
    // route.params에서 친구와 함께 식사하기 팝업 열기 요청 확인
    useEffect(() => {
        if (route.params?.showFriendLunchModal) {
            // 친구와 함께 식사하기 팝업을 보여주는 로직
            // 플로팅버튼을 누른 것처럼 점심 약속 추가 모달을 열기
            const today = toLocalDateString(new Date());
            setModalData({ visible: true, events: [], date: today });
            // 파라미터 초기화
            navigation.setParams({ showFriendLunchModal: undefined });
        }
    }, [route.params?.showFriendLunchModal, navigation]);

    // 🚨 중요: route.params에서 일정 모달 표시 요청 확인
    useEffect(() => {
        if (route.params?.showScheduleModal && route.params?.scheduleDate && route.params?.scheduleEvent) {

            
            // 해당 날짜의 일정을 찾아서 모달에 표시
            const targetDate = route.params.scheduleDate;
            const targetEvent = route.params.scheduleEvent;
            
            // allEvents에서 해당 날짜의 일정들을 찾기
            const eventsForDate = getSafeEventsForDate(targetDate);
            
            if (eventsForDate.length > 0) {
                // 해당 일정이 포함된 날짜의 모든 일정을 모달에 표시
                setModalData({ 
                    visible: true, 
                    events: eventsForDate, 
                    date: targetDate 
                });
            } else {
                // 해당 날짜에 일정이 없으면 단일 일정으로 모달 표시
                setModalData({ 
                    visible: true, 
                    events: [targetEvent], 
                    date: targetDate 
                });
            }
            
            // 모달을 열고 나면 route.params 초기화
            navigation.setParams({ 
                showScheduleModal: undefined, 
                scheduleDate: undefined, 
                scheduleEvent: undefined 
            });
        }
    }, [route.params?.showScheduleModal, route.params?.scheduleDate, route.params?.scheduleEvent, navigation]);

    const fetchHomeData = useCallback((backupAppointments = null, backupMarkedDates = null, backupAllEvents = null) => {
        // 디버그 로그 제거
        // 디버그 로그 제거
        // 디버그 로그 제거
        
        // 🚨 중요: API 호출과 관계없이 항상 7일간 카드 생성 보장!
        const today = getKoreanToday(); // 한국 시간 기준으로 오늘 날짜 가져오기
        
        // Context 초기 데이터 설정
        const { setInitialData } = useSchedule();
        
        // 🎯 전역 변수에 정확한 오늘 날짜 저장 (플로팅 버튼에서 사용)
        // toLocalDateString() 사용하지 않고 직접 날짜 문자열 생성
        const year = today.getUTCFullYear();
        const month = String(today.getUTCMonth() + 1).padStart(2, '0');
        const date = String(today.getUTCDate()).padStart(2, '0');
        global.homeTodayDate = `${year}-${month}-${date}`;
        
        // 🎯 강제로 7일간 카드 생성 (API 응답과 독립적)
        const forceUpcoming = [];
        for (let i = 0; i < 7; i++) {
            // UTC 기준으로 날짜 계산 (로컬 시간대 변환 문제 해결)
            const utcYear = today.getUTCFullYear();
            const utcMonth = today.getUTCMonth();
            const utcDate = today.getUTCDate() + i;
            
            // UTC 기준으로 날짜 문자열 생성
            const dateString = `${utcYear}-${String(utcMonth + 1).padStart(2, '0')}-${String(utcDate).padStart(2, '0')}`;
            forceUpcoming.push({
                date: dateString,
                events: []
            });
                    // 강제 생성 날짜
        }
    // 강제 생성 최종 upcoming 배열
        
        // 🚨 즉시 상태 업데이트 (API 응답과 관계없이)
        // 단, 기존에 있는 일정은 보존
        setAppointments(prev => {
            const newAppointments = [...forceUpcoming];
            
            // 기존 appointments에서 이벤트가 있는 날짜는 보존
            if (prev && prev.length > 0) {
                prev.forEach(existingAppointment => {
                    if (existingAppointment.events && Array.isArray(existingAppointment.events) && existingAppointment.events.length > 0) {
                        const existingIndex = newAppointments.findIndex(item => item.date === existingAppointment.date);
                        if (existingIndex >= 0) {
                            newAppointments[existingIndex] = existingAppointment;
                        }
                    }
                });
            }
            
                                    // console.log('🔍 [fetchHomeData] 기존 일정 보존 후 appointments:', newAppointments);
            return newAppointments;
        });
        
        fetch(`${RENDER_SERVER_URL}/cafeteria/today`).then(res => res.json()).then(data => { 
            if (data && Array.isArray(data.menu)) {
                setTodayMenu(data.menu);
                // 메뉴 기록 미션 완료 처리 (임시 비활성화)
                // if (data.menu && data.menu.length > 0) {
                //     handleActionCompletion('menu_record');
                // }
            }
        }).catch(console.error);

        if (!currentUser) {
            // 디버그 로그 제거
            
            // 전역 변수에 사용자 ID가 있으면 사용
            if (global.myEmployeeId) {
                // 디버그 로그 제거
            } else {
                // 디버그 로그 제거
                return;
            }
        }
        
        const userId = currentUser?.employee_id || global.myEmployeeId;
        // 디버그 로그 제거
        fetch(`${RENDER_SERVER_URL}/events/${userId}`).then(res => {
            // 디버그 로그 제거
            
            // 🚨 중요: 서버 오류 시 전역 백업 상태 보존!
            if (!res.ok) {
                // 디버그 로그 제거
                
                // 전역 백업 상태가 있으면 그대로 복원
                if (global.backupAppointments && global.backupAppointments.length > 0) {
                    // 디버그 로그 제거
                    setAppointments(global.backupAppointments);
                    setMarkedDates(global.backupMarkedDates || {});
                    setAllEvents(global.backupAllEvents || {});
                    return Promise.reject(new Error('전역 백업 상태 복원 완료'));
                } else {
                    // 디버그 로그 제거
                    // 기본값 설정
                    const upcoming = [];
                    for (let i = 0; i < 7; i++) {
                        const date = new Date(today);
                        date.setUTCDate(today.getUTCDate() + i);
                        const dateString = toLocalDateString(date);
                        upcoming.push({
                            date: dateString,
                            events: []
                        });
                    }
                    setAppointments(upcoming);
                    setMarkedDates({});
                    setAllEvents({});
                    return Promise.reject(new Error('기본값 설정 완료'));
                }
            }
            
            return res.json();
        }).then(data => {
                    // 디버그 로그 제거
        
        if (!data || typeof data !== 'object') {
            // 디버그 로그 제거
            return;
        }
        
        // 데이터 구조 상세 분석
        // 디버그 로그 제거
        
    const upcoming = [];

    // 1. 오늘부터 7일간의 '나의 점심 약속'만 upcoming에 넣기 (UI용)
        // 디버그 로그 제거
                // 반복 일정을 모든 날짜에 확장하는 함수
            const expandRecurringEvents = (events, startDate) => {
                const expandedEvents = [];
                
                events.forEach(event => {
                    if (event.is_recurring && event.recurrence_type) {
                        // 반복 일정인 경우 모든 반복 날짜 계산
                        const eventStartDate = new Date(startDate);
                        
                        // 7일간의 반복 일정 계산
                        for (let i = 0; i < 7; i++) {
                            const checkDate = new Date(today);
                            checkDate.setUTCDate(today.getUTCDate() + i);
                            const checkDateString = toLocalDateString(checkDate);
                            
                            // 해당 날짜에 반복 일정이 적용되는지 확인
                            let shouldInclude = false;
                            
                            if (event.recurrence_type === 'daily') {
                                // 매일 반복: 시작일로부터 1일 간격
                                const daysDiff = Math.floor((checkDate - eventStartDate) / (1000 * 60 * 60 * 24));
                                shouldInclude = daysDiff >= 0 && daysDiff % 1 === 0;
                            } else if (event.recurrence_type === 'weekly') {
                                // 매주 반복: 시작일로부터 7일 간격
                                const daysDiff = Math.floor((checkDate - eventStartDate) / (1000 * 60 * 60 * 24));
                                shouldInclude = daysDiff >= 0 && daysDiff % 7 === 0;
                            } else if (event.recurrence_type === 'yearly') {
                                // 매년 반복: 시작일로부터 365일 간격
                                const daysDiff = Math.floor((checkDate - eventStartDate) / (1000 * 60 * 60 * 24));
                                shouldInclude = daysDiff >= 0 && daysDiff % 365 === 0;
                            }
                            
                            if (shouldInclude) {
                                // 해당 날짜에 반복 일정 추가
                                const existingDateIndex = expandedEvents.findIndex(item => item.date === checkDateString);
                                if (existingDateIndex >= 0) {
                                    expandedEvents[existingDateIndex].events.push(event);
                                } else {
                                    expandedEvents.push({
                                        date: checkDateString,
                                        events: [event]
                                    });
                                }
                            }
                        }
                    } else {
                        // 일반 일정인 경우 해당 날짜에만 추가
                        const existingDateIndex = expandedEvents.findIndex(item => item.date === startDate);
                        if (existingDateIndex >= 0) {
                            expandedEvents[existingDateIndex].events.push(event);
                        } else {
                            expandedEvents.push({
                                date: startDate,
                                events: [event]
                            });
                        }
                    }
                });
                
                return expandedEvents;
            };
            
            // 모든 반복 일정을 먼저 확장하여 전체 날짜에 배치
            const allExpandedEvents = {};
            
            // 백엔드 데이터가 비어있을 때 전역 변수 데이터를 우선적으로 사용
            if (Object.keys(data).length === 0 && global.allEvents && Object.keys(global.allEvents).length > 0) {
                // 백엔드 데이터가 비어있어 전역 변수 데이터 사용
                Object.keys(global.allEvents).forEach(dateString => {
                    const globalEventsOnDate = Array.isArray(global.allEvents[dateString]) ? global.allEvents[dateString] : [];
                    if (globalEventsOnDate.length > 0) {
                        if (!allExpandedEvents[dateString]) {
                            allExpandedEvents[dateString] = [];
                        }
                        // 전역 변수의 일정을 추가
                        globalEventsOnDate.forEach(event => {
                            allExpandedEvents[dateString].push(event);
                        });
                    }
                });
            }
            
            // 백엔드 데이터가 있을 때는 전역 변수 데이터를 완전히 무시
            if (Object.keys(data).length > 0) {
                // 디버그 로그 제거
                // 🚨 중요: 전역 변수 데이터를 완전히 초기화하지 않음
                // 새로 생성된 일정을 보존하기 위해 기존 전역 변수 데이터 유지
                
                // 백엔드 데이터를 그대로 사용 (반복 일정 계산 제거)
                Object.keys(data).forEach(dateString => {
                    const eventsOnDate = Array.isArray(data[dateString]) ? data[dateString] : [];
                    
                    if (!allExpandedEvents[dateString]) {
                        allExpandedEvents[dateString] = [];
                    }
                    
                    // 🚨 중요: "[삭제됨]" 일정이 있는 날짜에서는 반복 일정 숨김 처리
                    const hasDeletedEvent = eventsOnDate.some(event => 
                        (event.title && event.title.startsWith('[삭제됨]'))
                    );
                    
                    if (hasDeletedEvent) {
                        // "[삭제됨]" 일정이 있는 경우, 해당 날짜에는 아무 일정도 표시하지 않음
                        // 완전히 빈 날짜로 만들어서 "일정 없음" 상태로 표시
                        allExpandedEvents[dateString] = [];
                    } else {
                        // 일반적인 경우: 모든 일정 표시
                        eventsOnDate.forEach(event => {
                            allExpandedEvents[dateString].push(event);
                        });
                    }
                });
                
                // 🚨 중요: 백엔드 데이터 처리 후 전역 변수의 새로 생성된 일정 추가
                if (global.allEvents && Object.keys(global.allEvents).length > 0) {
                    Object.keys(global.allEvents).forEach(dateString => {
                        const globalEventsOnDate = Array.isArray(global.allEvents[dateString]) ? global.allEvents[dateString] : [];
                        if (globalEventsOnDate.length > 0) {
                            if (!allExpandedEvents[dateString]) {
                                allExpandedEvents[dateString] = [];
                            }
                            // 전역 변수의 일정을 중복 없이 추가
                            globalEventsOnDate.forEach(event => {
                                const isDuplicate = allExpandedEvents[dateString].some(existingEvent => 
                                    existingEvent.id === event.id
                                );
                                if (!isDuplicate) {
                                    allExpandedEvents[dateString].push(event);
                                }
                            });
                        }
                    });
                }
            }
            
            // 백엔드 데이터가 있으면 전역 변수 데이터는 사용하지 않음 (단순화)
            if (Object.keys(data).length === 0 && global.allEvents && Object.keys(global.allEvents).length > 0) {
                // 백엔드 데이터가 없어 전역 변수 데이터 사용
                Object.keys(global.allEvents).forEach(dateString => {
                    if (!allExpandedEvents[dateString]) {
                        allExpandedEvents[dateString] = [];
                    }
                    allExpandedEvents[dateString].push(...global.allEvents[dateString]);
                });
            }
            
            // 전역 변수에 새로 추가된 일정이 있으면 즉시 표시
            if (global.newScheduleData) {
                // 전역 변수 새 일정 처리
                const newSchedule = global.newScheduleData;
                const scheduleDate = newSchedule.date;
                
                if (!allExpandedEvents[scheduleDate]) {
                    allExpandedEvents[scheduleDate] = [];
                }
                
                // 중복 확인 후 추가
                const isDuplicate = allExpandedEvents[scheduleDate].some(existingEvent => 
                    existingEvent.id === newSchedule.id && 
                    existingEvent.date === newSchedule.date &&
                    existingEvent.title === newSchedule.title
                );
                
                if (!isDuplicate) {
                    allExpandedEvents[scheduleDate].push(newSchedule);
                    // 새 일정 추가
                }
                
                // 전역 변수 정리
                global.newScheduleData = undefined;
            }
            
            // 중복 일정 정리 함수 (디버깅용)
            const cleanupDuplicateSchedules = async () => {
                try {
                    const response = await fetch(`${RENDER_SERVER_URL}/personal_schedules/cleanup`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            employee_id: global.myEmployeeId || 'KOICA001'
                        })
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        console.log('🔧 중복 일정 정리 결과:', result);
                        return result;
                        } else {
                        console.error('🔧 중복 일정 정리 실패:', response.status);
                    }
                } catch (error) {
                    console.error('🔧 중복 일정 정리 오류:', error);
                }
            };
            
            // 전역 변수에 정리 함수 추가 (디버깅용)
            if (typeof global !== 'undefined') {
                global.cleanupDuplicateSchedules = cleanupDuplicateSchedules;
            }
            

            
            // 🎯 API 응답이 성공적으로 처리된 경우에만 기존 7일간 카드 생성 로직 실행
            // API 응답 처리 완료, 기존 7일간 카드 생성 로직 실행
            
            // 각 날짜별로 이벤트 처리 (오늘부터 7일)
            for (let i = 0; i < 7; i++) {
                // UTC 기준으로 날짜 계산 (로컬 시간대 변환 문제 해결)
                const utcYear = today.getUTCFullYear();
                const utcMonth = today.getUTCMonth();
                const utcDate = today.getUTCDate() + i;
                
                // UTC 기준으로 날짜 문자열 생성
                const dateString = `${utcYear}-${String(utcMonth + 1).padStart(2, '0')}-${String(utcDate).padStart(2, '0')}`;
                const eventsOnDate = allExpandedEvents[dateString] || [];
                
                // 각 날짜별 이벤트 처리
                upcoming.push({ date: dateString, events: eventsOnDate });
            }
            

        // 최종 upcoming 배열

            // 2. allExpandedEvents를 사용하여 markedDates 업데이트 (달력 표시용 - 반복 일정 포함)
        const newMarkedDates = {};
        const newAllEvents = {};
        
        // allExpandedEvents의 모든 날짜를 markedDates에 추가
        Object.keys(allExpandedEvents).forEach(dateString => {
            if (allExpandedEvents[dateString].length > 0) {
                let hasRandomLunch = false;
                let hasPersonalSchedule = false;
                let hasOtherEvents = false;

                allExpandedEvents[dateString].forEach(event => {
                    if (event.type === '랜덤 런치') {
                        hasRandomLunch = true;
                    } else if (event.type === '기타 일정') {
                        hasPersonalSchedule = true;
                    } else {
                        hasOtherEvents = true;
                    }
                });

                let dotColor;
                if (hasRandomLunch) {
                    dotColor = '#F4D160';
                } else if (hasPersonalSchedule) {
                    dotColor = currentColors.gray;
                } else {
                    dotColor = currentColors.primary;
                }

                newMarkedDates[dateString] = {
                    selected: true,
                    selectedColor: dotColor
                };
                
                newAllEvents[dateString] = allExpandedEvents[dateString];
            }
        });
        
        // 전역 변수도 업데이트 (과거 일정 표시용)
        if (typeof global !== 'undefined') {
            global.allEvents = newAllEvents;
        }

        // 🚨 중요: 기존 상태와 병합하여 업데이트 (새로 생성된 일정 보존)
        setAppointments(prev => {
            const mergedAppointments = [...upcoming];
            
            // 기존 appointments에서 이벤트가 있는 날짜는 보존
            if (prev && prev.length > 0) {
                prev.forEach(existingAppointment => {
                    if (existingAppointment.events && Array.isArray(existingAppointment.events) && existingAppointment.events.length > 0) {
                        const existingIndex = mergedAppointments.findIndex(item => item.date === existingAppointment.date);
                        if (existingIndex >= 0) {
                            // 기존 일정과 새 일정을 병합
                            const existingEvents = existingAppointment.events;
                            const newEvents = mergedAppointments[existingIndex].events;
                            
                            // 중복 제거하여 병합
                            const mergedEvents = [...existingEvents];
                            newEvents.forEach(newEvent => {
                                const isDuplicate = mergedEvents.some(existingEvent => 
                                    existingEvent.id === newEvent.id
                                );
                                if (!isDuplicate) {
                                    mergedEvents.push(newEvent);
                                }
                            });
                            
                            mergedAppointments[existingIndex] = {
                                ...mergedAppointments[existingIndex],
                                events: mergedEvents
                            };
                        }
                    }
                });
            }
            
                                    // console.log('🔍 [fetchHomeData] 최종 병합된 appointments:', mergedAppointments);
            return mergedAppointments;
        });
        
        setMarkedDates(prev => {
            const mergedMarkedDates = { ...prev, ...newMarkedDates };
                                    // console.log('🔍 [fetchHomeData] 최종 병합된 markedDates:', mergedMarkedDates);
            return mergedMarkedDates;
        });
        
        // 전체 이벤트 데이터를 저장 (달력 클릭 시 사용)
        setAllEvents(prev => {
            const mergedAllEvents = { ...prev, ...newAllEvents };
                                    // console.log('🔍 [fetchHomeData] 최종 병합된 allEvents:', mergedAllEvents);
            return mergedAllEvents;
        });
        
        // 🚨 중요: API 응답과 관계없이 항상 7일간 카드 생성 보장
                            // console.log('🔍 [홈탭] API 응답 처리 완료, 7일간 카드 생성 확인');
        }).catch(error => {
            console.error('🔍 [홈탭] events API 오류:', error);
            
            // 🚨 중요: 서버 오류 시 전역 백업 상태 확인 및 복원!
            // 서버 오류 발생, 전역 백업 상태 확인
            
            // 전역 백업 상태가 있으면 그대로 복원
            if (global.backupAppointments && global.backupAppointments.length > 0) {
                // catch 블록에서 전역 백업 상태 복원
                setAppointments(global.backupAppointments);
                setMarkedDates(global.backupMarkedDates || {});
                setAllEvents(global.backupAllEvents || {});
            } else {
                // 전역 백업 상태가 없어 기본값 설정
                const upcoming = [];
                for (let i = 0; i < 7; i++) {
                    // UTC 기준으로 날짜 계산 (로컬 시간대 변환 문제 해결)
                    const utcYear = today.getUTCFullYear();
                    const utcMonth = today.getUTCMonth();
                    const utcDate = today.getUTCDate() + i;
                    
                    // UTC 기준으로 날짜 문자열 생성
                    const dateString = `${utcYear}-${String(utcMonth + 1).padStart(2, '0')}-${String(utcDate).padStart(2, '0')}`;
                    upcoming.push({
                        date: dateString,
                        events: []
                    });
                    // catch 블록 날짜
                }
                // catch 블록 최종 upcoming 배열
                
                setAppointments(upcoming);
                setMarkedDates({});
                setAllEvents({});
            }
        });

    }, []);

    const fetchNotifications = useCallback(async () => {
        try {
            if (!currentUser) return;
        const response = await fetch(`${API_BASE_URL}/notifications/${currentUser.employee_id}`);
            if (response.ok) {
                const data = await response.json();
                setUnreadCount(data.unread_count || 0);
            }
        } catch (error) {
            console.error('알림 조회 실패:', error);
        }
    }, []);

    useFocusEffect(useCallback(() => {
        // 🚨 중요: 현재 상태를 백업하여 보존!
        const currentAppointments = appointments;
        const currentMarkedDates = markedDates;
        const currentAllEvents = allEvents;
        

        
        // 전역 변수 확인 후 처리
        if (global.newPersonalSchedule && !isProcessingSchedule.current) {
            // 🚨 중요: 중복 실행 방지
            isProcessingSchedule.current = true;
            
            const newSchedule = global.newPersonalSchedule;
            const dateString = newSchedule.date;
            
            // appointments 상태 즉시 업데이트
            setAppointments(prev => {
                const newAppointments = [...prev];
                const existingDateIndex = newAppointments.findIndex(item => item.date === dateString);
                
                if (existingDateIndex >= 0) {
                    // 🚨 중요: 데이터 무결성 검증
                    const existingEvents = newAppointments[existingDateIndex].events || [];
                    const validEvents = getSafeValidEvents(existingEvents);
                    
                    newAppointments[existingDateIndex] = {
                        ...newAppointments[existingDateIndex],
                        events: [...validEvents, newSchedule]
                    };
                    // 기존 날짜에 일정 추가
                } else {
                    newAppointments.push({
                        date: dateString,
                        events: [newSchedule]
                    });
                    // 새로운 날짜에 일정 추가
                }
                
                // 🚨 중요: 반복 일정 처리
                if (newSchedule.isRecurring) {
                    // 반복일정 처리 시작
                    
                    if (newSchedule.recurrenceType === 'daily') {
                        // 일간 반복 처리 시작 - 3650일
                        // 3650일간 반복 일정 생성 (10년)
                        for (let day = 1; day <= 3650; day++) {
                            const nextDate = new Date(dateString);
                            nextDate.setDate(nextDate.getDate() + day);
                            const nextDateString = nextDate.toISOString().split('T')[0];
                            
                            // 이미 존재하는 날짜인지 확인
                            const nextDateIndex = newAppointments.findIndex(item => item.date === nextDateString);
                            
                            if (nextDateIndex >= 0) {
                                // 기존 날짜에 반복 일정 추가
                                // 기존 날짜에 반복일정 추가
                                const existingEvents = newAppointments[nextDateIndex].events || [];
                                const validEvents = getSafeValidEvents(existingEvents);
                                
                                newAppointments[nextDateIndex] = {
                                    ...newAppointments[nextDateIndex],
                                    events: [...validEvents, { ...newSchedule, date: nextDateString }]
                                };
                            } else {
                                // 새로운 날짜에 반복 일정 추가
                                newAppointments.push({
                                    date: nextDateString,
                                    events: [{ ...newSchedule, date: nextDateString }]
                                });
                            }
                        }
                    } else if (newSchedule.recurrenceType === 'weekly') {
                        // 주간 반복 처리 시작 - 800주
                        // 800주간 반복 일정 생성 (약 15년)
                        for (let week = 1; week <= 800; week++) {
                            const nextDate = new Date(dateString);
                            nextDate.setDate(nextDate.getDate() + (week * 7));
                            const nextDateString = nextDate.toISOString().split('T')[0];
                            
                            // 이미 존재하는 날짜인지 확인
                            const nextDateIndex = newAppointments.findIndex(item => item.date === nextDateString);
                            
                            if (nextDateIndex >= 0) {
                                // 기존 날짜에 반복 일정 추가
                                const existingEvents = newAppointments[nextDateIndex].events || [];
                                const validEvents = getSafeValidEvents(existingEvents);
                                
                                newAppointments[nextDateIndex] = {
                                    ...newAppointments[nextDateIndex],
                                    events: [...validEvents, { ...newSchedule, date: nextDateString }]
                                };
                            } else {
                                // 새로운 날짜에 반복 일정 추가
                                newAppointments.push({
                                    date: nextDateString,
                                    events: [{ ...newSchedule, date: nextDateString }]
                                });
                            }
                        }
                    } else if (newSchedule.recurrenceType === 'monthly') {
                        // 월간 반복 처리 시작 - 120개월
                        // 120개월간 반복 일정 생성 (10년)
                        for (let month = 1; month <= 120; month++) {
                            const nextDate = new Date(dateString);
                            nextDate.setMonth(nextDate.getMonth() + month);
                            const nextDateString = nextDate.toISOString().split('T')[0];
                            
                            // 이미 존재하는 날짜인지 확인
                            const nextDateIndex = newAppointments.findIndex(item => item.date === nextDateString);
                            
                            if (nextDateIndex >= 0) {
                                // 기존 날짜에 반복 일정 추가
                                const existingEvents = newAppointments[nextDateIndex].events || [];
                                const validEvents = getSafeValidEvents(existingEvents);
                                
                                newAppointments[nextDateIndex] = {
                                    ...newAppointments[nextDateIndex],
                                    events: [...validEvents, { ...newSchedule, date: nextDateString }] 
                                };
                            } else {
                                // 새로운 날짜에 반복 일정 추가
                                newAppointments.push({
                                    date: nextDateString,
                                    events: [{ ...newSchedule, date: nextDateString }]
                                });
                            }
                        }
                    }
                }
                
                // 🚨 중요: 최종 데이터 무결성 검증
                const validatedAppointments = newAppointments.map(item => ({
                    ...item,
                    events: (item.events || []).filter(event => event && typeof event === 'object')
                }));
                
                // 업데이트된 appointments
                return validatedAppointments;
            });
            
            // markedDates 상태 즉시 업데이트
            setMarkedDates(prev => {
                const newMarkedDates = { ...prev };
                newMarkedDates[dateString] = {
                    selected: true,
                    selectedColor: currentColors.gray
                };
                
                // 🚨 중요: 반복 일정 markedDates 추가
                if (newSchedule.isRecurring) {
                    if (newSchedule.recurrenceType === 'daily') {
                                    // 3650일간 반복 일정 markedDates 추가 (10년)
            for (let day = 1; day <= 3650; day++) {
                            const nextDate = new Date(dateString);
                            nextDate.setDate(nextDate.getDate() + day);
                            const nextDateString = nextDate.toISOString().split('T')[0];
                            
                            newMarkedDates[nextDateString] = {
                                selected: true,
                                selectedColor: currentColors.gray
                            };
                            // 일간 반복 일정 markedDates 추가
                        }
                    } else if (newSchedule.recurrenceType === 'weekly') {
                        // 800주간 반복 일정 markedDates 추가
                        for (let week = 1; week <= 800; week++) {
                            const nextDate = new Date(dateString);
                            nextDate.setDate(nextDate.getDate() + (week * 7));
                            const nextDateString = nextDate.toISOString().split('T')[0];
                            
                            newMarkedDates[nextDateString] = {
                                selected: true,
                                selectedColor: currentColors.gray
                            };
                            // 주간 반복 일정 markedDates 추가
                        }
                    } else if (newSchedule.recurrenceType === 'monthly') {
                        // 120개월간 반복 일정 markedDates 추가
                        for (let month = 1; month <= 120; month++) {
                            const nextDate = new Date(dateString);
                            nextDate.setMonth(nextDate.getMonth() + month);
                            const nextDateString = nextDate.toISOString().split('T')[0];
                            
                            newMarkedDates[nextDateString] = {
                                selected: true,
                                selectedColor: currentColors.gray
                            };
                            // 월간 반복 일정 markedDates 추가
                        }
                    }
                }
                
                // 업데이트된 markedDates
                return newMarkedDates;
            });
            
            // allEvents 상태 즉시 업데이트
            setAllEvents(prev => {
                const newAllEvents = { ...prev };
                
                if (newAllEvents[dateString]) {
                    // 🚨 중요: 데이터 무결성 검증
                    const existingEvents = newAllEvents[dateString] || [];
                    const validEvents = getSafeValidEvents(existingEvents);
                    newAllEvents[dateString] = [...validEvents, newSchedule];
                } else {
                    newAllEvents[dateString] = [newSchedule];
                }
                
                // 🚨 중요: 반복 일정 allEvents 추가 (endDate 고려)
                if (newSchedule.isRecurring) {
                    // 종료 날짜 확인
                    const endDate = newSchedule.endDate ? new Date(newSchedule.endDate) : null;
                    const startDate = new Date(dateString);
                    
                    // endDate 처리 시작
                    
                    // endDate 정보 확인
                    
                    if (newSchedule.recurrenceType === 'daily') {
                        // 일간 반복 일정 allEvents 추가 (endDate까지)
                        let day = 1;
                        let generatedCount = 0;
                        
                        // 🚨 중요: endDate가 설정된 경우 정확한 일수 계산
                        let maxDays = 3650; // 기본값: 10년
                        if (endDate) {
                            // endDate까지의 정확한 일수 계산 (endDate 포함)
                            const endDateOnly = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
                            const startDateOnly = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
                            maxDays = Math.ceil((endDateOnly - startDateOnly) / (1000 * 60 * 60 * 24)) + 1;
                            // endDate 기반 일수 계산
                        }
                        
                        for (let day = 1; day <= maxDays; day++) {
                            const nextDate = new Date(startDate);
                            nextDate.setDate(startDate.getDate() + day);
                            const nextDateString = nextDate.toISOString().split('T')[0];
                            
                            // 🚨 중요: endDate가 설정된 경우 해당 날짜까지만 생성 (endDate 포함)
                            if (endDate && nextDate > endDate) {
                                // endDate 초과, 생성 중단
                                break;
                            }
                            
                            if (newAllEvents[nextDateString]) {
                                const existingEvents = newAllEvents[nextDateString] || [];
                                const validEvents = getSafeValidEvents(existingEvents);
                                newAllEvents[nextDateString] = [...validEvents, { ...newSchedule, date: nextDateString }];
                            } else {
                                newAllEvents[nextDateString] = [{ ...newSchedule, date: nextDateString }];
                            }
                            
                            generatedCount++;
                        }
                        
                        // 일간 반복 완료
                    } else if (newSchedule.recurrenceType === 'weekly') {
                        // 주간 반복 일정 allEvents 추가 (endDate까지)
                        let generatedCount = 0;
                        
                        // 🚨 중요: endDate가 설정된 경우 정확한 주수 계산
                        let maxWeeks = 800; // 기본값: 800주
                        if (endDate) {
                            // endDate까지의 정확한 주수 계산 (endDate 포함)
                            const endDateOnly = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
                            const startDateOnly = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
                            const daysDiff = Math.ceil((endDateOnly - startDateOnly) / (1000 * 60 * 60 * 24));
                            maxWeeks = Math.ceil(daysDiff / 7) + 1;
                            console.log('�� [반복일정] 주간 반복 - endDate 기반 주수 계산:', {
                                startDate: startDateOnly.toISOString().split('T')[0],
                                endDate: endDateOnly.toISOString().split('T')[0],
                                daysDiff: daysDiff,
                                calculatedWeeks: maxWeeks
                            });
                        }
                        
                        for (let week = 1; week <= maxWeeks; week++) {
                            const nextDate = new Date(startDate);
                            nextDate.setDate(startDate.getDate() + (week * 7));
                            const nextDateString = nextDate.toISOString().split('T')[0];
                            
                            // 🚨 중요: endDate가 설정된 경우 해당 날짜까지만 생성 (endDate 포함)
                            if (endDate && nextDate > endDate) {
                                console.log('�� [반복일정] 주간 반복 - endDate 초과, 생성 중단:', {
                                    nextDate: nextDateString,
                                    endDate: endDate.toISOString().split('T')[0],
                                    generatedCount
                                });
                                break;
                            }
                            
                            if (newAllEvents[nextDateString]) {
                                const existingEvents = newAllEvents[nextDateString] || [];
                                const validEvents = getSafeValidEvents(existingEvents);
                                newAllEvents[nextDateString] = [...validEvents, { ...newSchedule, date: nextDateString }];
                            } else {
                                newAllEvents[nextDateString] = [{ ...newSchedule, date: nextDateString }];
                            }
                            
                            generatedCount++;
                        }
                        
                        // console.log('🔍 [반복일정] 주간 반복 완료 - 총 생성된 일정 수:', generatedCount);
                    } else if (newSchedule.recurrenceType === 'monthly') {
                        // 월간 반복 일정 allEvents 추가 (endDate까지)
                        let generatedCount = 0;
                        
                        // 🚨 중요: endDate가 설정된 경우 정확한 개월수 계산
                        let maxMonths = 120; // 기본값: 120개월
                        if (endDate) {
                            // endDate까지의 정확한 개월수 계산 (endDate 포함)
                            const endDateOnly = new Date(endDate.getFullYear(), endDate.getMonth(), endDate.getDate());
                            const startDateOnly = new Date(startDate.getFullYear(), startDate.getMonth(), startDate.getDate());
                            const monthsDiff = (endDateOnly.getFullYear() - startDateOnly.getFullYear()) * 12 + (endDateOnly.getMonth() - startDateOnly.getMonth());
                            maxMonths = monthsDiff + 1;
                            console.log('�� [반복일정] 월간 반복 - endDate 기반 개월수 계산:', {
                                startDate: startDateOnly.toISOString().split('T')[0],
                                endDate: endDateOnly.toISOString().split('T')[0],
                                monthsDiff: monthsDiff,
                                calculatedMonths: maxMonths
                            });
                        }
                        
                        for (let month = 1; month <= maxMonths; month++) {
                            const nextDate = new Date(startDate);
                            nextDate.setMonth(startDate.getMonth() + month);
                            const nextDateString = nextDate.toISOString().split('T')[0];
                            
                            // 🚨 중요: endDate가 설정된 경우 해당 날짜까지만 생성 (endDate 포함)
                            if (endDate && nextDate > endDate) {
                                console.log('�� [반복일정] 월간 반복 - endDate 초과, 생성 중단:', {
                                    nextDate: nextDateString,
                                    endDate: endDate.toISOString().split('T')[0],
                                    generatedCount
                                });
                                break;
                            }
                            
                            if (newAllEvents[nextDateString]) {
                                const existingEvents = newAllEvents[nextDateString] || [];
                                const validEvents = getSafeValidEvents(existingEvents);
                                newAllEvents[nextDateString] = [...validEvents, { ...newSchedule, date: nextDateString }];
                            } else {
                                newAllEvents[nextDateString] = [{ ...newSchedule, date: nextDateString }];
                            }
                            
                            generatedCount++;
                        }
                        
                        // console.log('🔍 [반복일정] 월간 반복 완료 - 총 생성된 일정 수:', generatedCount);
                    }
                }
                
                // 업데이트된 allEvents
                return newAllEvents;
            });
            
            // 🚨 중요: allEvents 상태 업데이트 완료 후 markedDates 동기화
            // useEffect에서 자동으로 처리됨
            
            // 전역 변수 초기화 (전역변수 시스템 제거됨)
            // global.newPersonalSchedule = undefined;
                            // console.log('🔍 [홈탭] useFocusEffect 전역 변수 일정 처리 완료');
            
            // 🚨 중요: 중복 실행 방지 해제
            isProcessingSchedule.current = false;
            
            // 🚨 중요: 반복 일정 처리 완료 후 상태 확인
            if (newSchedule.isRecurring) {
                // 반복 일정 처리 완료
            }
            
            // 상태 업데이트 후 최종 확인
            setTimeout(() => {
                // 상태 업데이트 후 최종 확인
                
                // 반복 일정 데이터 상세 확인
                if (newSchedule.isRecurring) {
                    // 반복 일정 상세 정보
                    
                    // markedDates에서 반복 일정 날짜들 확인
                    const recurringDates = Object.keys(markedDates).filter(date => 
                        date !== dateString && markedDates[date]?.selected
                    );
                    
                    // allEvents에서 반복 일정 이벤트들 확인
                    const recurringEvents = Object.keys(allEvents).filter(date => 
                        date !== dateString && allEvents[date]?.length > 0
                    );
                }
            }, 100);
        }
        
        // 🚨 중요: 새 파티 처리 (전역변수 시스템 제거됨)
        // if (global.newPartySchedule) {
        //     const newParty = global.newPartySchedule;
        //     const dateString = newParty.date;
        //     
        //     // appointments 상태 즉시 업데이트
        //     setAppointments(prev => {
        //         const newAppointments = [...prev];
        //         const existingDateIndex = newAppointments.findIndex(item => item.date === dateString);
        //         
        //         if (existingDateIndex >= 0) {
        //             // 🚨 중요: 데이터 무결성 검증
        //             const existingEvents = newAppointments[existingDateIndex].events || [];
        //             const validEvents = getSafeValidEvents(existingEvents);
        //             
        //             newAppointments[existingDateIndex] = {
        //                 ...newAppointments[existingDateIndex],
        //                 events: [...validEvents, newParty]
        //             };
        //             // 기존 날짜에 새 파티 추가
        //         } else {
        //             newAppointments.push({
        //                 date: dateString,
        //                 events: [newParty]
        //             });
        //             // 새로운 날짜에 새 파티 추가
        //         }
        //         
        //         // 🚨 중요: 최종 데이터 무결성 검증
        //         const validatedAppointments = newAppointments.map(item => ({
        //             ...item,
        //             events: (item.events || []).filter(event => event && typeof event === 'object')
        //         }));
        //         
        //         // 업데이트된 appointments
        //         return validatedAppointments;
        //     });
        //     
        //     // markedDates 상태 즉시 업데이트
        //     setMarkedDates(prev => {
        //         const newMarkedDates = { ...prev };
        //         // 랜덤런치 파티인지 확인하여 색상 결정
        //         const isRandomLunch = newParty && newParty.is_from_match === true;
        //         const selectedColor = isRandomLunch ? '#F4D160' : currentColors.primary; // 랜덤런치는 노란색, 일반 파티는 파란색
        //         
        //         newMarkedDates[dateString] = {
        //             selected: true,
        //             selectedColor: selectedColor
        //         };
        //         return newMarkedDates;
        //     });
        //     
        //     // allEvents 상태 즉시 업데이트
        //     setAllEvents(prev => {
        //         const newAllEvents = { ...prev };
        //         if (newAllEvents[dateString]) {
        //             // 🚨 중요: 데이터 무결성 검증
        //             const existingEvents = newAllEvents[dateString] || [];
        //             const validEvents = getSafeValidEvents(existingEvents);
        //             newAllEvents[dateString] = [...validEvents, newParty];
        //         } else {
        //             newAllEvents[dateString] = [newParty];
        //         }
        //         // console.log('🔍 [홈탭] useFocusEffect: allEvents 업데이트 완료, 날짜:', dateString);
        //         return newAllEvents;
        //     });
        //     
        //     // 전역 변수 초기화 (전역변수 시스템 제거됨)
        //     // global.newPartySchedule = undefined;
        //     // 전역 변수 새 파티 처리 완료
        // } else {
        //     // fetchHomeData 실행
        //     // 🚨 중요: 백업된 상태를 전달하여 fetchHomeData에서 보존!
        //     fetchHomeData(currentAppointments, currentMarkedDates, currentAllEvents);
        // }
    }, [currentColors.gray]));
    
    useFocusEffect(useCallback(() => {
        fetchNotifications();
    }, []));

    // unreadCount가 변경될 때마다 route params 업데이트
    useEffect(() => {
        navigation.setParams({ unreadCount });
    }, [unreadCount, navigation]);

    const handleMatchPress = async () => {
        // 제안 기반 랜덤 런치 화면으로 이동
        safeNavigateToTab(navigation, '파티', 'RandomLunch');
    };

    const goToAddPersonalSchedule = (date) => {
        // console.log('🔍 goToAddPersonalSchedule 호출, date:', date);
        setModalData({ visible: false, events: [] });
        safeNavigateToTab(navigation, "파티", "CreatePersonalSchedule", { date });
    };

    // 기타 일정 추가 후 홈 데이터 새로고침을 위한 리스너
    useFocusEffect(useCallback(() => {
        const unsubscribe = navigation.addListener('focus', () => {
            // 포커스 이벤트 발생, 홈 데이터 새로고침
            // console.log('🔍 [두번째 useFocusEffect] 포커스 이벤트 발생');
            
            // 전역 변수에서 새로운 일정 확인
        if (global.newPersonalSchedule && !isProcessingSchedule.current) {
            // console.log('🔍 [두번째 useFocusEffect] 전역 변수 일정 감지:', global.newPersonalSchedule);
            // 포커스 시 전역 변수 일정 감지
            
            // 🚨 중요: 중복 실행 방지
            isProcessingSchedule.current = true;
                
                const newSchedule = global.newPersonalSchedule;
                const dateString = newSchedule.date;
                
                // appointments 상태 즉시 업데이트
                setAppointments(prev => {
                    const newAppointments = [...prev];
                    const existingDateIndex = newAppointments.findIndex(item => item.date === dateString);
                    
                    if (existingDateIndex >= 0) {
                        newAppointments[existingDateIndex] = {
                            ...newAppointments[existingDateIndex],
                            events: [...newAppointments[existingDateIndex].events, newSchedule]
                        };
                    } else {
                        newAppointments.push({
                            date: dateString,
                            events: [newSchedule]
                        });
                    }
                    
                    return newAppointments;
                });
                
                // markedDates 상태 즉시 업데이트
                setMarkedDates(prev => {
                    const newMarkedDates = { ...prev };
                    newMarkedDates[dateString] = {
                        selected: true,
                        selectedColor: '#64748B' // 기타 일정 색상
                    };
                    return newMarkedDates;
                });
                
                // allEvents 상태 즉시 업데이트
                setAllEvents(prev => {
                    const newAllEvents = { ...prev };
                    if (newAllEvents[dateString]) {
                        newAllEvents[dateString] = [...newAllEvents[dateString], newSchedule];
                    } else {
                        newAllEvents[dateString] = [newSchedule];
                    }
                    // allEvents 업데이트 완료, 날짜
                    return newAllEvents;
                });
                
                // 🚨 중요: 중복 실행 방지 해제
                isProcessingSchedule.current = false;
                
                // 상태 업데이트 완료 확인
                // 모든 상태 업데이트 완료 - appointments, markedDates, allEvents
                
                // 전역 변수 초기화
                global.newPersonalSchedule = undefined;
                // 포커스 시 전역 변수 일정 처리 완료
                
                // 🚨 중요: 전역 변수 처리 완료 후 fetchHomeData 건너뛰기
                // 새로 생성된 일정이 서버 API 호출로 덮어써지는 것을 방지
                // console.log('🔍 [useFocusEffect] 전역 변수 일정 처리 완료, fetchHomeData 건너뛰기');
                return;
            }
            
            // 전역 변수에서 수정된 일정 확인
            if (global.updatedPersonalSchedule && !isProcessingSchedule.current) {
                // 🚨 디버깅: 전역 변수 존재 확인
                console.log('🔍 [App.js] useFocusEffect에서 전역 변수 존재 확인:', {
                    hasGlobalVar: !!global.updatedPersonalSchedule,
                    isProcessing: isProcessingSchedule.current,
                    globalVarContent: global.updatedPersonalSchedule
                });
                
                // 🚨 중요: 중복 실행 방지
                isProcessingSchedule.current = true;
                
                const updatedSchedule = global.updatedPersonalSchedule;
                const originalDate = updatedSchedule.originalDate;
                const newDate = updatedSchedule.newDate;
                const scheduleData = updatedSchedule.schedule;
                const editMode = updatedSchedule.editMode;
                
                // 🚨 디버깅: 전역 변수 감지 로그
                console.log('🔍 [App.js] useFocusEffect에서 전역 변수 감지:', {
                    originalDate,
                    newDate,
                    scheduleId: scheduleData.id || scheduleData._id,
                    editMode,
                    timestamp: updatedSchedule.timestamp
                });
                
                // 🚨 중요: 전체 반복 일정 수정인지 확인
                if (editMode === 'recurring_all') {
                    console.log('🔍 [App.js] 전체 반복 일정 수정 모드 감지');
                    console.log('🔍 [App.js] 날짜 변경 정보:', {
                        originalDate: scheduleData.originalDate,
                        newDate: scheduleData.newDate,
                        hasDateChange: scheduleData.originalDate !== scheduleData.newDate
                    });
                    
                    // 🚨 중요: 전체 반복 일정 수정에서는 모든 반복 일정을 새 날짜로 이동
                    if (scheduleData.originalDate && scheduleData.newDate && scheduleData.originalDate !== scheduleData.newDate) {
                        console.log('🔍 [App.js] 전체 반복 일정 수정 - 모든 반복 일정을 새 날짜로 이동');
                        
                        // 1. 기존 날짜에서 모든 반복 일정 제거하고 새 날짜에 추가 (한 번에 처리)
                        setAppointments(prev => {
                            console.log('🔍 [App.js] appointments 상태 업데이트 시작');
                            
                            // 기존 날짜에서 반복 일정 제거
                            let newAppointments = prev.map(appointment => {
                                if (appointment.date === scheduleData.originalDate) {
                                    return {
                                        ...appointment,
                                        events: (appointment.events || []).filter(event => {
                                            // scheduleData.schedule.id와 일치하는 일정 제거
                                            const scheduleId = scheduleData.schedule?.id || scheduleData.schedule?._id;
                                            return event.id !== scheduleId && event._id !== scheduleId;
                                        })
                                    };
                                }
                                return appointment;
                            }).filter(appointment => appointment.events && Array.isArray(appointment.events) && appointment.events.length > 0); // 빈 날짜 제거
                            
                            // 반복 일정 생성 함수
                            const generateRecurringEvents = () => {
                                const events = [];
                                const schedule = scheduleData.schedule;
                                
                                if (!schedule.isRecurring) return events;
                                
                                let currentDate = new Date(scheduleData.newDate);
                                const endDate = schedule.endType === 'never' ? new Date('2030-12-31') : new Date(schedule.endDate);
                                
                                console.log('🔍 [App.js] 반복 일정 생성 시작:', {
                                    startDate: scheduleData.newDate,
                                    endDate: schedule.endDate,
                                    recurrenceType: schedule.recurrenceType,
                                    recurrenceInterval: schedule.recurrenceInterval
                                });
                                
                                while (currentDate <= endDate) {
                                    const dateStr = currentDate.toISOString().split('T')[0];
                                    events.push({
                                        ...schedule,
                                        id: `${schedule.id}_${dateStr}`,
                                        date: dateStr,
                                        title: schedule.title,
                                        restaurant: schedule.restaurant,
                                        time: schedule.time,
                                        location: schedule.location,
                                        description: schedule.description,
                                        attendees: schedule.attendees,
                                        isRecurring: schedule.isRecurring,
                                        recurrenceType: schedule.recurrenceType,
                                        recurrenceInterval: schedule.recurrenceInterval,
                                        endType: schedule.endType,
                                        endDate: schedule.endDate
                                    });
                                    
                                    // 다음 반복 날짜 계산
                                    if (schedule.recurrenceType === 'daily') {
                                        currentDate.setDate(currentDate.getDate() + schedule.recurrenceInterval);
                                    } else if (schedule.recurrenceType === 'weekly') {
                                        currentDate.setDate(currentDate.getDate() + (7 * schedule.recurrenceInterval));
                                    } else if (schedule.recurrenceType === 'monthly') {
                                        currentDate.setMonth(currentDate.getMonth() + schedule.recurrenceInterval);
                                    }
                                }
                                
                                console.log('🔍 [App.js] 생성된 반복 일정:', events.length, '개');
                                return events;
                            };
                            
                            const recurringEvents = generateRecurringEvents();
                            
                            // 새 날짜에 반복 일정들 추가
                            const existingDateIndex = newAppointments.findIndex(item => item.date === scheduleData.newDate);
                            
                            if (existingDateIndex >= 0) {
                                // 기존 날짜에 반복 일정들 추가
                                newAppointments[existingDateIndex].events.push(...recurringEvents);
                                console.log('🔍 [App.js] 기존 날짜에 반복 일정 추가:', scheduleData.newDate, recurringEvents.length, '개');
                            } else {
                                // 새로운 날짜에 반복 일정들 추가
                                newAppointments.push({
                                    date: scheduleData.newDate,
                                    events: recurringEvents
                                });
                                console.log('🔍 [App.js] 새 날짜에 반복 일정 추가:', scheduleData.newDate, recurringEvents.length, '개');
                            }
                            
                            // 날짜별로 정렬
                            newAppointments.sort((a, b) => new Date(a.date) - new Date(b.date));
                            
                            console.log('🔍 [App.js] appointments 업데이트 완료:', newAppointments.length, '개 날짜');
                            return newAppointments;
                        });
                        
                        // 3. allEvents 상태도 동일하게 업데이트
                        setAllEvents(prev => {
                            const newAllEvents = { ...prev };
                            
                            // 기존 날짜에서 일정 제거
                            if (newAllEvents[scheduleData.originalDate] && Array.isArray(newAllEvents[scheduleData.originalDate])) {
                                newAllEvents[scheduleData.originalDate] = newAllEvents[scheduleData.originalDate].filter(event => {
                                    // scheduleData.schedule.id와 일치하는 일정 제거
                                    const scheduleId = scheduleData.schedule?.id || scheduleData.schedule?._id;
                                    return event.id !== scheduleId && event._id !== scheduleId;
                                });
                                
                                // 빈 배열이면 해당 날짜 키 제거
                                if (newAllEvents[scheduleData.originalDate].length === 0) {
                                    delete newAllEvents[scheduleData.originalDate];
                                }
                            }
                            
                            // 새 날짜에 반복 일정들 추가
                            const schedule = scheduleData.schedule;
                            if (schedule.isRecurring) {
                                let currentDate = new Date(scheduleData.newDate);
                                const endDate = schedule.endType === 'never' ? new Date('2030-12-31') : new Date(schedule.endDate);
                                
                                while (currentDate <= endDate) {
                                    const dateStr = currentDate.toISOString().split('T')[0];
                                    
                                    if (newAllEvents[dateStr]) {
                                        newAllEvents[dateStr].push({
                                            ...schedule,
                                            id: `${schedule.id}_${dateStr}`,
                                            date: dateStr,
                                            title: schedule.title,
                                            restaurant: schedule.restaurant,
                                            time: schedule.time,
                                            location: schedule.location,
                                            description: schedule.description,
                                            attendees: schedule.attendees,
                                            isRecurring: schedule.isRecurring,
                                            recurrenceType: schedule.recurrenceType,
                                            recurrenceInterval: schedule.recurrenceInterval,
                                            endType: schedule.endType,
                                            endDate: schedule.endDate
                                });
                            } else {
                                        newAllEvents[dateStr] = [{
                                            ...schedule,
                                            id: `${schedule.id}_${dateStr}`,
                                            date: dateStr,
                                            title: schedule.title,
                                            restaurant: schedule.restaurant,
                                            time: schedule.time,
                                            location: schedule.location,
                                            description: schedule.description,
                                            attendees: schedule.attendees,
                                            isRecurring: schedule.isRecurring,
                                            recurrenceType: schedule.recurrenceType,
                                            recurrenceInterval: schedule.recurrenceInterval,
                                            endType: schedule.endType,
                                            endDate: schedule.endDate
                                        }];
                                    }
                                    
                                    // 다음 반복 날짜 계산
                                    if (schedule.recurrenceType === 'daily') {
                                        currentDate.setDate(currentDate.getDate() + schedule.recurrenceInterval);
                                    } else if (schedule.recurrenceType === 'weekly') {
                                        currentDate.setDate(currentDate.getDate() + (7 * schedule.recurrenceInterval));
                                    } else if (schedule.recurrenceType === 'monthly') {
                                        currentDate.setMonth(currentDate.getMonth() + schedule.recurrenceInterval);
                                    }
                                }
                            }
                            
                            return newAllEvents;
                        });
                        
                        // 4. markedDates 업데이트
                        setMarkedDates(prev => {
                            const newMarkedDates = { ...prev };
                            
                            // 🚨 중요: 반복 일정의 모든 기존 날짜 마킹 제거
                            const schedule = scheduleData.schedule;
                            if (schedule.isRecurring) {
                                // 기존 반복 패턴의 모든 날짜 계산
                                let oldCurrentDate = new Date(scheduleData.originalDate);
                                const oldEndDate = schedule.endType === 'never' ? new Date('2030-12-31') : new Date(schedule.endDate);
                                
                                console.log('🔍 [App.js] markedDates 업데이트 - 기존 반복 일정 마킹 제거 시작:', {
                                    startDate: scheduleData.originalDate,
                                    endDate: schedule.endDate,
                                    recurrenceType: schedule.recurrenceType,
                                    recurrenceInterval: schedule.recurrenceInterval
                                });
                                
                                while (oldCurrentDate <= oldEndDate) {
                                    const oldDateStr = oldCurrentDate.toISOString().split('T')[0];
                                    
                                    // 기존 반복 날짜의 마킹 제거
                                    if (newMarkedDates[oldDateStr]) {
                                        delete newMarkedDates[oldDateStr];
                                        console.log('🔍 [App.js] 기존 반복 일정 날짜 마킹 제거:', oldDateStr);
                                    }
                                    
                                    // 다음 반복 날짜 계산
                                    if (schedule.recurrenceType === 'daily') {
                                        oldCurrentDate.setDate(oldCurrentDate.getDate() + schedule.recurrenceInterval);
                                    } else if (schedule.recurrenceType === 'weekly') {
                                        oldCurrentDate.setDate(oldCurrentDate.getDate() + (7 * schedule.recurrenceInterval));
                                    } else if (schedule.recurrenceType === 'monthly') {
                                        oldCurrentDate.setMonth(oldCurrentDate.getMonth() + schedule.recurrenceInterval);
                                    }
                                }
                                
                                console.log('🔍 [App.js] 기존 반복 일정 마킹 제거 완료');
                            } else {
                                // 단일 일정인 경우 기존 날짜 마킹만 제거
                                if (newMarkedDates[scheduleData.originalDate]) {
                                    delete newMarkedDates[scheduleData.originalDate];
                                    console.log('🔍 [App.js] 단일 일정 기존 날짜 마킹 제거:', scheduleData.originalDate);
                                }
                            }
                            
                            // 🚨 중요: 반복 일정의 모든 새 날짜에 마킹 추가
                            if (schedule.isRecurring) {
                                let newCurrentDate = new Date(scheduleData.newDate);
                                const newEndDate = schedule.endType === 'never' ? new Date('2030-12-31') : new Date(schedule.endDate);
                                
                                console.log('🔍 [App.js] markedDates 업데이트 - 새 반복 일정 마킹 시작:', {
                                    startDate: scheduleData.newDate,
                                    endDate: schedule.endDate,
                                    recurrenceType: schedule.recurrenceType,
                                    recurrenceInterval: schedule.recurrenceInterval
                                });
                                
                                while (newCurrentDate <= newEndDate) {
                                    const newDateStr = newCurrentDate.toISOString().split('T')[0];
                                    
                                    // 각 반복 날짜에 마킹 추가
                                    newMarkedDates[newDateStr] = {
                                        selected: true,
                                        selectedColor: '#64748B' // 기타 일정 색상
                                    };
                                    
                                    console.log('🔍 [App.js] 새 반복 일정 날짜 마킹 추가:', newDateStr);
                                    
                                    // 다음 반복 날짜 계산
                                    if (schedule.recurrenceType === 'daily') {
                                        newCurrentDate.setDate(newCurrentDate.getDate() + schedule.recurrenceInterval);
                                    } else if (schedule.recurrenceType === 'weekly') {
                                        newCurrentDate.setDate(newCurrentDate.getDate() + (7 * schedule.recurrenceInterval));
                                    } else if (schedule.recurrenceType === 'monthly') {
                                        newCurrentDate.setMonth(newCurrentDate.getMonth() + schedule.recurrenceInterval);
                                    }
                                }
                                
                                console.log('🔍 [App.js] 새 반복 일정 마킹 추가 완료');
                            } else {
                                // 단일 일정인 경우 새 날짜에만 마킹 추가
                            newMarkedDates[scheduleData.newDate] = {
                                selected: true,
                                selectedColor: '#64748B' // 기타 일정 색상
                            };
                                
                                console.log('🔍 [App.js] 단일 일정 새 날짜 마킹 추가:', scheduleData.newDate);
                            }
                            
                            return newMarkedDates;
                        });
                        
                        console.log('🔍 [App.js] 전체 반복 일정 수정 완료:', {
                            from: scheduleData.originalDate,
                            to: scheduleData.newDate,
                            totalEvents: scheduleData.schedule.isRecurring ? '반복 일정 생성됨' : '단일 일정'
                        });
                    } else {
                        // 날짜 변경이 없는 경우 - 기존 로직 (내용만 업데이트)
                        console.log('🔍 [App.js] 날짜 변경 없음 - 내용만 업데이트');
                        console.log('🔍 [App.js] 수정할 일정 ID:', scheduleData.schedule?.id || scheduleData.schedule?._id);
                        console.log('🔍 [App.js] 수정된 내용:', {
                            title: scheduleData.title,
                            restaurant: scheduleData.restaurant,
                            time: scheduleData.time,
                            location: scheduleData.location,
                            description: scheduleData.description
                        });
                        
                        // 🚨 디버깅: 현재 appointments 상태 확인
                        console.log('🔍 [App.js] 수정 전 appointments 상태:', appointments);
                        
                        setAppointments(prev => {
                            const newAppointments = [...prev];
                            let updateCount = 0;
                            
                            // 모든 반복 일정을 찾아서 내용 업데이트
                            newAppointments.forEach(appointment => {
                                appointment.events = appointment.events.map(event => {
                                    // scheduleData.schedule.id와 일치하는 일정 찾기
                                    const scheduleId = scheduleData.schedule?.id || scheduleData.schedule?._id;
                                    if (event.id === scheduleId || event._id === scheduleId) {
                                        updateCount++;
                                        console.log('🔍 [App.js] 일정 업데이트됨:', {
                                            date: appointment.date,
                                            eventId: event.id || event._id,
                                            oldTitle: event.title,
                                            newTitle: scheduleData.title
                                        });
                                        
                                        // 반복 일정의 내용만 업데이트 (날짜는 유지)
                                        return {
                                            ...event,
                                            title: scheduleData.title,
                                            restaurant: scheduleData.restaurant,
                                            time: scheduleData.time,
                                            location: scheduleData.location,
                                            description: scheduleData.description,
                                            attendees: scheduleData.attendees,
                                            // 반복 설정도 업데이트
                                            isRecurring: scheduleData.isRecurring,
                                            recurrenceType: scheduleData.recurrenceType,
                                            recurrenceInterval: scheduleData.recurrenceInterval,
                                            endType: scheduleData.endType,
                                            endDate: scheduleData.endDate
                                        };
                                    }
                                    return event;
                                });
                            });
                            
                            console.log('🔍 [App.js] appointments 업데이트 완료, 총', updateCount, '개 일정 수정됨');
                            return newAppointments;
                        });
                        
                        // allEvents 상태도 동일하게 업데이트
                        setAllEvents(prev => {
                            const newAllEvents = { ...prev };
                            let updateCount = 0;
                            
                            Object.keys(newAllEvents).forEach(date => {
                                newAllEvents[date] = newAllEvents[date].map(event => {
                                    // scheduleData.schedule.id와 일치하는 일정 찾기
                                    const scheduleId = scheduleData.schedule?.id || scheduleData.schedule?._id;
                                    if (event.id === scheduleId || event._id === scheduleId) {
                                        updateCount++;
                                        console.log('🔍 [App.js] allEvents 업데이트됨:', {
                                            date,
                                            eventId: event.id || event._id,
                                            oldTitle: event.title,
                                            newTitle: scheduleData.title
                                        });
                                        
                                        // 반복 일정의 내용만 업데이트 (날짜는 유지)
                                        return {
                                            ...event,
                                            title: scheduleData.title,
                                            restaurant: scheduleData.restaurant,
                                            time: scheduleData.time,
                                            location: scheduleData.location,
                                            description: scheduleData.description,
                                            attendees: scheduleData.attendees,
                                            // 반복 설정도 업데이트
                                            isRecurring: scheduleData.isRecurring,
                                            recurrenceType: scheduleData.recurrenceType,
                                            recurrenceInterval: scheduleData.recurrenceInterval,
                                            endType: scheduleData.endType,
                                            endDate: scheduleData.endDate
                                        };
                                    }
                                    return event;
                                });
                            });
                            
                            console.log('🔍 [App.js] allEvents 업데이트 완료, 총', updateCount, '개 일정 수정됨');
                            return newAllEvents;
                        });
                    }
                    
                    // 🚨 디버깅: 상태 업데이트 후 확인
                    setTimeout(() => {
                        console.log('🔍 [App.js] 상태 업데이트 후 appointments 확인:', appointments);
                        console.log('🔍 [App.js] 상태 업데이트 후 allEvents 확인:', allEvents);
                        
                        // 🚨 강제 리렌더링을 위한 상태 업데이트
                        setAppointments(prev => [...prev]);
                        setAllEvents(prev => ({ ...prev }));
                        
                        console.log('🔍 [App.js] 강제 리렌더링 실행됨');
                    }, 100);
                    
                    // 전역 변수 초기화 및 처리 완료
                    global.updatedPersonalSchedule = undefined;
                    isProcessingSchedule.current = false;
                    
                    // 전역 변수 초기화
                    global.updatedPersonalSchedule = undefined;
                    
                    return;
                }
                
                // 일반 수정 또는 단일 반복 일정 수정: 날짜 변경 처리
                console.log('🔍 [App.js] 일반 수정 또는 단일 반복 일정 수정 모드 - 날짜 변경 있음');
                
                // appointments 상태 업데이트
                setAppointments(prev => {
                    const newAppointments = [...prev];
                    
                    // 원래 날짜에서 일정 제거
                    const originalDateIndex = newAppointments.findIndex(item => item.date === originalDate);
                    if (originalDateIndex >= 0) {
                        newAppointments[originalDateIndex] = {
                            ...newAppointments[originalDateIndex],
                            events: (newAppointments[originalDateIndex].events || []).filter(event => 
                                event.id !== scheduleData.id && event._id !== scheduleData.id
                            )
                        };
                        
                        // 이벤트가 없어진 날짜는 제거
                        if (newAppointments[originalDateIndex].events && Array.isArray(newAppointments[originalDateIndex].events) && newAppointments[originalDateIndex].events.length === 0) {
                            newAppointments.splice(originalDateIndex, 1);
                        }
                    }
                    
                    // 새 날짜에 일정 추가
                    const newDateIndex = newAppointments.findIndex(item => item.date === newDate);
                    if (newDateIndex >= 0) {
                        newAppointments[newDateIndex] = {
                            ...newAppointments[newDateIndex],
                            events: [...(newAppointments[newDateIndex].events || []), scheduleData]
                        };
                    } else {
                        newAppointments.push({
                            date: newDate,
                            events: [scheduleData]
                        });
                    }
                    
                    return newAppointments;
                });
                
                // markedDates 상태 업데이트
                setMarkedDates(prev => {
                    const newMarkedDates = { ...prev };
                    
                    // 원래 날짜 마킹 제거
                    if (newMarkedDates[originalDate]) {
                        delete newMarkedDates[originalDate];
                    }
                    
                    // 새 날짜 마킹 추가
                    newMarkedDates[newDate] = {
                        selected: true,
                        selectedColor: '#64748B' // 기타 일정 색상
                    };
                    
                    return newMarkedDates;
                });
                
                // allEvents 상태 업데이트
                setAllEvents(prev => {
                    const newAllEvents = { ...prev };
                    
                    // 원래 날짜에서 일정 제거
                    if (newAllEvents[originalDate]) {
                        newAllEvents[originalDate] = newAllEvents[originalDate].filter(event => 
                            event.id !== scheduleData.id && event._id !== scheduleData.id
                        );
                        
                        // 이벤트가 없어진 날짜는 제거
                        if (newAllEvents[originalDate].length === 0) {
                            delete newAllEvents[originalDate];
                        }
                    }
                    
                    // 새 날짜에 일정 추가
                    if (newAllEvents[newDate]) {
                        newAllEvents[newDate] = [...newAllEvents[newDate], scheduleData];
                    } else {
                        newAllEvents[newDate] = [scheduleData];
                    }
                    
                    return newAllEvents;
                });
                
                // 🚨 중요: 중복 실행 방지 해제
                isProcessingSchedule.current = false;
                
                // 🚨 디버깅: 상태 업데이트 완료 로그
                console.log('🔍 [App.js] useFocusEffect에서 상태 업데이트 완료:', {
                    appointmentsLength: appointments.length,
                    markedDatesKeys: Object.keys(markedDates),
                    allEventsKeys: Object.keys(allEvents)
                });
                
                // 🚨 디버깅: 마운트 시 상태 업데이트 완료 로그
                console.log('🔍 [App.js] 마운트 시 상태 업데이트 완료:', {
                    appointmentsLength: appointments.length,
                    markedDatesKeys: Object.keys(markedDates),
                    allEventsKeys: Object.keys(allEvents)
                });
                
                // 전역 변수 초기화
                global.updatedPersonalSchedule = undefined;
                
                // 🚨 디버깅: 마운트 시 상태 업데이트 완료 로그
                console.log('🔍 [App.js] 마운트 시 상태 업데이트 완료:', {
                    appointmentsLength: appointments.length,
                    markedDatesKeys: Object.keys(markedDates),
                    allEventsKeys: Object.keys(allEvents)
                });
                
                // 수정된 일정 처리 완료 후 fetchHomeData 건너뛰기
                return;
            }
            
            // 강제 새로고침 플래그 확인
            if (global.forceRefreshHome && global.forceRefreshTimestamp) {
                console.log('🔍 [App.js] 강제 새로고침 플래그 감지:', {
                    forceRefresh: global.forceRefreshHome,
                    timestamp: global.forceRefreshTimestamp
                });
                
                // 강제 새로고침 실행
                console.log('🔍 [App.js] 강제 새로고침 실행 중...');
                fetchHomeData();
                
                // 플래그 초기화
                global.forceRefreshHome = false;
                global.forceRefreshTimestamp = undefined;
                
                return;
            }
            
            // 전역 변수가 없을 때만 서버 API 호출
            if (!global.newPersonalSchedule && !global.newPartySchedule && !global.updatedPersonalSchedule) {
                // 전역 변수 일정이 없을 때만 fetchHomeData 실행
                fetchHomeData();
            }
        });
        return unsubscribe;
    }, [navigation]));
    
    // 🚨 중요: 상태 변경을 감지하여 백업하는 useEffect
    useEffect(() => {
        // appointments가 변경될 때마다 백업
        if (appointments.length > 0) {
            global.backupAppointments = [...appointments];
            global.backupMarkedDates = { ...markedDates };
            global.backupAllEvents = { ...allEvents };
            
            // 🚨 중요: 로컬 저장소에도 영구 저장
            saveAppointmentsToStorage(appointments, markedDates, allEvents);
        }
    }, [appointments, markedDates, allEvents]);

    // 🚨 중요: 컴포넌트 마운트 시 로컬 저장소에서 데이터 복원
    useEffect(() => {
        const initializeData = async () => {
            await loadAppointmentsFromStorage();
        };
        
        initializeData();
    }, []); // 마운트 시에만 실행
    
    // 🚨 중요: 주기적으로 전역 변수 확인 (updatedPersonalSchedule 감지용)
    useEffect(() => {
        const interval = setInterval(() => {
            if (global.updatedPersonalSchedule && !isProcessingSchedule.current) {
                console.log('🔍 [App.js] 주기적 확인에서 전역 변수 감지:', global.updatedPersonalSchedule);
                
                // 🚨 중요: 중복 실행 방지
                isProcessingSchedule.current = true;
                
                const updatedSchedule = global.updatedPersonalSchedule;
                const originalDate = updatedSchedule.originalDate;
                const newDate = updatedSchedule.newDate;
                const scheduleData = updatedSchedule.schedule;
                const editMode = updatedSchedule.editMode;
                
                console.log('🔍 [App.js] 주기적 확인에서 처리 시작:', {
                    originalDate,
                    newDate,
                    editMode,
                    scheduleId: scheduleData.id || scheduleData._id
                });
                
                // 🚨 중요: 전체 반복 일정 수정인지 확인
                if (editMode === 'recurring_all') {
                    console.log('🔍 [App.js] 주기적 확인에서 전체 반복 일정 수정 감지');
                    console.log('🔍 [App.js] 날짜 변경 정보:', {
                        originalDate: originalDate,
                        newDate: newDate,
                        hasDateChange: originalDate !== newDate
                    });
                    
                    // 🚨 중요: 날짜가 변경된 경우 기존 날짜의 일정을 새 날짜로 이동
                    if (originalDate && newDate && originalDate !== newDate) {
                        console.log('🔍 [App.js] 주기적 확인에서 날짜 변경 감지 - 기존 일정을 새 날짜로 이동');
                        
                        // 1. 기존 날짜에서 일정 제거
                        setAppointments(prev => {
                            const newAppointments = prev.map(appointment => {
                                if (appointment.date === originalDate) {
                                    return {
                                        ...appointment,
                                        events: (appointment.events || []).filter(event => 
                                            event.id !== scheduleData.id && event._id !== scheduleData.id
                                        )
                                    };
                                }
                                return appointment;
                            }).filter(appointment => appointment.events && Array.isArray(appointment.events) && appointment.events.length > 0); // 빈 날짜 제거
                            
                            return newAppointments;
                        });
                        
                        // 2. 새 날짜에 일정 추가
                        setAppointments(prev => {
                            const newAppointments = [...prev];
                            const existingDateIndex = newAppointments.findIndex(item => item.date === newDate);
                            
                            if (existingDateIndex >= 0) {
                                // 기존 날짜에 일정 추가
                                newAppointments[existingDateIndex].events.push({
                                    ...scheduleData,
                                    date: newDate
                                });
                            } else {
                                // 새로운 날짜에 일정 추가
                                newAppointments.push({
                                    date: newDate,
                                    events: [{
                                        ...scheduleData,
                                        date: newDate
                                    }]
                                });
                            }
                            
                            return newAppointments;
                        });
                        
                        // 3. allEvents 상태도 동일하게 업데이트
                        setAllEvents(prev => {
                            const newAllEvents = { ...prev };
                            
                            // 기존 날짜에서 일정 제거
                            if (newAllEvents[originalDate] && Array.isArray(newAllEvents[originalDate])) {
                                newAllEvents[originalDate] = newAllEvents[originalDate].filter(event => 
                                    event.id !== scheduleData.id && event._id !== scheduleData.id
                                );
                                
                                // 빈 배열이면 해당 날짜 키 제거
                                if (newAllEvents[originalDate].length === 0) {
                                    delete newAllEvents[originalDate];
                                }
                            }
                            
                            // 새 날짜에 일정 추가
                            if (newAllEvents[newDate]) {
                                newAllEvents[newDate].push({
                                    ...scheduleData,
                                    date: newDate
                                });
                            } else {
                                newAllEvents[newDate] = [{
                                    ...scheduleData,
                                    date: newDate
                                }];
                            }
                            
                            return newAllEvents;
                        });
                        
                        // 4. markedDates 업데이트
                        setMarkedDates(prev => {
                            const newMarkedDates = { ...prev };
                            
                            // 기존 날짜 마킹 제거 (해당 날짜에 다른 일정이 없으면)
                            if (newMarkedDates[originalDate]) {
                                // 해당 날짜에 다른 일정이 있는지 확인
                                const hasOtherEvents = appointments.some(appointment => 
                                    appointment.date === originalDate && 
                                    appointment.events.some(event => 
                                        event.id !== scheduleData.id && event._id !== scheduleData.id
                                    )
                                );
                                
                                if (!hasOtherEvents) {
                                    delete newMarkedDates[originalDate];
                                }
                            }
                            
                            // 새 날짜 마킹 추가
                            newMarkedDates[newDate] = {
                                selected: true,
                                selectedColor: '#64748B' // 기타 일정 색상
                            };
                            
                            return newMarkedDates;
                        });
                        
                        console.log('🔍 [App.js] 주기적 확인에서 날짜 변경 처리 완료:', {
                            from: originalDate,
                            to: newDate
                        });
                    } else {
                        // 날짜 변경이 없는 경우 - 기존 로직 (내용만 업데이트)
                        console.log('🔍 [App.js] 날짜 변경 없음 - 내용만 업데이트');
                        
                        // appointments 상태 업데이트
                        setAppointments(prev => {
                            const newAppointments = [...prev];
                            let updateCount = 0;
                            
                            newAppointments.forEach(appointment => {
                                appointment.events = appointment.events.map(event => {
                                    if (event.id === scheduleData.id || event._id === scheduleData.id) {
                                        updateCount++;
                                        console.log('🔍 [App.js] 주기적 확인에서 일정 업데이트됨:', {
                                            date: appointment.date,
                                            eventId: event.id || event._id,
                                            oldTitle: event.title,
                                            newTitle: scheduleData.title
                                        });
                                        
                                        return {
                                            ...event,
                                            title: scheduleData.title,
                                            restaurant: scheduleData.restaurant,
                                            time: scheduleData.time,
                                            location: scheduleData.location,
                                            description: scheduleData.description,
                                            attendees: scheduleData.attendees,
                                            isRecurring: scheduleData.isRecurring,
                                            recurrenceType: scheduleData.recurrenceType,
                                            recurrenceInterval: scheduleData.recurrenceInterval,
                                            endType: scheduleData.endType,
                                            endDate: scheduleData.endDate
                                        };
                                    }
                                    return event;
                                });
                            });
                            
                            console.log('🔍 [App.js] 주기적 확인에서 appointments 업데이트 완료, 총', updateCount, '개 일정 수정됨');
                            return newAppointments;
                        });
                        
                        // allEvents 상태도 업데이트
                        setAllEvents(prev => {
                            const newAllEvents = { ...prev };
                            let updateCount = 0;
                            
                            Object.keys(newAllEvents).forEach(date => {
                                newAllEvents[date] = newAllEvents[date].map(event => {
                                    if (event.id === scheduleData.id || event._id === scheduleData.id) {
                                        updateCount++;
                                        console.log('🔍 [App.js] 주기적 확인에서 allEvents 업데이트됨:', {
                                            date,
                                            eventId: event.id || event._id,
                                            oldTitle: event.title,
                                            newTitle: scheduleData.title
                                        });
                                        
                                        return {
                                            ...event,
                                            title: scheduleData.title,
                                            restaurant: scheduleData.restaurant,
                                            time: scheduleData.time,
                                            location: scheduleData.location,
                                            description: scheduleData.description,
                                            attendees: scheduleData.attendees,
                                            isRecurring: scheduleData.isRecurring,
                                            recurrenceType: scheduleData.recurrenceType,
                                            recurrenceInterval: scheduleData.recurrenceInterval,
                                            endType: scheduleData.endType,
                                            endDate: scheduleData.endDate
                                        };
                                    }
                                    return event;
                                });
                            });
                            
                            console.log('🔍 [App.js] 주기적 확인에서 allEvents 업데이트 완료, 총', updateCount, '개 일정 수정됨');
                            return newAllEvents;
                        });
                    }
                    
                    // 🚨 강제 리렌더링을 위한 상태 업데이트
                    setTimeout(() => {
                        setAppointments(prev => [...prev]);
                        setAllEvents(prev => ({ ...prev }));
                        console.log('🔍 [App.js] 주기적 확인에서 강제 리렌더링 실행됨');
                    }, 100);
                    
                    // 전역 변수 초기화 및 처리 완료
                    global.updatedPersonalSchedule = undefined;
                    isProcessingSchedule.current = false;
                    
                    console.log('🔍 [App.js] 주기적 확인에서 처리 완료');
                    return;
                }
                
                // 일반 수정 또는 단일 반복 일정 수정: 날짜 변경 처리
                console.log('🔍 [App.js] 주기적 확인에서 일반 수정 또는 단일 반복 일정 수정 감지');
                
                // appointments 상태 업데이트
                setAppointments(prev => {
                    const newAppointments = [...prev];
                    
                    // 원래 날짜에서 일정 제거
                    const originalDateIndex = newAppointments.findIndex(item => item.date === originalDate);
                    if (originalDateIndex >= 0) {
                        newAppointments[originalDateIndex] = {
                            ...newAppointments[originalDateIndex],
                            events: newAppointments[originalDateIndex].events.filter(event => 
                                event.id !== scheduleData.id && event._id !== scheduleData.id
                            )
                        };
                        
                        // 이벤트가 없어진 날짜는 제거
                        if (newAppointments[originalDateIndex].events.length === 0) {
                            newAppointments.splice(originalDateIndex, 1);
                        }
                    }
                    
                    // 새 날짜에 일정 추가
                    const newDateIndex = newAppointments.findIndex(item => item.date === newDate);
                    if (newDateIndex >= 0) {
                        newAppointments[newDateIndex] = {
                            ...newAppointments[newDateIndex],
                            events: [...newAppointments[newDateIndex].events, scheduleData]
                        };
                    } else {
                        newAppointments.push({
                            date: newDate,
                            events: [scheduleData]
                        });
                    }
                    
                    return newAppointments;
                });
                
                // markedDates 상태 업데이트
                setMarkedDates(prev => {
                    const newMarkedDates = { ...prev };
                    
                    // 원래 날짜 마킹 제거
                    if (newMarkedDates[originalDate]) {
                        delete newMarkedDates[originalDate];
                    }
                    
                    // 새 날짜 마킹 추가
                    newMarkedDates[newDate] = {
                        selected: true,
                        selectedColor: '#64748B' // 기타 일정 색상
                    };
                    
                    return newMarkedDates;
                });
                
                // allEvents 상태 업데이트
                setAllEvents(prev => {
                    const newAllEvents = { ...prev };
                    
                    // 원래 날짜에서 일정 제거
                    if (newAllEvents[originalDate]) {
                        newAllEvents[originalDate] = newAllEvents[originalDate].filter(event => 
                            event.id !== scheduleData.id && event._id !== scheduleData.id
                        );
                        
                        // 이벤트가 없어진 날짜는 제거
                        if (newAllEvents[originalDate].length === 0) {
                            delete newAllEvents[originalDate];
                        }
                    }
                    
                    // 새 날짜에 일정 추가
                    if (newAllEvents[newDate]) {
                        newAllEvents[newDate] = [...newAllEvents[newDate], scheduleData];
                    } else {
                        newAllEvents[newDate] = [scheduleData];
                    }
                    
                    return newAllEvents;
                });
                
                // 🚨 중요: 중복 실행 방지 해제
                isProcessingSchedule.current = false;
                
                // 전역 변수 초기화
                global.updatedPersonalSchedule = undefined;
                
                console.log('🔍 [App.js] 주기적 확인에서 상태 업데이트 완료');
            }
        }, 500); // 500ms마다 확인
        
        return () => clearInterval(interval);
    }, []);
    
    // 컴포넌트 마운트 시 즉시 전역 변수 확인 (fetchHomeData보다 먼저 실행)
    useEffect(() => {
        // 컴포넌트 마운트 시 즉시 체크 시작
        // 전역 변수 상태
        
                    // 전역 변수에서 새로운 일정 확인
            if (global.newPersonalSchedule) {
                // 마운트 시 전역 변수 일정 감지
                
                const newSchedule = global.newPersonalSchedule;
                const dateString = newSchedule.date;
                
                // appointments 상태 즉시 업데이트
                setAppointments(prev => {
                    const newAppointments = [...prev];
                    const existingDateIndex = newAppointments.findIndex(item => item.date === dateString);
                    
                    if (existingDateIndex >= 0) {
                        newAppointments[existingDateIndex] = {
                            ...newAppointments[existingDateIndex],
                            events: [...newAppointments[existingDateIndex].events, newSchedule]
                        };
                                                // console.log('🔍 [홈탭] 마운트 시: 기존 날짜에 일정 추가');
                    } else {
                        newAppointments.push({
                            date: dateString,
                            events: [newSchedule]
                        });
                                                // console.log('🔍 [홈탭] 마운트 시: 새로운 날짜에 일정 추가');
                    }
                    
                    return newAppointments;
                });
                
                // markedDates 상태 즉시 업데이트
                setMarkedDates(prev => {
                    const newMarkedDates = { ...prev };
                    newMarkedDates[dateString] = {
                        selected: true,
                        selectedColor: currentColors.gray
                    };
                    return newMarkedDates;
                });
                
                // allEvents 상태 즉시 업데이트
                setAllEvents(prev => {
                    const newAllEvents = { ...prev };
                    if (newAllEvents[dateString]) {
                        newAllEvents[dateString] = [...newAllEvents[dateString], newSchedule];
                    } else {
                        newAllEvents[dateString] = [newSchedule];
                    }
                    return newAllEvents;
                });
                
                // 전역 변수 초기화
                global.newPersonalSchedule = undefined;
                                // console.log('🔍 [홈탭] 마운트 시 전역 변수 일정 처리 완료');
            }

            // 전역 변수에서 수정된 일정 확인
            if (global.updatedPersonalSchedule) {
                // 🚨 디버깅: 마운트 시 전역 변수 존재 확인
                console.log('🔍 [App.js] 마운트 시 전역 변수 존재 확인:', {
                    hasGlobalVar: !!global.updatedPersonalSchedule,
                    globalVarContent: global.updatedPersonalSchedule
                });
                
                const updatedSchedule = global.updatedPersonalSchedule;
                const originalDate = updatedSchedule.originalDate;
                const newDate = updatedSchedule.newDate;
                const scheduleData = updatedSchedule.schedule;
                
                // 🚨 디버깅: 마운트 시 전역 변수 감지 로그
                console.log('🔍 [App.js] 마운트 시 전역 변수 감지:', {
                    originalDate,
                    newDate,
                    scheduleId: scheduleData.id || scheduleData._id,
                    timestamp: updatedSchedule.timestamp
                });
                
                // appointments 상태 업데이트
                setAppointments(prev => {
                    const newAppointments = [...prev];
                    
                    // 원래 날짜에서 일정 제거
                    const originalDateIndex = newAppointments.findIndex(item => item.date === originalDate);
                    if (originalDateIndex >= 0) {
                        newAppointments[originalDateIndex] = {
                            ...newAppointments[originalDateIndex],
                            events: newAppointments[originalDateIndex].events.filter(event => 
                                event.id !== scheduleData.id && event._id !== scheduleData.id
                            )
                        };
                        
                        // 이벤트가 없어진 날짜는 제거
                        if (newAppointments[originalDateIndex].events.length === 0) {
                            newAppointments.splice(originalDateIndex, 1);
                        }
                    }
                    
                    // 새 날짜에 일정 추가
                    const newDateIndex = newAppointments.findIndex(item => item.date === newDate);
                    if (newDateIndex >= 0) {
                        newAppointments[newDateIndex] = {
                            ...newAppointments[newDateIndex],
                            events: [...newAppointments[newDateIndex].events, scheduleData]
                        };
                    } else {
                        newAppointments.push({
                            date: newDate,
                            events: [scheduleData]
                        });
                    }
                    
                    return newAppointments;
                });
                
                // markedDates 상태 업데이트
                setMarkedDates(prev => {
                    const newMarkedDates = { ...prev };
                    
                    // 원래 날짜 마킹 제거
                    if (newMarkedDates[originalDate]) {
                        delete newMarkedDates[originalDate];
                    }
                    
                    // 새 날짜 마킹 추가
                    newMarkedDates[newDate] = {
                        selected: true,
                        selectedColor: currentColors.gray
                    };
                    
                    return newMarkedDates;
                });
                
                // allEvents 상태 업데이트
                setAllEvents(prev => {
                    const newAllEvents = { ...prev };
                    
                    // 원래 날짜에서 일정 제거
                    if (newAllEvents[originalDate]) {
                        newAllEvents[originalDate] = newAllEvents[originalDate].filter(event => 
                            event.id !== scheduleData.id && event._id !== scheduleData.id
                        );
                        
                        // 이벤트가 없어진 날짜는 제거
                        if (newAllEvents[originalDate].length === 0) {
                            delete newAllEvents[originalDate];
                        }
                    }
                    
                    // 새 날짜에 일정 추가
                    if (newAllEvents[newDate]) {
                        newAllEvents[newDate] = [...newAllEvents[newDate], scheduleData];
                    } else {
                        newAllEvents[newDate] = [scheduleData];
                    }
                    
                    return newAllEvents;
                });
                
                // 전역 변수 초기화
                global.updatedPersonalSchedule = undefined;
            }
        
        // 🚨 중요: 전역 변수에서 새로운 파티 확인
        if (global.newPartySchedule) {
                            // console.log('🔍 [홈탭] 마운트 시 전역 변수 새 파티 감지:', global.newPartySchedule);
            
            const newParty = global.newPartySchedule;
            const dateString = newParty.date;
            
                            // console.log('🔍 [홈탭] 마운트 시 새 파티 날짜:', dateString);
                // console.log('🔍 [홈탭] 마운트 시 새 파티 제목:', newParty.title);
            
            // appointments 상태 즉시 업데이트
            setAppointments(prev => {
                const newAppointments = [...prev];
                const existingDateIndex = newAppointments.findIndex(item => item.date === dateString);
                
                if (existingDateIndex >= 0) {
                    newAppointments[existingDateIndex] = {
                        ...newAppointments[existingDateIndex],
                        events: [...newAppointments[existingDateIndex].events, newParty]
                    };
                                            // console.log('🔍 [홈탭] 마운트 시: 기존 날짜에 새 파티 추가');
                } else {
                    newAppointments.push({
                        date: dateString,
                        events: [newParty]
                    });
                                            // console.log('🔍 [홈탭] 마운트 시: 새로운 날짜에 새 파티 추가');
                }
                
                // console.log('🔍 [홈탭] 마운트 시: 업데이트된 appointments:', newAppointments);
                return newAppointments;
            });
            
            // markedDates 상태 업데이트
            setMarkedDates(prev => {
                const newMarkedDates = { ...prev };
                // 랜덤런치 파티인지 확인하여 색상 결정
                const isRandomLunch = newParty && newParty.is_from_match === true;
                const selectedColor = isRandomLunch ? '#F4D160' : currentColors.primary; // 랜덤런치는 노란색, 일반 파티는 파란색
                
                newMarkedDates[dateString] = {
                    selected: true,
                    selectedColor: selectedColor
                };
                // console.log('🔍 [홈탭] 마운트 시: 업데이트된 markedDates:', newMarkedDates);
                return newMarkedDates;
            });
            
            // allEvents 상태 업데이트
            setAllEvents(prev => {
                const newAllEvents = { ...prev };
                if (newAllEvents[dateString]) {
                    newAllEvents[dateString] = [...newAllEvents[dateString], newParty];
                } else {
                    newAllEvents[dateString] = [newParty];
                }
                // console.log('🔍 [홈탭] 마운트 시: 업데이트된 allEvents:', newAllEvents);
                return newAllEvents;
            });
            
            // 전역 변수 초기화
            global.newPartySchedule = undefined;
                            // console.log('🔍 [홈탭] 마운트 시 전역 변수 새 파티 처리 완료');
        }
        
        if (!global.newPersonalSchedule && !global.newPartySchedule) {
                            // console.log('🔍 [홈탭] 마운트 시 전역 변수에 새 일정/파티 없음');
        }
    }, []); // 빈 의존성 배열로 마운트 시에만 실행
    
    // 기타 일정 추가 후 홈 데이터 새로고침을 위한 route params 리스너
    useEffect(() => {
        if (route.params?.refreshHomeData) {
            // console.log('🔍 [홈탭] 기타 일정 추가 감지, 홈 데이터 새로고침 시작');
            // console.log('🔍 [홈탭] 새로고침 타임스탬프:', route.params.refreshTimestamp);
            // console.log('🔍 [홈탭] 새로운 일정 데이터:', route.params.newScheduleData);
            // console.log('🔍 [홈탭] 즉시 업데이트 플래그:', route.params.immediateUpdate);
            
            // 즉시 업데이트가 필요한 경우 로컬 상태에 먼저 추가
            if (route.params?.immediateUpdate && route.params?.newScheduleData) {
                // console.log('🔍 [홈탭] 즉시 로컬 상태 업데이트 시작');
                const newSchedule = route.params.newScheduleData;
                
                // 날짜 형식 통일 (YYYY-MM-DD 형식으로)
                let dateString;
                try {
                    if (newSchedule.date && typeof newSchedule.date === 'string') {
                        // 이미 YYYY-MM-DD 형식인 경우
                        if (/^\d{4}-\d{2}-\d{2}$/.test(newSchedule.date)) {
                            dateString = newSchedule.date;
                        } else {
                            // 다른 형식인 경우 Date 객체로 변환
                            const scheduleDate = new Date(newSchedule.date);
                            dateString = scheduleDate.toISOString().split('T')[0];
                        }
                    } else {
                        // 날짜가 없는 경우 현재 날짜 사용
                        dateString = new Date().toISOString().split('T')[0];
                    }
                } catch (error) {
                    console.error('🔍 [홈탭] 날짜 변환 오류:', error);
                    dateString = new Date().toISOString().split('T')[0];
                }
                
                // console.log('🔍 [홈탭] 원본 날짜:', newSchedule.date);
                // console.log('🔍 [홈탭] 변환된 날짜 문자열:', dateString);
                
                // appointments 상태 즉시 업데이트
                setAppointments(prev => {
                    const newAppointments = [...prev];
                    const existingDateIndex = newAppointments.findIndex(item => item.date === dateString);
                    
                    if (existingDateIndex >= 0) {
                        // 기존 날짜에 추가
                        newAppointments[existingDateIndex] = {
                            ...newAppointments[existingDateIndex],
                            events: [...newAppointments[existingDateIndex].events, newSchedule]
                        };
                        // console.log('🔍 [홈탭] 기존 날짜에 일정 추가:', existingDateIndex);
                    } else {
                        // 새로운 날짜 추가
                        newAppointments.push({
                            date: dateString,
                            events: [newSchedule]
                        });
                        // console.log('🔍 [홈탭] 새로운 날짜에 일정 추가');
                    }
                    
                    // console.log('🔍 [홈탭] 업데이트된 appointments:', newAppointments);
                    return newAppointments;
                });
                
                // markedDates 상태 즉시 업데이트
                setMarkedDates(prev => {
                    const newMarkedDates = { ...prev };
                    newMarkedDates[dateString] = {
                        selected: true,
                        selectedColor: currentColors.gray  // 기타 일정은 회색
                    };
                    // console.log('🔍 [홈탭] 업데이트된 markedDates:', newMarkedDates);
                    return newMarkedDates;
                });
                
                // allEvents 상태 즉시 업데이트
                setAllEvents(prev => {
                    const newAllEvents = { ...prev };
                    if (newAllEvents[dateString]) {
                        newAllEvents[dateString] = [...newAllEvents[dateString], newSchedule];
                    } else {
                        newAllEvents[dateString] = [newSchedule];
                    }
                    // console.log('🔍 [홈탭] 업데이트된 allEvents:', newAllEvents);
                    return newAllEvents;
                });
                
                                    // console.log('🔍 [홈탭] 로컬 상태 즉시 업데이트 완료');
            }
            
            // 서버에서 최신 데이터 가져오기 (약간의 지연 후)
            setTimeout(() => {
                // console.log('🔍 [홈탭] 서버 데이터 동기화 시작');
                fetchHomeData();
            }, 1000);
            
            // 파라미터 초기화
            navigation.setParams({ 
                refreshHomeData: undefined, 
                refreshTimestamp: undefined,
                newScheduleData: undefined,
                immediateUpdate: undefined
            });
        }
    }, [route.params?.refreshHomeData, route.params?.refreshTimestamp]);
    
    // 🚨 중요: allEvents 상태 변화를 감지하여 markedDates 자동 동기화
    useEffect(() => {
        if (allEvents && typeof allEvents === 'object') {
            const newMarkedDates = generateMarkedDatesFromAllEvents();
            setMarkedDates(newMarkedDates);
            
            // AsyncStorage에도 저장
            try {
                AsyncStorage.setItem('@marked_dates', JSON.stringify(newMarkedDates));
            } catch (storageError) {
                console.error('🔍 [useEffect] AsyncStorage markedDates 저장 오류:', storageError);
            }
        }
    }, [allEvents]);
    
    // 전역 변수에서 새로운 일정 확인 (백업 방법)
    useEffect(() => {
        if (global.newPersonalSchedule) {

            
            const newSchedule = global.newPersonalSchedule;
            const dateString = newSchedule.date;
            

            
            // appointments 상태 즉시 업데이트
            setAppointments(prev => {
                const newAppointments = [...prev];
                const existingDateIndex = newAppointments.findIndex(item => item.date === dateString);
                
                if (existingDateIndex >= 0) {
                    // 기존 날짜에 추가
                    newAppointments[existingDateIndex] = {
                        ...newAppointments[existingDateIndex],
                        events: [...newAppointments[existingDateIndex].events, newSchedule]
                    };

                } else {
                    // 새로운 날짜 추가
                    newAppointments.push({
                        date: dateString,
                        events: [newSchedule]
                    });

                }
                

                return newAppointments;
            });
            
            // markedDates 상태 즉시 업데이트
            setMarkedDates(prev => {
                const newMarkedDates = { ...prev };
                newMarkedDates[dateString] = {
                    selected: true,
                    selectedColor: currentColors.gray
                };

                return newMarkedDates;
            });
            
            // allEvents 상태 즉시 업데이트
            setAllEvents(prev => {
                const newAllEvents = { ...prev };
                if (newAllEvents[dateString]) {
                    newAllEvents[dateString] = [...newAllEvents[dateString], newSchedule];
                } else {
                    newAllEvents[dateString] = [newSchedule];
                }

                return newAllEvents;
            });
            
            // 전역 변수 초기화
            global.newPersonalSchedule = undefined;

        }
    }, []);
    
    // 전역 변수 확인을 위한 주기적 체크 (추가 백업)
    useEffect(() => {
        const checkGlobalSchedule = () => {
            if (global.newPersonalSchedule) {

                
                const newSchedule = global.newPersonalSchedule;
                const dateString = newSchedule.date;
                

                
                // appointments 상태 즉시 업데이트
                setAppointments(prev => {
                    const newAppointments = [...prev];
                    const existingDateIndex = newAppointments.findIndex(item => item.date === dateString);
                    
                    if (existingDateIndex >= 0) {
                        newAppointments[existingDateIndex] = {
                            ...newAppointments[existingDateIndex],
                            events: [...newAppointments[existingDateIndex].events, newSchedule]
                        };
                    } else {
                        newAppointments.push({
                            date: dateString,
                            events: [newSchedule]
                        });
                    }
                    
                    return newAppointments;
                });
                
                // markedDates 상태 즉시 업데이트
                setMarkedDates(prev => {
                    const newMarkedDates = { ...prev };
                    newMarkedDates[dateString] = {
                        selected: true,
                        selectedColor: currentColors.gray
                    };
                    return newMarkedDates;
                });
                
                // allEvents 상태 즉시 업데이트
                setAllEvents(prev => {
                    const newAllEvents = { ...prev };
                    if (newAllEvents[dateString]) {
                        newAllEvents[dateString] = [...newAllEvents[dateString], newSchedule];
                    } else {
                        newAllEvents[dateString] = [newSchedule];
                    }
                    return newAllEvents;
                });
                
                // 전역 변수 초기화
                global.newPersonalSchedule = undefined;
                // console.log('🔍 [홈탭] 주기적 체크 전역 변수 일정 처리 완료');
            }
        };
        
        // 즉시 한 번 체크
        checkGlobalSchedule();
        
        // 1초 후 다시 체크
        const timer = setTimeout(checkGlobalSchedule, 1000);
        
        return () => clearTimeout(timer);
    }, []);
    
    // 전역 변수 확인을 위한 간단한 체크
    useEffect(() => {
        // 컴포넌트가 마운트된 후 즉시 확인
        const immediateCheck = () => {
            // 간단한 체크 시작
            // 전역 변수 상태
            
            // 전역 변수 확인
            if (global.newPersonalSchedule) {
                // 전역 변수에서 일정 감지
                processNewSchedule(global.newPersonalSchedule, '전역 변수');
                global.newPersonalSchedule = undefined;
                return;
            }
            
            // 전역 변수에 새 일정 없음
        };
        
        // 새로운 일정 처리 함수 (간단한 버전)
        const processNewSchedule = (newSchedule, source) => {
            const dateString = newSchedule.date;
            
            // 🚨 중요: 로컬 일정에 고유 ID 생성 (삭제 기능을 위해)
            const scheduleWithId = {
                ...newSchedule,
                id: newSchedule.id || `local_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                _id: newSchedule._id || newSchedule.id || `local_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
            };
            
                    // console.log('🔍 [processNewSchedule] ID가 추가된 일정:', scheduleWithId);
        // console.log('🔍 [processNewSchedule] attendees 데이터:', scheduleWithId.attendees);
        // console.log('🔍 [processNewSchedule] 일정 타입:', scheduleWithId.scheduleType || '기타 일정');
            
            // appointments 상태 즉시 업데이트
            setAppointments(prev => {
                const newAppointments = [...prev];
                const existingDateIndex = newAppointments.findIndex(item => item.date === dateString);
                
                if (existingDateIndex >= 0) {
                    // 기존 날짜에 일정 추가
                    const existingEvents = newAppointments[existingDateIndex].events || [];
                    newAppointments[existingDateIndex] = {
                        ...newAppointments[existingDateIndex],
                        events: [...existingEvents, scheduleWithId]
                    };
                } else {
                    // 새로운 날짜에 일정 추가
                    newAppointments.push({
                        date: dateString,
                        events: [scheduleWithId]
                    });
                }
                
                                        // console.log('🔍 [processNewSchedule] appointments 업데이트 완료:', newAppointments.length, '개 날짜');
                return newAppointments;
            });
            
            // markedDates 상태 즉시 업데이트
            setMarkedDates(prev => {
                const newMarkedDates = { ...prev };
                newMarkedDates[dateString] = {
                    selected: true,
                    selectedColor: '#64748B' // 기타 일정 색상
                };
                                        // console.log('🔍 [processNewSchedule] markedDates 업데이트 완료:', dateString);
                return newMarkedDates;
            });
            
            // allEvents 상태 즉시 업데이트
            setAllEvents(prev => {
                const newAllEvents = { ...prev };
                if (newAllEvents[dateString]) {
                    newAllEvents[dateString] = [...newAllEvents[dateString], scheduleWithId];
                } else {
                    newAllEvents[dateString] = [scheduleWithId];
                }
                                        // console.log('🔍 [processNewSchedule] allEvents 업데이트 완료:', dateString, '에', newAllEvents[dateString]?.length || 0, '개 일정');
                return newAllEvents;
            });
            
            // 일정 처리 완료
            console.log('✅ [processNewSchedule] 일정 처리 완료:', dateString);
        };
        
        // 즉시 실행
        immediateCheck();
        
        // 추가 지연 체크 (2초, 5초 후)
        const timer1 = setTimeout(immediateCheck, 2000);
        const timer2 = setTimeout(immediateCheck, 5000);
        
        return () => {
            clearTimeout(timer1);
            clearTimeout(timer2);
        };
    }, []);
    
    // 통합 약속 생성기에서 생성된 약속을 홈 화면에 반영
    const handleAppointmentCreated = useCallback((newAppointment) => {
        // 로컬 상태에 즉시 추가 (Optimistic Update)
        const appointmentDate = newAppointment.date;
        setAppointments(prev => ({
            ...prev,
            [appointmentDate]: [
                ...(prev[appointmentDate] || []),
                newAppointment
            ]
        }));
        
        // 달력 마킹 업데이트
        setMarkedDates(prev => ({
            ...prev,
            [appointmentDate]: {
                selected: true,
                selectedColor: newAppointment.type === '랜덤 런치' ? '#F4D160' : 
                              newAppointment.type === '개인 일정' ? '#64748B' : '#3B82F6'
            }
        }));
        
        // 전체 이벤트 데이터 업데이트
        setAllEvents(prev => ({
            ...prev,
            [appointmentDate]: [
                ...(prev[appointmentDate] || []),
                newAppointment
            ]
        }));
        
        // 서버와 동기화
        fetchHomeData();
    }, []);

    const handleEditPersonalSchedule = (event, editMode = 'single') => {
        setModalData({ visible: false, events: [] });
        safeNavigateToTab(navigation, '파티', 'EditPersonalSchedule', { 
            schedule: event, 
            editMode: editMode 
        });
    };

    const handleDeletePersonalSchedule = (scheduleId, eventData = null, deleteMode = 'single') => {
        // �� 수정: deleteMode를 직접 사용
        if (deleteMode === 'single') {
            // 단일 일정 삭제
            deleteSchedule(scheduleId, 'single', eventData);
        } else if (deleteMode === 'all') {
            // 모든 반복 일정 삭제
            deleteSchedule(scheduleId, 'all', eventData);
        } else {
            // deleteMode가 없으면 기존 로직 사용 (하위 호환성)
        const isRecurring = eventData?.is_recurring || false;
        
        if (isRecurring) {
            Alert.alert(
                "반복 일정 삭제", 
                "이 일정은 반복 일정입니다. 어떻게 삭제하시겠습니까?",
                [
                    { text: "취소", style: "cancel" },
                    { 
                        text: "이 날짜만 삭제", 
                        onPress: () => deleteSchedule(scheduleId, 'single', eventData)
                    },
                    { 
                        text: "모든 반복 일정 삭제", 
                        style: "destructive",
                        onPress: () => deleteSchedule(scheduleId, 'all', eventData)
                    }
                ]
            );
        } else {
            Alert.alert("일정 삭제", "정말로 이 점심 약속을 삭제하시겠습니까?", [
                { text: "취소", style: "cancel" },
                { text: "삭제", style: "destructive", onPress: () => deleteSchedule(scheduleId, 'single', eventData) }
            ]);
            }
        }
    };

    const deleteSchedule = async (scheduleId, deleteMode, eventData = null) => {
        try {


            // scheduleId 유효성 검사
            if (!scheduleId) {
                console.error('❌ [삭제] scheduleId가 없습니다:', scheduleId);
                Alert.alert("오류", "일정 ID를 찾을 수 없습니다. 일정 데이터를 확인해주세요.");
                return;
            }

            // 🚨 중요: 로컬 일정인지 확인 (local_ 또는 temp_로 시작하는 ID)
            const isLocalSchedule = scheduleId.toString().startsWith('local_') || scheduleId.toString().startsWith('temp_');
            
            // 중요: deleteMode === 'all'이면 해당 반복 일정의 모든 인스턴스만 삭제
            if (isLocalSchedule && deleteMode === 'all') {
                // 로컬 일정의 모든 반복 일정 삭제
                console.log('�� [삭제] 로컬 일정 모든 반복 일정 삭제:', scheduleId);
                
                // 해당 반복 일정의 모든 인스턴스를 찾아서 삭제
                const targetScheduleId = scheduleId;
                const targetSchedule = eventData;
                
                if (!targetSchedule) {
                    console.error('❌ [삭제] 반복 일정 데이터를 찾을 수 없습니다.');
                    Alert.alert("오류", "반복 일정 데이터를 찾을 수 없습니다.");
                    return;
                }
                
                // 1단계: appointments에서 해당 반복 일정의 모든 인스턴스 제거
                setAppointments(prev => {
                    const newAppointments = prev.map(item => {
                        const filteredEvents = (item.events || []).filter(event => {
                            const eventId = event.id || event._id || event.local_id;
                            // 같은 반복 일정인지 확인 (ID가 같거나 같은 반복 그룹에 속하는지)
                            const isSameRecurringSchedule = eventId === targetScheduleId || 
                                (event.isRecurring && event.recurrenceType === targetSchedule.recurrenceType && 
                                 event.recurrenceInterval === targetSchedule.recurrenceInterval &&
                                 event.title === targetSchedule.title &&
                                 event.restaurant === targetSchedule.restaurant);
                            
                            return !isSameRecurringSchedule;
                        });
                        
                        return {
                            ...item,
                            events: filteredEvents
                        };
                    }).filter(item => item.events && Array.isArray(item.events) && item.events.length > 0); // 일정이 없는 날짜는 제거
                    
                    return newAppointments;
                });
                
                // 2단계: allEvents에서 해당 반복 일정의 모든 인스턴스 제거
                setAllEvents(prev => {
                    const newAllEvents = { ...prev };
                    
                    Object.keys(newAllEvents).forEach(dateString => {
                        if (newAllEvents[dateString] && Array.isArray(newAllEvents[dateString])) {
                            const filteredEvents = newAllEvents[dateString].filter(event => {
                                const eventId = event.id || event._id || event.local_id;
                                // 같은 반복 일정인지 확인
                                const isSameRecurringSchedule = eventId === targetScheduleId || 
                                    (event.isRecurring && event.recurrenceType === targetSchedule.recurrenceType && 
                                     event.recurrenceInterval === targetSchedule.recurrenceInterval &&
                                     event.title === targetSchedule.title &&
                                     event.restaurant === targetSchedule.restaurant);
                                
                                return !isSameRecurringSchedule;
                            });
                            
                            newAllEvents[dateString] = filteredEvents;
                            
                            // 해당 날짜에 일정이 없으면 날짜 자체도 제거
                            if (filteredEvents.length === 0) {
                                delete newAllEvents[dateString];
                            }
                        }
                    });
                    
                    return newAllEvents;
                });
                
                // 3단계: markedDates에서 해당 반복 일정과 관련된 날짜들 제거
                setMarkedDates(prev => {
                    const newMarkedDates = { ...prev };
                    
                    // allEvents에서 제거된 날짜들을 markedDates에서도 제거
                    Object.keys(newMarkedDates).forEach(dateString => {
                        if (!global.allEvents || !global.allEvents[dateString] || global.allEvents[dateString].length === 0) {
                            delete newMarkedDates[dateString];
                        }
                    });
                    
                    return newMarkedDates;
                });
                
                // 전역 변수 업데이트
                global.allEvents = {};
                
                // AsyncStorage에서도 해당 반복 일정 관련 데이터만 삭제
                try {
                    await AsyncStorage.removeItem('@all_events');
                    await AsyncStorage.removeItem('@appointments');
                    await AsyncStorage.removeItem('@marked_dates');
                } catch (storageError) {
                    console.error('🔍 [삭제] AsyncStorage 삭제 오류:', storageError);
                }
                
                Alert.alert("성공", "해당 반복 일정의 모든 인스턴스가 삭제되었습니다.");
                setModalData({ visible: false, events: [] });
                return;
            }
            
            // 중요: deleteMode === 'single'이고 로컬 일정인 경우
            if (isLocalSchedule && deleteMode === 'single') {
                // 로컬 일정 삭제 (백엔드 API 호출 없음)

                
                // 로컬 상태에서 일정 제거
                const targetDate = eventData?.date;
                if (targetDate) {

                    
                    // 1단계: appointments에서 제거
                    setAppointments(prev => {

                        const newAppointments = prev.map(item => {
                            if (item.date === targetDate) {
                                const filteredEvents = (item.events || []).filter(event => {
                                    const eventId = event.id || event._id || event.local_id;
                                    const shouldKeep = eventId !== scheduleId;
                                    if (!shouldKeep) {

                                    }
                                    return shouldKeep;
                                });
                                

                                
                                return {
                                    ...item,
                                    events: filteredEvents
                                };
                            }
                            return item;
                        });
                        

                        return newAppointments;
                    });

                    // 2단계: allEvents에서 제거 (markedDates는 useEffect가 자동 동기화)
                    setAllEvents(prev => {
                        const newAllEvents = { ...prev };
                        
                        if (newAllEvents[targetDate] && Array.isArray(newAllEvents[targetDate])) {
                            const filteredEvents = newAllEvents[targetDate].filter(event => {
                                const eventId = event.id || event._id || event.local_id;
                                const shouldKeep = eventId !== scheduleId;
                                return shouldKeep;
                            });
                            
                            newAllEvents[targetDate] = filteredEvents;
                            
                            // 해당 날짜에 일정이 없으면 날짜 자체도 제거
                            if (filteredEvents.length === 0) {
                                delete newAllEvents[targetDate];
                            }
                        }
                        
                        // 🚨 중요: useEffect가 allEvents 변화를 감지하여 markedDates 자동 동기화
                        return newAllEvents;
                    });
                }

                Alert.alert("성공", "해당 날짜의 일정이 삭제되었습니다.");
                setModalData({ visible: false, events: [] });
                
                // 🚨 중요: useEffect가 자동으로 markedDates 동기화하므로 수동 동기화 불필요
                return;
            }

            // 백엔드 API를 통한 삭제 (기존 로직)
            const token = global.accessToken;
            if (!token) {
                Alert.alert("오류", "인증 토큰이 없습니다. 다시 로그인해주세요.");
                return;
            }

            // 삭제 요청 데이터 준비
            const deleteData = {
                delete_mode: deleteMode
            };

            // 반복 일정의 특정 날짜만 삭제하는 경우, 해당 날짜 정보 추가
            if (deleteMode === 'single' && eventData?.date) {
                deleteData.target_date = eventData.date;
            }

            const apiUrl = `${RENDER_SERVER_URL}/personal_schedules/${scheduleId}`;


            const response = await fetch(apiUrl, { 
                method: 'DELETE',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(deleteData)
            });
            

            
            // 응답 본문 확인
            let responseData = null;
            try {
                responseData = await response.json();

            } catch (parseError) {
                console.log(' [삭제] 응답 본문 파싱 실패 (정상적인 경우)');
            }
            
            if (response.ok) {
                const message = deleteMode === 'single' ? '해당 날짜의 일정이 삭제되었습니다.' : '모든 반복 일정이 삭제되었습니다.';
                Alert.alert("성공", message);
                setModalData({ visible: false, events: [] });
                
                // 🚨 중요: 반복 일정 삭제 후 상태 완전 초기화
                if (deleteMode === 'all') {

                    
                    // 전역 변수 데이터 완전 초기화
                    global.allEvents = {};
                    global.newScheduleData = undefined;
                    global.newPersonalSchedule = undefined;
                    
                    // 로컬 상태 즉시 초기화
                    setAllEvents({});
                    setAppointments([]);
                    setMarkedDates({});
                    
                    // AsyncStorage에서도 삭제
                    try {
                        await AsyncStorage.removeItem('@all_events');
                        await AsyncStorage.removeItem('@appointments');
                        await AsyncStorage.removeItem('@marked_dates');

                    } catch (storageError) {
                        console.error('🔍 [삭제] AsyncStorage 삭제 오류:', storageError);
                    }
                    
                    // 🚨 중요: fetchHomeData() 호출하지 않음 - 로컬 상태만 사용

                                } else if (deleteMode === 'single') {
                    // 🚨 중요: 특정 날짜만 삭제한 경우
                    // fetchHomeData() 호출하지 않음 - 로컬 상태만 사용
                    // useEffect가 allEvents 변화를 감지하여 markedDates 자동 동기화
                }
            } else {
                let errorMessage = "삭제에 실패했습니다.";
                try {
                const errorData = await response.json();
                    errorMessage = errorData.message || errorData.error || errorMessage;
                } catch (parseError) {
                    console.error('❌ [삭제] 응답 파싱 오류:', parseError);
                }
                
                console.error('❌ [삭제] API 오류:', response.status, errorMessage);
                Alert.alert("삭제 실패", `오류 코드: ${response.status}\n${errorMessage}`);
            }
        } catch (error) {
            console.error('❌ [삭제] 네트워크 오류:', error);
            Alert.alert("오류", `네트워크 오류가 발생했습니다: ${error.message}`);
        }
    };
        // allEvents에서 appointments 데이터 생성 (반복 일정 포함)
    const generateAppointmentsFromAllEvents = () => {
        // 🚨 중요: 한국 시간 기준으로 오늘 날짜 가져오기
        const today = getKoreanToday();
        

        
        const appointments = [];
        
        // 오늘부터 7일간의 카드를 항상 생성
        for (let i = 0; i < 7; i++) {
            const date = new Date(today);
            date.setDate(today.getDate() + i);
            const dateString = date.toISOString().split('T')[0];
            
            
            
            // allEvents에서 해당 날짜의 일정 가져오기
            const events = allEvents && allEvents[dateString] ? allEvents[dateString] : [];
            
            appointments.push({
                date: dateString,
                events: events
            });
        }
        

        
        return appointments;
    };

    // allEvents에서 markedDates 데이터 생성 (달력 동그라미용)
    const generateMarkedDatesFromAllEvents = () => {
        const newMarkedDates = {};
        
        if (allEvents && typeof allEvents === 'object') {
            Object.keys(allEvents).forEach(dateString => {
                const events = allEvents[dateString];
                if (events && Array.isArray(events) && events.length > 0) {
                    // 해당 날짜에 일정이 있으면 마킹
                    // 기타 일정(개인 일정)은 회색, 파티 일정은 파란색, 랜덤런치는 노란색으로 표시
                    const hasPartySchedule = events.some(event => event.type === 'party' || event.isParty);
                    const hasPersonalSchedule = events.some(event => 
                        !event.type || 
                        event.type === 'personal' || 
                        !event.isParty || 
                        event.scheduleType === '기타 일정'
                    );
                    // 랜덤런치 확정된 일정 판단 조건 개선
                    const hasRandomLunch = events.some(event => 
                        event.is_from_match === true || 
                        event.type === '랜덤 런치' ||
                        event.scheduleType === '랜덤 런치' ||
                        (event.type === 'party' && event.is_from_match === true) ||
                        (event.type === 'party' && event.status === 'confirmed' && event.is_from_match === true)
                    );
                    
                    let selectedColor = '#3B82F6'; // 기본 파란색
                    
                    if (hasRandomLunch) {
                        // 랜덤런치가 있는 경우 노란색 (최우선)
                        selectedColor = '#F4D160'; // 노란색
                        console.log('🔍 [달력마크] 랜덤런치 노란색 마크:', dateString, events.filter(e => 
                            e.is_from_match === true || 
                            e.type === '랜덤 런치' ||
                            e.scheduleType === '랜덤 런치'
                        ));
                        
                        // 랜덤런치 일정의 경우 글자색을 남색으로 설정
                        newMarkedDates[dateString] = {
                            selected: true,
                            selectedColor: selectedColor,
                            textColor: '#1D5D9B' // 남색 글자색
                        };
                    } else if (hasPersonalSchedule && !hasPartySchedule) {
                        // 기타 일정만 있는 경우 회색
                        selectedColor = '#64748B'; // 기타 일정 색상
                        newMarkedDates[dateString] = {
                            selected: true,
                            selectedColor: selectedColor
                        };
                    } else if (hasPartySchedule) {
                        // 파티 일정이 있는 경우 파란색
                        selectedColor = '#3B82F6'; // 파란색
                        newMarkedDates[dateString] = {
                            selected: true,
                            selectedColor: selectedColor
                        };
                    }
                }
            });
        }
        
        return newMarkedDates;
    };
    
    // 🚨 중요: 잘못된 markedDates 정리 함수
    const cleanupInvalidMarkedDates = () => {
        if (!allEvents || !markedDates) return;
        
        const allEventDates = Object.keys(allEvents);
        const markedDateKeys = Object.keys(markedDates);
        
        // allEvents에 없는 날짜의 markedDates 제거
        const invalidDates = markedDateKeys.filter(date => !allEventDates.includes(date));
        
        if (invalidDates.length > 0) {
                            // console.log('🔍 [cleanupInvalidMarkedDates] 잘못된 markedDates 발견:', invalidDates);
            
            setMarkedDates(prev => {
                const newMarkedDates = { ...prev };
                invalidDates.forEach(date => {
                    delete newMarkedDates[date];
                });
                return newMarkedDates;
            });
            
                            // console.log('🔍 [cleanupInvalidMarkedDates] 잘못된 markedDates 정리 완료');
        }
    };

    // 🚨 중요: allEvents 상태 변화 감지하여 markedDates 동기화
    useEffect(() => {
        if (allEvents && Object.keys(allEvents).length > 0) {
            
            
            const newMarkedDates = generateMarkedDatesFromAllEvents();
            setMarkedDates(newMarkedDates);
            
            // AsyncStorage에도 저장
            try {
                AsyncStorage.setItem('@marked_dates', JSON.stringify(newMarkedDates));
    
            } catch (storageError) {
                console.error('🔍 [useEffect] AsyncStorage markedDates 저장 오류:', storageError);
            }
        }
    }, [allEvents]);

    // 기본 약속 상자들 생성 (약속 데이터가 없을 때 사용)
    const generateDefaultAppointments = () => {
        const defaultAppointments = [];
        const today = getKoreanToday();
        
        // 오늘부터 7일간의 기본 날짜 생성
        for (let i = 0; i < 7; i++) {
            const date = new Date(today);
            date.setDate(today.getDate() + i);
            const dateString = date.toISOString().split('T')[0];
            
            defaultAppointments.push({
                date: dateString,
                events: [] // 빈 이벤트 배열
            });
        }
        
        return defaultAppointments;
    };

    const renderAppointmentItem = ({ item }) => {
        const date = new Date(item.date);
        const dayOfWeek = ['일', '월', '화', '수', '목', '금', '토'][date.getDay()];
        return (
            <TouchableOpacity style={styles.appointmentCard}             onPress={() => { 
                setModalData({ visible: true, events: item.events || [], date: item.date }); 
            }}>
                <View style={styles.appointmentHeader}>
                    <Text style={styles.appointmentDate}>{`${date.getDate()}일 (${dayOfWeek})`}</Text>
                </View>
                {item.events && item.events.length > 0 ? (
                    item.events.map((event, index) => {
                        // 참석자에서 내 닉네임 제외 (userManager 사용)
                        const currentNickname = global.myNickname || '사용자';
                        
                        // 기타 일정의 attendees 필드 처리
                        let others = [];
                        if (event.attendees && Array.isArray(event.attendees)) {
                            // 기타 일정: attendees 배열에서 nickname 추출
                            others = event.attendees
                                .map(attendee => attendee.nickname || attendee.name)
                                .filter(name => name && name.toLowerCase() !== currentNickname.trim().toLowerCase());
                        } else if (event.all_members || event.members) {
                            // 파티 일정: 기존 방식
                            others = (event.all_members || event.members || []).map(s => s.trim()).filter(name => name.toLowerCase() !== currentNickname.trim().toLowerCase());
                        }
                        
                        // description에서 시간, 식당, 참석자 파싱 (필드가 없을 때만)
                        let parsedTime = event.time;
                        let parsedRestaurant = event.restaurant;
                        let parsedLocation = event.location;
                        
                        if ((!parsedTime || !parsedRestaurant || !parsedLocation || others.length === 0) && event.description) {
                            // 새로운 형식 파싱 (모이는 시간, 모이는 장소)
                            const timeMatch = event.description.match(/🕐 모이는 시간: ([^\n]+)/) || event.description.match(/시간: ([^\n]+)/);
                            const restaurantMatch = event.description.match(/🍽️ 식당: ([^\n]+)/);
                            const locationMatch = event.description.match(/📍 모이는 장소: ([^\n]+)/) || event.description.match(/장소: ([^\n]+)/);
                            const attendeesMatch = event.description.match(/👥 참석자: ([^\n]+)/) || event.description.match(/참가자: ([^\n]+)/);
                            
                            if (!parsedTime && timeMatch) parsedTime = timeMatch[1].trim();
                            if (!parsedRestaurant && restaurantMatch) parsedRestaurant = restaurantMatch[1].trim();
                            if (!parsedLocation && locationMatch) parsedLocation = locationMatch[1].trim();
                            if (others.length === 0 && attendeesMatch) {
                                // 참석자에서 (숫자명) 제거하고 파싱
                                const attendeesText = attendeesMatch[1].replace(/\s*\(\d+명\)$/, '');
                                others = attendeesText.split(',').map(s => s.trim()).filter(name => name && name.toLowerCase() !== currentNickname.trim().toLowerCase());
                            }
                        }
                        return (
                            <View key={index} style={styles.eventItem}>
                                <Text style={styles.eventTitle} numberOfLines={1}>
                                    {event.type === '랜덤 런치' ? '⚡️' : 
                                     (event.type === '파티' || event.isParty) ? '🎉' : 
                                     (event.scheduleType === '기타 일정' || !event.type) ? '📝' : '📝'} {event.title}
                                </Text>
                                {/* 시간 표시 */}
                                {parsedTime && <Text style={styles.eventDetail} numberOfLines={1}>⏰ {parsedTime}</Text>}
                                {/* 식당 표시 */}
                                {parsedRestaurant && <Text style={styles.eventDetail} numberOfLines={1}>🍽️ {parsedRestaurant}</Text>}
                                {/* 모이는 장소 표시 */}
                                {parsedLocation && <Text style={styles.eventDetail} numberOfLines={1}>📍 {parsedLocation}</Text>}
                                {/* 참석자(내 닉네임 제외) */}
                                {others.length > 0 && <Text style={styles.eventDetail} numberOfLines={1}>👥 {others.join(', ')}</Text>}
                            </View>
                        );
                    })
                ) : (<View style={{flex: 1, justifyContent: 'center'}}><Text style={styles.noAppointmentText}>약속 없음</Text></View>)}
            </TouchableOpacity>
        );
    };

    const renderRandomLunchCard = () => {
        return (
            <TouchableOpacity style={{
                backgroundColor: currentColors.primary,
                borderRadius: 20,
                marginHorizontal: 16,
                marginBottom: 16,
                padding: 20,
                elevation: 3,
                shadowColor: currentColors.primary,
                shadowOffset: { width: 0, height: 4 },
                shadowOpacity: 0.1,
                shadowRadius: 8,
                borderWidth: 1,
                borderColor: 'rgba(59, 130, 246, 0.1)'
            }} onPress={handleMatchPress}>
                <View style={{flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center'}}>
                    <Text style={{color: '#FFFFFF', fontSize: 20, fontWeight: 'bold', marginBottom: 12}}>랜덤 런치 🎲</Text>
                    <Ionicons name="shuffle" size={28} color="#FFFFFF" />
                </View>
                <Text style={{color: '#FFFFFF', fontSize: 16, marginTop: 8}}>새로운 동료와 점심 약속을 잡아보세요!</Text>
            </TouchableOpacity>
        );
    };
    
    return (
        <SafeAreaView style={styles.safeArea}>
            <ScrollView contentContainerStyle={styles.homeContainer}>
                <View style={{
                    backgroundColor: currentColors.surface,
                    borderRadius: 20,
                    marginHorizontal: 16,
                    marginBottom: 16,
                    marginTop: 14,
                    padding: 20,
                    elevation: 3,
                    shadowColor: currentColors.primary,
                    shadowOffset: { width: 0, height: 4 },
                    shadowOpacity: 0.1,
                    shadowRadius: 8,
                    borderWidth: 1,
                    borderColor: 'rgba(59, 130, 246, 0.1)'
                }}>
                    <Text style={styles.cardTitle}>오늘의 구내식당 메뉴 🍱</Text>
                    <Text style={styles.menuText}>{(todayMenu || []).length > 0 ? todayMenu.join(', ') : '메뉴 정보가 없습니다.'}</Text>
                </View>
                {renderRandomLunchCard()}
                
                <View style={{
                    backgroundColor: currentColors.surface,
                    borderRadius: 20,
                    marginHorizontal: 16,
                    marginBottom: 16,
                    padding: 20,
                    elevation: 3,
                    shadowColor: currentColors.primary,
                    shadowOffset: { width: 0, height: 4 },
                    shadowOpacity: 0.1,
                    shadowRadius: 8,
                    borderWidth: 1,
                    borderColor: 'rgba(59, 130, 246, 0.1)'
                }}>
                    <Text style={styles.cardTitle}>나의 점심 약속 🗓️</Text>
                    <FlatList 
                        data={generateAppointmentsFromAllEvents()} 
                        renderItem={renderAppointmentItem} 
                        keyExtractor={item => item.date} 
                        horizontal 
                        showsHorizontalScrollIndicator={false} 
                        contentContainerStyle={{ paddingVertical: 5 }} 
                    />
                </View>
                <View style={{
                    backgroundColor: currentColors.surface,
                    borderRadius: 20,
                    marginHorizontal: 16,
                    marginBottom: 16,
                    padding: 20,
                    elevation: 3,
                    shadowColor: currentColors.primary,
                    shadowOffset: { width: 0, height: 4 },
                    shadowOpacity: 0.1,
                    shadowRadius: 8,
                    borderWidth: 1,
                    borderColor: 'rgba(59, 130, 246, 0.1)'
                }}>
                    <Text style={styles.cardTitle}>달력 📅</Text>
                    <Calendar 
                        markedDates={markedDates} 
                        maxDate={new Date(Date.now() + 15 * 365 * 24 * 60 * 60 * 1000).toISOString().split('T')[0]} // 15년 후까지
                        onDayPress={(day) => { 
                            try {
                                // 🚨 중요: 안전한 헬퍼 함수 사용
                                const validEvents = getSafeEventsForDate(day.dateString);
                            
                                // console.log('🔍 [Calendar] onDayPress - 날짜:', day.dateString, '이벤트 수:', validEvents.length);
                            
                                // 날짜 클릭 시 모달 데이터 설정
                            setModalData({ visible: true, events: validEvents, date: day.dateString }); 
                            } catch (error) {
                                console.error('🔍 [Calendar] onDayPress 오류:', error);
                                setModalData({ visible: true, events: [], date: day.dateString });
                            }
                        }} 
                        theme={{ 
                            selectedDayBackgroundColor: currentColors.primary, 
                            todayTextColor: currentColors.primary, 
                            arrowColor: currentColors.primary,
                            selectedDayTextColor: '#FFFFFF',
                            'stylesheet.calendar.header': { 
                                week: { 
                                    marginTop: 5, 
                                    flexDirection: 'row', 
                                    justifyContent: 'space-between' 
                                } 
                            },
                            'stylesheet.day.basic': {
                                base: {
                                    width: 32,
                                    height: 32,
                                    alignItems: 'center',
                                    justifyContent: 'center'
                                }
                            },
                            'stylesheet.day.single': {
                                base: {
                                    width: 32,
                                    height: 32,
                                    alignItems: 'center',
                                    justifyContent: 'center'
                                },
                                selected: {
                                    backgroundColor: 'transparent',
                                    borderRadius: 16,
                                    borderWidth: 2,
                                    borderColor: 'transparent'
                                }
                            },
                            // 랜덤런치 일정의 글자색을 남색으로 설정
                            'stylesheet.day.marked': {
                                base: {
                                    width: 32,
                                    height: 32,
                                    alignItems: 'center',
                                    justifyContent: 'center'
                                }
                            }
                        }} 
                    />
                </View>
            </ScrollView>

            {/* 새로운 일정 상세 모달 */}
            <ScheduleDetailModal
                visible={modalData.visible && (modalData.events || []).length > 0}
                onClose={() => setModalData({ ...modalData, visible: false })}
                events={modalData.events || []}
                date={modalData.date}
                navigation={navigation}
                onEdit={handleEditPersonalSchedule}
                onDelete={handleDeletePersonalSchedule}
            />

            {/* 기존 일정 추가 옵션 모달 */}
            <Modal 
                visible={modalData.visible && (!modalData.events || modalData.events.length === 0)} 
                transparent={true} 
                animationType="fade" 
                onRequestClose={() => setModalData({ ...modalData, visible: false })}
            >
                <Pressable style={styles.centeredView} onPress={() => setModalData({ ...modalData, visible: false })}>
                    <Pressable style={styles.modalView} onPress={(e) => e.stopPropagation()}>
                        {/* 일정 추가 옵션만 표시 */} 
                            <>
                                <Text style={styles.modalTitle}>점심 약속을 만들어 볼까요?</Text>
                                <View style={styles.appointmentOptionsContainer}>
                                    <TouchableOpacity style={[styles.appointmentOptionButton, {backgroundColor: currentColors.yellow}]} onPress={() => { setModalData({ visible: false }); handleMatchPress(); }}>
                                        <View style={styles.optionContent}>
                                            <Text style={[styles.optionTitle, {color: currentColors.deepBlue}]}>🎲 랜덤 런치</Text>
                                            <Text style={[styles.optionSubtitle, {color: currentColors.deepBlue}]}>AI가 추천하는 동료와 함께</Text>
                                        </View>
                                        <Ionicons name="chevron-forward" size={20} color={currentColors.deepBlue} />
                                    </TouchableOpacity>
                                    
                                    <TouchableOpacity style={[styles.appointmentOptionButton, {backgroundColor: currentColors.primary}]} onPress={() => { setModalData({ visible: false }); safeNavigateToTab(navigation, '파티', 'CreateParty'); }}>
                                        <View style={styles.optionContent}>
                                            <Text style={[styles.optionTitle, {color: '#FFFFFF'}]}>🎉 그룹 파티</Text>
                                            <Text style={[styles.optionSubtitle, {color: '#FFFFFF'}]}>가고 싶은 맛집에 그룹 사냥을</Text>
                                        </View>
                                        <Ionicons name="chevron-forward" size={20} color="#FFFFFF" />
                                    </TouchableOpacity>
                                    
                                    <TouchableOpacity style={[styles.appointmentOptionButton, {backgroundColor: currentColors.secondary}]} onPress={() => { 
                                        setModalData({ visible: false }); 
                                        safeNavigateToTab(navigation, '소통', 'VotingScreen', {
                                            chatRoomId: -1,
                                            chatTitle: '',
                                            participants: [{ 
                                                employee_id: user.employee_id, 
                                                nickname: user.nickname 
                                            }]
                                        });
                                    }}>
                                        <View style={styles.optionContent}>
                                            <Text style={[styles.optionTitle, {color: '#FFFFFF'}]}>🗳️ 스마트 일정 조율</Text>
                                            <Text style={[styles.optionSubtitle, {color: '#FFFFFF'}]}>약속이 없는 일정만 골라서 투표</Text>
                                        </View>
                                        <Ionicons name="chevron-forward" size={20} color="#FFFFFF" />
                                    </TouchableOpacity>
                                    
                                    <TouchableOpacity style={[styles.appointmentOptionButton, {backgroundColor: currentColors.gray}]} onPress={() => { 
                                        const dateToUse = modalData.date || toLocalDateString(getKoreanToday());
                                        setModalData({ visible: false }); 
                                        safeNavigateToTab(navigation, '파티', 'CreatePersonalSchedule', { date: dateToUse }); 
                                    }}>
                                        <View style={styles.optionContent}>
                                            <Text style={[styles.optionTitle, {color: '#FFFFFF'}]}>📝 기타 일정</Text>
                                            <Text style={[styles.optionSubtitle, {color: '#FFFFFF'}]}>나만의 개인 일정</Text>
                                        </View>
                                        <Ionicons name="chevron-forward" size={20} color="#FFFFFF" />
                                    </TouchableOpacity>
                                </View>
                            </>
                    </Pressable>
                </Pressable>
            </Modal>
            
            {/* 플로팅 빠른 액션 버튼 */}
            <TouchableOpacity
                style={{
                    position: 'absolute',
                    right: 24,
                    bottom: 32,
                    width: 56,
                    height: 56,
                    borderRadius: 28,
                    backgroundColor: currentColors.primary,
                    justifyContent: 'center',
                    alignItems: 'center',
                    zIndex: 10,
                    elevation: 8,
                    shadowColor: currentColors.primary,
                    shadowOffset: { width: 0, height: 4 },
                    shadowOpacity: 0.3,
                    shadowRadius: 8
                }}
                activeOpacity={0.85}
                onPress={() => {
                    // 🎯 홈탭에서 이미 계산된 정확한 오늘 날짜를 전역 변수에서 가져오기
                    const todayString = global.homeTodayDate || toLocalDateString(getKoreanToday());
                    setModalData({ visible: true, events: [], date: todayString });
                }}
            >
                <Ionicons name="add" size={32} color="#fff" />
            </TouchableOpacity>
            
            <MissionModal 
                visible={missionModalVisible}
                onClose={() => setMissionModalVisible(false)}
                navigation={navigation}
                onMissionUpdate={() => {
                    // 미션 수령 후 즉시 헤더의 빨간 점 상태 갱신
                    // 이 콜백은 MissionModal에서 미션 수령 시 호출됨
                    // TabNavigator의 상태를 즉시 업데이트하여 홈탭과 헤더의 빨간 점 동기화
                }}
            />
            

        </SafeAreaView>
    );
}

// --- 새로운 랜덤 런치 시스템 화면들 ---
function SelectLunchDateScreen({ navigation }) {
    const { user } = useAuth();
    const [availableDates, setAvailableDates] = useState([]);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        fetchAvailableDates();
    }, []);

    const fetchAvailableDates = async () => {
        try {
            setLoading(true);
            const response = await fetch(`${RENDER_SERVER_URL}/proposals/available-dates?employee_id=${global.myEmployeeId || '1'}`);
            const data = await response.json();
            if (response.ok) {
                // 오늘 이후(오늘 포함) 날짜만 남기기
                const today = new Date();
                today.setHours(0, 0, 0, 0); // 오늘 00:00

                const filteredDates = data.filter(d => {
                    // d가 'YYYY-MM-DD' 문자열이면, 항상 UTC 기준으로 해석
                    const dateObj = new Date(d + 'T00:00:00Z');
                    // 한국 시간(UTC+9)으로 변환
                    const koreaDate = new Date(dateObj.getTime() + 9 * 60 * 60 * 1000);
                    koreaDate.setHours(0, 0, 0, 0);
                    
                    return koreaDate > today; // 오늘보다 큰 날짜(내일부터)만 남김
                });
                
                setAvailableDates(filteredDates);
} else {
    Alert.alert('오류', data.message || '날짜 정보를 가져오는데 실패했습니다.');
}
        } catch (error) {
            console.error('날짜 조회 오류:', error);
            Alert.alert('오류', '네트워크에 문제가 발생했습니다.');
        } finally {
            setLoading(false);
        }
    };

    const handleDateSelect = (date) => {
        navigation.navigate('SuggestGroupScreen', { selectedDate: date });
    };



    const renderDateButton = ({ item }) => {
        const date = new Date(item);
        const dayOfWeek = ['일', '월', '화', '수', '목', '금', '토'][date.getDay()];
        const isToday = new Date().toDateString() === date.toDateString();
        
        return (
            <TouchableOpacity 
                style={[styles.dateButton, isToday && styles.todayButton]} 
                onPress={() => handleDateSelect(item)}
            >
                <Text style={[styles.dateButtonText, isToday && styles.todayButtonText]}>
                    {date.getDate()}일
                </Text>
                <Text style={[styles.dateButtonSubText, isToday && styles.todayButtonText]}>
                    ({dayOfWeek})
                </Text>
                {isToday && <Text style={styles.todayLabel}>오늘</Text>}
            </TouchableOpacity>
        );
    };

    if (loading) {
        return (
            <SafeAreaView style={styles.safeArea}>
                <View style={styles.loadingContainer}>
                    <ActivityIndicator size="large" color={currentColors.primary} />
                    <Text style={styles.loadingText}>날짜 정보를 불러오는 중...</Text>
                </View>
            </SafeAreaView>
        );
    }

    return (
        <SafeAreaView style={styles.safeArea}>
            <ScrollView style={styles.container}>
                <FlatList
                    data={availableDates}
                    renderItem={renderDateButton}
                    keyExtractor={item => item}
                    numColumns={3}
                    contentContainerStyle={styles.dateGrid}
                    scrollEnabled={false}
                />
            </ScrollView>
        </SafeAreaView>
    );
}
function SuggestGroupScreen({ navigation, route }) {
    const { user } = useAuth();
    const { selectedDate } = route?.params || {};
    const [suggestedGroups, setSuggestedGroups] = useState([]);
    const [loading, setLoading] = useState(true);
    const [currentGroupIndex, setCurrentGroupIndex] = useState(0);
    const [proposedGroups, setProposedGroups] = useState(new Set());
    
    // 랜덤런치 탭에서 사용될 때 기본 날짜 설정
    const defaultDate = selectedDate || new Date();
    const [currentDate, setCurrentDate] = useState(defaultDate);

    useEffect(() => {
        fetchSuggestedGroups();
    }, [currentDate]);

    useEffect(() => {
        if (suggestedGroups.length > 0) {
            fetchMyProposals();
        }
    }, [suggestedGroups]);

    // 화면이 포커스될 때마다 제안 상태 새로고침
    useFocusEffect(
        useCallback(() => {
            fetchMyProposals();
        }, [])
    );

    const fetchMyProposals = async () => {
        try {
            const response = await fetch(`${RENDER_SERVER_URL}/proposals/mine?employee_id=${global.myEmployeeId || '1'}`);
            const data = await response.json();
            if (response.ok) {
                const sentProposals = data.sent_proposals || [];
                const pendingProposals = sentProposals.filter(p => p.status === 'pending');
                const proposedGroupKeys = new Set();
                pendingProposals.forEach(proposal => {
                    if (proposal.recipient_ids) {
                        // 여기 두 줄이 중요!
                        const ids = parseRecipientIds(proposal.recipient_ids);
                        const groupKey = getGroupKeyFromIds(ids);
                        proposedGroupKeys.add(groupKey);
                    }
                });
                setProposedGroups(proposedGroupKeys);
            }
        } catch (error) {
            console.error('제안 상태 조회 오류:', error);
        }
    };

    const fetchSuggestedGroups = async () => {
        try {
            setLoading(true);
            // 가상 그룹 매칭 API 사용 - 여러 그룹 지원
            const response = await fetch(`${RENDER_SERVER_URL}/dev/random-lunch/${user.employee_id || '1'}`);
            const groupsData = await response.json();
            
            if (response.ok && groupsData && Array.isArray(groupsData)) {
                // API가 배열을 반환하므로 각 그룹을 변환
                const virtualGroups = groupsData.map(data => ({
                    id: data.id,
                    date: data.date,
                    members: data.members,
                    status: data.status,
                    created_at: data.created_at,
                    score: data.score || 0,
                    // 화면 표시용 추가 필드
                    title: `🍽️ ${data.date} 점심 모임`,
                    current_members: data.current_members || data.members.length,
                    max_members: data.max_members || 4,
                    restaurant_name: '추천 식당',
                    party_date: data.date,
                    party_time: '12:00',
                    users: data.members.map(memberId => {
                        // memberId를 기반으로 실제 닉네임 가져오기
                        const nicknames = {
                            '1': '김철수', '2': '이영희', '3': '박민수', '4': '최지은', '5': '정현우',
                            '6': '한소영', '7': '윤준호', '8': '송미라', '9': '강동현', '10': '임서연',
                            '11': '오태호', '12': '신유진', '13': '조성민', '14': '백하은', '15': '남준석',
                            '16': '류지현', '17': '차준호', '18': '구미영', '19': '홍성훈', '20': '전소연'
                        };
                        return {
                            employee_id: memberId,
                            nickname: nicknames[memberId] || `사용자${memberId}`,
                            profile_image: null
                        };
                    })
                }));
                
                setSuggestedGroups(virtualGroups);
                console.log('✅ [랜덤런치]', virtualGroups.length, '개 그룹 매칭 완료');
            } else {
                setSuggestedGroups([]);
            }
        } catch (error) {
            console.error('그룹 추천 오류:', error);
            setSuggestedGroups([]);
        } finally {
            setLoading(false);
        }
    };

    const handleCancelSentProposal = async (proposalId) => {
        try {
            const response = await fetch(`${RENDER_SERVER_URL}/proposals/${proposalId}/cancel`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ employee_id: user.employee_id })
            });
            
            if (response.ok) {
                Alert.alert('알림', '제안이 취소되었습니다.');
                fetchMyProposals();
            } else {
                Alert.alert('오류', '제안 취소에 실패했습니다.');
            }
        } catch (error) {
            console.error('제안 취소 오류:', error);
            Alert.alert('오류', '네트워크에 문제가 발생했습니다.');
        }
    };

    const handleProposeGroup = async (group) => {
        // 그룹 키 생성 (날짜 포함)
        const groupUserIds = group.users
            .map(user => user.employee_id)
            .filter(id => id && id.trim().length > 0)
            .sort();
        const selectedDateStr = toKoreanDateString(selectedDate);
        const groupKey = getGroupKeyFromIds(groupUserIds, selectedDateStr);
        
        // 이미 제안한 그룹이면 취소
        if (group.isProposed || proposedGroups.has(groupKey)) {
            try {
                // 해당 날짜에 내가 보낸 제안 찾기
                const response = await fetch(`${RENDER_SERVER_URL}/proposals/mine?employee_id=${user.employee_id}`);
                const data = await response.json();
                
                if (response.ok) {
                    const sentProposals = data.sent_proposals || [];
                    
                    // 해당 그룹에 해당하는 제안 찾기
                    const myProposal = sentProposals.find(proposal => {
                        if (proposal.proposed_date !== selectedDate || proposal.status !== 'pending') {
                            return false;
                        }
                        
                        if (proposal.recipient_ids) {
                            const recipientIds = parseRecipientIds(proposal.recipient_ids);
                            return getGroupKeyFromIds(recipientIds) === groupKey;
                        }
                        return false;
                    });
                    
                    if (myProposal) {
                        const cancelResponse = await fetch(`${RENDER_SERVER_URL}/proposals/${myProposal.id}/cancel`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ employee_id: user.employee_id })
                        });
                        
                        if (cancelResponse.ok) {
                            setProposedGroups(prev => {
                                const newSet = new Set(prev);
                                newSet.delete(groupKey);
                                return newSet;
                            });
                            Alert.alert('알림', '제안이 취소되었습니다.');
                            fetchMyProposals();
                            fetchSmartRecommendations(false);
                        } else {
                            Alert.alert('오류', '제안 취소에 실패했습니다.');
                        }
                    }
                }
            } catch (error) {
                console.error('제안 취소 오류:', error);
                Alert.alert('오류', '네트워크에 문제가 발생했습니다.');
            }
            fetchMyProposals();
            return;
        }

        try {
            const recipientIds = group.users
                .map(user => user.employee_id)
                .filter(id => id && id.trim().length > 0);
            const response = await fetch(`${RENDER_SERVER_URL}/proposals`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    proposer_id: user.employee_id,
                    recipient_ids: recipientIds,
                    proposed_date: toKoreanDateString(selectedDate)
                })
            });
            const data = await response.json();
            if (response.ok) {
                // 즉시 UI 업데이트
                setProposedGroups(prev => new Set([...prev, groupKey]));
                Alert.alert('성공', '제안이 전송되었습니다.');
                fetchMyProposals();
            } else {
                Alert.alert('오류', data.message || '제안에 실패했습니다.');
            }
        } catch (error) {
            console.error('제안 오류:', error);
            Alert.alert('오류', '네트워크에 문제가 발생했습니다.');
        }
        fetchMyProposals();
    };

    const renderUserCard = ({ item }) => {
        console.log('DEBUG: renderUserCard item:', item);
        return (
        <View style={{
            backgroundColor: currentColors.surface,
            borderRadius: 16,
            padding: 16,
            marginBottom: 12,
            elevation: 2,
            shadowColor: currentColors.primary,
            shadowOffset: { width: 0, height: 2 },
            shadowOpacity: 0.1,
            shadowRadius: 4,
            borderWidth: 1,
            borderColor: 'rgba(59, 130, 246, 0.1)'
        }}>
                            <View style={{flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', marginBottom: 8}}>
                <View style={{flexDirection: 'row', alignItems: 'center', flex: 1}}>
                    {/* 아바타 이미지 공간 */}
                    <View style={{
                        width: 40,
                        height: 40,
                        borderRadius: 20,
                        backgroundColor: '#3B82F6',
                        marginRight: 12,
                        justifyContent: 'center',
                        alignItems: 'center',
                        borderWidth: 1,
                        borderColor: '#2563EB'
                    }}>
                        <Text style={{
                            fontSize: 18,
                            color: '#FFFFFF',
                            fontWeight: 'bold'
                        }}>
                            {item.nickname ? item.nickname.charAt(0) : '?'}
                        </Text>
                    </View>
                    <Text style={{fontSize: 16, fontWeight: 'bold', color: currentColors.text, flex: 1}}>{item.nickname}</Text>
                </View>
                <View style={{
                    backgroundColor: currentColors.yellow,
                    borderRadius: 12,
                    paddingVertical: 4,
                    paddingHorizontal: 8
                }}>
                    <Text style={{color: currentColors.deepBlue, fontSize: 'bold', fontSize: 12}}>추천</Text>
                </View>
            </View>
            {item.lunch_preference && (
                <Text style={{fontSize: 14, color: currentColors.textSecondary, marginBottom: 4}}>🍽️ {item.lunch_preference}</Text>
            )}
            {item.main_dish_genre && (
                <Text style={{fontSize: 14, color: currentColors.textSecondary}}>🍜 {item.main_dish_genre}</Text>
            )}
        </View>
        );
    };

    const renderGroupCard = ({ item, index }) => {
        // 그룹 키 생성 (날짜 포함)
        const groupUserIds = item.users
            .map(user => user.employee_id)
            .filter(id => id && id.trim().length > 0)
            .sort();
        const selectedDateStr = toKoreanDateString(selectedDate);
        const groupKey = getGroupKeyFromIds(groupUserIds, selectedDateStr);
        
        return (
            <View style={{
                backgroundColor: currentColors.surface,
                borderRadius: 20,
                padding: 20,
                marginHorizontal: 16,
                marginBottom: 16,
                elevation: 3,
                shadowColor: currentColors.primary,
                shadowOffset: { width: 0, height: 4 },
                shadowOpacity: 0.1,
                shadowRadius: 8,
                borderWidth: 1,
                borderColor: 'rgba(59, 130, 246, 0.1)'
            }}>
                <View style={{marginBottom: 16}}>
                    <View style={{flexDirection: 'row', alignItems: 'center', marginBottom: 8}}>
                        {/* 그룹 아바타 */}
                        <View style={{
                            width: 50,
                            height: 50,
                            borderRadius: 25,
                            backgroundColor: '#FF0000',
                            marginRight: 15,
                            justifyContent: 'center',
                            alignItems: 'center'
                        }}>
                            <Text style={{
                                fontSize: 20,
                                color: '#FFFFFF',
                                fontWeight: 'bold'
                            }}>
                                {index + 1}
                            </Text>
                        </View>
                        <Text style={{fontSize: 20, fontWeight: 'bold', color: currentColors.primary}}>
                            추천 그룹 {index + 1}
                        </Text>
                    </View>
                    <Text style={{fontSize: 14, color: currentColors.textSecondary}}>
                        성향이 맞는 동료들과 함께 점심을 먹어보세요!
                    </Text>
                </View>
                
                <FlatList
                    data={item.recommended_group}
                    renderItem={renderUserCard}
                    keyExtractor={(user, index) => `user-${user.employee_id}-${index}`}
                    scrollEnabled={false}
                />
                
                <TouchableOpacity 
                    style={{
                        backgroundColor: item.isProposed ? currentColors.gray : currentColors.primary,
                        borderRadius: 16,
                        padding: 16,
                        marginTop: 16,
                        elevation: 3,
                        shadowColor: currentColors.primary,
                        shadowOffset: { width: 0, height: 2 },
                        shadowOpacity: 0.2,
                        shadowRadius: 4
                    }}
                    onPress={() => handleProposeGroup(item)}
                >
                    <Text style={{
                        color: '#FFFFFF',
                        fontWeight: 'bold',
                        textAlign: 'center',
                        fontSize: 16
                    }}>
                        {item.isProposed ? '제안 취소' : '이 그룹에 제안하기'}
                    </Text>
                </TouchableOpacity>
            </View>
        );
    };

    if (loading) {
        return (
            <SafeAreaView style={styles.safeArea}>
                <View style={{
                    flex: 1,
                    justifyContent: 'center',
                    alignItems: 'center',
                    padding: 20,
                    backgroundColor: currentColors.background
                }}>
                    <ActivityIndicator size="large" color={currentColors.primary} />
                    <Text style={{
                        fontSize: 16,
                        color: currentColors.textSecondary,
                        marginTop: 16
                    }}>추천 그룹을 찾는 중...</Text>
                </View>
            </SafeAreaView>
        );
    }

    return (
        <SafeAreaView style={styles.safeArea}>
            <ScrollView style={styles.container}>
                <View style={{
                    backgroundColor: currentColors.surface,
                    borderRadius: 20,
                    padding: 20,
                    marginHorizontal: 16,
                    marginBottom: 16,
                    elevation: 3,
                    shadowColor: currentColors.primary,
                    shadowOffset: { width: 0, height: 4 },
                    shadowOpacity: 0.1,
                    shadowRadius: 8,
                    borderWidth: 1,
                    borderColor: 'rgba(59, 130, 246, 0.1)'
                }}>
                    <Text style={{
                        fontSize: 18,
                        fontWeight: 'bold',
                        marginBottom: 12,
                        color: currentColors.primary
                    }}>
                        {new Date(currentDate).getMonth() + 1}월 날짜 선택
                    </Text>
                    <Text style={{
                        fontSize: 16,
                        color: currentColors.textSecondary,
                        lineHeight: 24,
                        marginBottom: 16
                    }}>
                        성향이 맞는 동료들과 함께 점심을 먹어보세요!
                        {suggestedGroups.length > 1 && ' 좌우로 스와이프하여 다른 그룹도 확인해보세요.'}
                    </Text>
                    
                    {/* 날짜 선택 버튼 */}
                    <TouchableOpacity
                        style={{
                            backgroundColor: currentColors.primary,
                            borderRadius: 12,
                            padding: 12,
                            alignItems: 'center'
                        }}
                        onPress={() => {
                            // 날짜 선택 모달 열기
                            const newDate = new Date(currentDate);
                            newDate.setDate(newDate.getDate() + 1);
                            setCurrentDate(newDate);
                        }}
                    >
                        <Text style={{
                            color: '#FFFFFF',
                            fontWeight: 'bold',
                            fontSize: 16
                        }}>
                            다음 날짜로 변경
                        </Text>
                    </TouchableOpacity>
                </View>
                
                {suggestedGroups.length > 0 ? (
                    <>
                        <FlatList
                            data={suggestedGroups}
                            renderItem={renderGroupCard}
                            keyExtractor={item => `group-${item.group_id}`}
                            horizontal
                            pagingEnabled
                            showsHorizontalScrollIndicator={false}
                            onMomentumScrollEnd={(event) => {
                                const index = Math.round(event.nativeEvent.contentOffset.x / (SCREEN_WIDTH - 32));
                                setCurrentGroupIndex(index);
                            }}
                            contentContainerStyle={{ paddingHorizontal: 0 }}
                        />
                        
                        {suggestedGroups.length > 1 && (
                            <View style={{
                                flexDirection: 'row',
                                justifyContent: 'center',
                                alignItems: 'center',
                                marginTop: 20,
                                marginBottom: 20
                            }}>
                                {suggestedGroups.map((_, index) => (
                                    <View
                                        key={index}
                                        style={{
                                            width: 8,
                                            height: 8,
                                            borderRadius: 4,
                                            backgroundColor: index === currentGroupIndex ? currentColors.primary : currentColors.lightGray,
                                            marginHorizontal: 4
                                        }}
                                    />
                                ))}
                            </View>
                        )}
                    </>
                ) : (
                    <View style={{
                        flex: 1,
                        justifyContent: 'center',
                        alignItems: 'center',
                        padding: 20,
                        backgroundColor: currentColors.background
                    }}>
                        <Text style={{
                            fontSize: 16,
                            color: currentColors.textSecondary,
                            textAlign: 'center',
                            marginTop: 50
                        }}>
                            해당 날짜에 추천할 수 있는 동료가 없습니다.
                        </Text>
                    </View>
                )}
            </ScrollView>
        </SafeAreaView>
    );
}
function MyProposalsScreen({ navigation }) {
    const { user } = useAuth();
    const [proposals, setProposals] = useState({ sent_proposals: [], received_proposals: [] });
    const [loading, setLoading] = useState(true);
    const [expandedProposals, setExpandedProposals] = useState(new Set());
    const [groupMembersMap, setGroupMembersMap] = useState({});
    const [confirmedGroups, setConfirmedGroups] = useState([]);

    useEffect(() => {
        fetchMyProposals();
        fetchConfirmedGroups();
    }, []);

    // 화면이 포커스될 때마다 제안 목록 새로고침
    useFocusEffect(
        useCallback(() => {
            fetchMyProposals();
            fetchConfirmedGroups();
        }, [])
    );

    const fetchConfirmedGroups = async () => {
        try {
            const response = await fetch(`${RENDER_SERVER_URL}/parties?employee_id=${global.myEmployeeId || '1'}&is_from_match=true`);
            const data = await response.json();
            if (response.ok && Array.isArray(data)) {
                // API 응답 데이터를 안전하게 처리 (members_employee_ids 필드 제거)
                const safeData = data.map(party => {
                    // members_employee_ids 필드를 제거하고 필요한 필드만 추출
                    const { members_employee_ids, ...safeParty } = party;
                    
                    return {
                        ...safeParty,
                        // 기본값 설정
                        current_members: party.current_members || party.members_count || 1,
                        restaurant_name: party.restaurant_name || party.restaurant || '식당명 없음',
                        party_date: party.party_date || party.date || '날짜 없음'
                    };
                });
                setConfirmedGroups(safeData);
            }
        } catch (error) {
            console.error('성사된 그룹 조회 오류:', error);
            // 오류 발생 시 빈 배열로 설정
            setConfirmedGroups([]);
        }
    };

    const handleRejectProposal = async (proposalId) => {
        try {
            const response = await fetch(`${RENDER_SERVER_URL}/proposals/${proposalId}/reject`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ user_id: user.employee_id })
            });
            const data = await response.json();
            if (response.ok) {
                Alert.alert('알림', data.message || '제안을 거절했습니다.');
                fetchMyProposals(); // 목록 새로고침
            } else {
                Alert.alert('오류', data.message || '거절에 실패했습니다.');
            }
        } catch (error) {
            console.error('제안 거절 오류:', error);
            Alert.alert('오류', '네트워크에 문제가 발생했습니다.');
        }
    };

    const fetchMyProposals = async () => {
        try {
            setLoading(true);
            const response = await fetch(`${RENDER_SERVER_URL}/proposals/mine?employee_id=${user.employee_id}`);
            const data = await response.json();
            if (response.ok) {
                // 취소된 제안만 제거
                const filterProposals = (proposals) => proposals.filter(p => p.status !== 'cancelled');
                const filteredData = {
                    sent_proposals: filterProposals(data.sent_proposals || []),
                    received_proposals: filterProposals(data.received_proposals || [])
                };
                setProposals(filteredData);
                // 보낸 제안들의 그룹 멤버 정보를 바로 가져오기
                const sentProposals = filteredData.sent_proposals || [];
                for (const proposal of sentProposals) {
                    if (proposal.recipient_ids) {
                        fetchGroupMembers(proposal.id, proposal.recipient_ids);
                    }
                }
            } else {
                Alert.alert('오류', data.message || '제안 목록을 가져오는데 실패했습니다.');
            }
        } catch (error) {
            console.error('제안 목록 조회 오류:', error);
            Alert.alert('오류', '네트워크에 문제가 발생했습니다.');
        } finally {
            setLoading(false);
        }
    };

    const handleAcceptProposal = async (proposalId) => {
        try {
            const response = await fetch(`${RENDER_SERVER_URL}/proposals/${proposalId}/accept`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ user_id: user.employee_id })
            });
            const data = await response.json();
            
            if (response.ok) {
                if (data.status === 'confirmed') {
                    Alert.alert('성공!', '매칭이 성사되었습니다!');
                } else {
                    Alert.alert('알림', data.message);
                }
                fetchMyProposals();
            } else {
                Alert.alert('오류', data.message || '수락에 실패했습니다.');
            }
        } catch (error) {
            console.error('제안 수락 오류:', error);
            Alert.alert('오류', '네트워크에 문제가 발생했습니다.');
        }
    };

    const handleCancelProposal = async (proposalId) => {
        try {
            const response = await fetch(`${RENDER_SERVER_URL}/proposals/${proposalId}/cancel`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ user_id: user.employee_id })
            });
            const data = await response.json();
            
            if (response.ok) {
                Alert.alert('알림', data.message);
                // 목록에서 즉시 제거
                setProposals(prev => ({
                    sent_proposals: prev.sent_proposals.filter(p => p.id !== proposalId),
                    received_proposals: prev.received_proposals
                }));
            } else {
                Alert.alert('오류', data.message || '취소에 실패했습니다.');
            }
        } catch (error) {
            console.error('제안 취소 오류:', error);
            Alert.alert('오류', '네트워크에 문제가 발생했습니다.');
        }
    };

    const toggleProposalExpansion = (proposalId) => {
        setExpandedProposals(prev => {
            const newSet = new Set(prev);
            if (newSet.has(proposalId)) {
                newSet.delete(proposalId);
            } else {
                newSet.add(proposalId);
            }
            return newSet;
        });
    };

    const fetchGroupMembers = async (proposalId, recipientIds) => {
        try {
            const userIds = parseRecipientIds(recipientIds);
            
            console.log('그룹 멤버 조회:', { proposalId, recipientIds, userIds });
            
            if (userIds.length === 0) {
                console.log('유효한 사용자 ID가 없음');
                setGroupMembersMap(prev => ({
                    ...prev,
                    [proposalId]: []
                }));
                return;
            }
            
            const response = await fetch(`${RENDER_SERVER_URL}/users/batch`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ user_ids: userIds })
            });
            
            console.log('API 응답 상태:', response.status);
            const data = await response.json();
            console.log('API 응답 데이터:', data);
            
            if (response.ok && Array.isArray(data)) {
                setGroupMembersMap(prev => ({
                    ...prev,
                    [proposalId]: data
                }));
                console.log('그룹 멤버 정보 저장 완료:', data);
            } else {
                console.error('API 응답 오류:', data);
                // 에러 시에도 빈 배열로 설정하여 로딩 상태 해제
                setGroupMembersMap(prev => ({
                    ...prev,
                    [proposalId]: []
                }));
            }
        } catch (error) {
            console.error('그룹 멤버 정보 조회 오류:', error);
            // 에러 시에도 빈 배열로 설정하여 로딩 상태 해제
            setGroupMembersMap(prev => ({
                ...prev,
                [proposalId]: []
            }));
        }
    };

    const renderConfirmedGroupItem = ({ item }) => (
        <TouchableOpacity 
            style={{
                backgroundColor: currentColors.surface,
                borderRadius: 20,
                padding: 20,
                marginHorizontal: 6,
                width: SCREEN_WIDTH * 0.5,
                height: 160,
                borderWidth: 1,
                borderColor: 'rgba(59, 130, 246, 0.1)',
                justifyContent: 'flex-start',
                elevation: 3,
                shadowColor: currentColors.primary,
                shadowOffset: { width: 0, height: 4 },
                shadowOpacity: 0.1,
                shadowRadius: 8
            }}
            onPress={() => navigation.navigate('PartyDetail', { partyId: item.id })}
        >
            <View style={{marginBottom: 6}}>
                <Text style={{fontSize: 16, fontWeight: 'bold', color: currentColors.text}}>⚡️ {item.party_date}</Text>
            </View>
            <Text style={{fontSize: 13, color: currentColors.textSecondary, marginBottom: 6}}>
                👥 {item.current_members}명 참여
            </Text>
            <Text style={{fontSize: 13, color: currentColors.textSecondary}}>
                🍽️ {item.restaurant_name}
            </Text>
        </TouchableOpacity>
    );

    const renderProposalItem = ({ item, type }) => {
        const isPending = item.status === 'pending';
        const isReceived = type === 'received';
        const isExpanded = expandedProposals.has(item.id);
        const groupMembers = groupMembersMap[item.id] || [];
        
        // 그룹 멤버 정보 가져오기 (hooks 없이 처리)
        if (isExpanded && type === 'sent' && item.recipient_ids && !groupMembersMap[item.id]) {
            console.log('그룹 멤버 정보 요청:', { proposalId: item.id, recipientIds: item.recipient_ids });
            fetchGroupMembers(item.id, item.recipient_ids);
        }
        
        return (
            <View style={{
                backgroundColor: currentColors.surface,
                borderRadius: 20,
                marginHorizontal: 16,
                marginBottom: 16,
                padding: 20,
                elevation: 3,
                shadowColor: currentColors.primary,
                shadowOffset: { width: 0, height: 4 },
                shadowOpacity: 0.1,
                shadowRadius: 8,
                borderWidth: 1,
                borderColor: 'rgba(59, 130, 246, 0.1)'
            }}>
                <TouchableOpacity 
                    style={{flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center'}}
                    onPress={() => toggleProposalExpansion(item.id)}
                >
                    <Text style={{fontSize: 16, fontWeight: 'bold', color: currentColors.text}}>
                        {new Date(item.proposed_date).toLocaleDateString('ko-KR', { 
                            month: 'long', 
                            day: 'numeric' 
                        })}
                    </Text>
                    <View style={{flexDirection: 'row', alignItems: 'center'}}>
                        <View style={{
                            backgroundColor: item.status === 'confirmed' ? currentColors.success : 
                                          item.status === 'cancelled' ? currentColors.error : 
                                          item.status === 'expired' ? currentColors.warning : currentColors.primaryLight,
                            borderRadius: 20,
                            paddingVertical: 6,
                            paddingHorizontal: 12,
                            marginRight: 8
                        }}>
                            <Text style={{color: item.status === 'confirmed' ? '#FFFFFF' : 
                                         item.status === 'cancelled' ? '#FFFFFF' : 
                                         item.status === 'expired' ? '#FFFFFF' : currentColors.primary, 
                                         fontWeight: 'bold', fontSize: 12}}>
                                {item.status === 'pending' ? '대기중' : 
                                 item.status === 'confirmed' ? '확정' : 
                                 item.status === 'cancelled' ? '취소' : '만료'}
                            </Text>
                        </View>
                        <Ionicons 
                            name={isExpanded ? "chevron-up" : "chevron-down"} 
                            size={20} 
                            color={currentColors.textSecondary} 
                        />
                    </View>
                </TouchableOpacity>
                
                {isExpanded && (
                    <View style={{marginTop: 12, paddingTop: 12, borderTopWidth: 1, borderTopColor: currentColors.lightGray}}>
                        {type === 'sent' && (
                            <View style={{marginBottom: 8}}>
                                <Text style={{fontSize: 14, fontWeight: 'bold', color: currentColors.text, marginBottom: 8}}>제안한 그룹:</Text>
                                {(groupMembers && groupMembers.length > 0) ? (
                                    groupMembers.map((member, index) => (
                                        <View key={index} style={{marginBottom: 8}}>
                                            <Text style={{fontSize: 14, color: currentColors.text, fontWeight: '600'}}>{member.nickname || member.employee_id}</Text>
                                            <Text style={{fontSize: 12, color: currentColors.textSecondary, marginLeft: 16}}>
                                                🍽️ {member.lunch_preference || '-'}
                                                {member.dining_history && `  |  ${member.dining_history}`}
                                            </Text>
                                            {member.main_dish_genre && (
                                                <Text style={{fontSize: 12, color: currentColors.textSecondary, marginLeft: 16}}>🍜 {member.main_dish_genre}</Text>
                                            )}
                                        </View>
                                    ))
                                ) : (
                                    <View style={{marginBottom: 8}}>
                                        <Text style={{fontSize: 12, color: currentColors.textSecondary}}>
                                            {item.recipient_ids ? '참여자 정보를 불러오는 중...' : '참여자 정보 없음'}
                                        </Text>
                                        {item.recipient_ids && (
                                            <Text style={{fontSize: 10, color: currentColors.textSecondary, marginTop: 4}}>
                                                ID: {item.recipient_ids}
                                            </Text>
                                        )}
                                    </View>
                                )}
                            </View>
                        )}
                        
                        {item.accepted_nicknames && item.accepted_nicknames.length > 0 && (
                            <Text style={{fontSize: 14, color: currentColors.success, fontWeight: '600', marginBottom: 8}}>
                                수락한 사람: {item.accepted_nicknames.join(', ')}
                            </Text>
                        )}
                
                        {isReceived && isPending && (
                            <View style={{flexDirection: 'row', justifyContent: 'space-between', marginTop: 8}}>
                                <TouchableOpacity 
                                    style={{
                                        backgroundColor: currentColors.primary,
                                        borderRadius: 16,
                                        paddingVertical: 12,
                                        paddingHorizontal: 20,
                                        flex: 1,
                                        marginRight: 8,
                                        alignItems: 'center',
                                        elevation: 3,
                                        shadowColor: currentColors.primary,
                                        shadowOffset: { width: 0, height: 4 },
                                        shadowOpacity: 0.3,
                                        shadowRadius: 8
                                    }}
                                    onPress={() => handleAcceptProposal(item.id)}
                                >
                                    <Text style={{color: '#FFFFFF', fontWeight: 'bold', fontSize: 14}}>
                                        수락
                                    </Text>
                                </TouchableOpacity>
                                <TouchableOpacity 
                                    style={{
                                        backgroundColor: currentColors.error,
                                        borderRadius: 16,
                                        paddingVertical: 12,
                                        paddingHorizontal: 20,
                                        flex: 1,
                                        marginLeft: 8,
                                        alignItems: 'center',
                                        elevation: 3,
                                        shadowColor: currentColors.error,
                                        shadowOffset: { width: 0, height: 4 },
                                        shadowOpacity: 0.3,
                                        shadowRadius: 8
                                    }}
                                       onPress={() => {
        Alert.alert('거절', '이 제안을 거절하시겠습니까?', [
            { text: '취소', style: 'cancel' },
            { text: '확인', style: 'destructive', onPress: () => handleRejectProposal(item.id) }
        ]);
    }}
>
    <Text style={{color: '#FFFFFF', fontWeight: 'bold', fontSize: 14}}>
        거절
    </Text>
</TouchableOpacity>
                             </View>
                        )}
                        
                        {type === 'sent' && isPending && (
                            <View style={{marginTop: 8}}>
                                <TouchableOpacity 
                                    style={{
                                        backgroundColor: '#EF4444',
                                        borderRadius: 16,
                                        paddingVertical: 12,
                                        paddingHorizontal: 24,
                                        alignItems: 'center',
                                        width: '100%',
                                        elevation: 3,
                                        shadowColor: '#EF4444',
                                        shadowOffset: { width: 0, height: 4 },
                                        shadowOpacity: 0.3,
                                        shadowRadius: 8
                                    }}
                                    onPress={async () => {
                                        Alert.alert('제안 취소', '이 제안을 취소하시겠습니까?', [
                                            { text: '취소', style: 'cancel' },
                                            { 
                                                text: '확인', 
                                                style: 'destructive', 
                                                onPress: async () => {
                                                    try {
                                                        console.log('DEBUG: 제안 취소 시도 - proposalId:', item.id);
                                                        const response = await fetch(`${RENDER_SERVER_URL}/proposals/${item.id}/cancel`, {
                                                            method: 'POST',
                                                            headers: { 'Content-Type': 'application/json' },
                                                            body: JSON.stringify({ employee_id: user.employee_id })
                                                        });
                                                        
                                                        console.log('DEBUG: 제안 취소 응답 - status:', response.status);
                                                        const responseData = await response.text();
                                                        console.log('DEBUG: 제안 취소 응답 - data:', responseData);
                                                        
                                                        if (response.ok) {
                                                            Alert.alert('알림', '제안이 취소되었습니다.');
                                                            fetchMyProposals();
                                                        } else {
                                                            Alert.alert('오류', `제안 취소에 실패했습니다. (${response.status})`);
                                                        }
                                                    } catch (error) {
                                                        console.error('제안 취소 오류:', error);
                                                        Alert.alert('오류', '네트워크에 문제가 발생했습니다.');
                                                    }
                                                }
                                            }
                                        ]);
                                    }}
                                >
                                    <Text style={{color: '#FFFFFF', fontWeight: 'bold', fontSize: 14}}>
                                        제안 취소
                                    </Text>
                                </TouchableOpacity>
                            </View>
                        )}
                    </View>
                )}
            </View>
        );
    };

    if (loading) {
        return (
            <SafeAreaView style={styles.safeArea}>
                <View style={{flex: 1, justifyContent: 'center', alignItems: 'center'}}>
                    <ActivityIndicator size="large" color={currentColors.primary} />
                    <Text style={{fontSize: 16, color: currentColors.textSecondary, marginTop: 16}}>제안 목록을 불러오는 중...</Text>
                </View>
            </SafeAreaView>
        );
    }

    return (
        <SafeAreaView style={styles.safeArea}>
            <ScrollView style={{flex: 1, backgroundColor: currentColors.background}}>

                {/* 매칭 성공한 점심 모임 */}
                {confirmedGroups.length > 0 && (
                    <View style={{marginBottom: 24}}>
                        <Text style={{fontSize: 20, fontWeight: 'bold', marginBottom: 12, color: currentColors.primary, paddingHorizontal: 16, marginTop: 16}}>
                            매칭 성공
                        </Text>
                        <FlatList
                            data={confirmedGroups}
                            renderItem={renderConfirmedGroupItem}
                            keyExtractor={item => `confirmed-${item.id}`}
                            horizontal
                            showsHorizontalScrollIndicator={false}
                            contentContainerStyle={{ paddingHorizontal: 16, paddingVertical: 5 }}
                        />
                    </View>
                )}
                
                <View style={{marginBottom: 24}}>
                    <Text style={{fontSize: 20, fontWeight: 'bold', marginBottom: 12, color: currentColors.primary, paddingHorizontal: 16, marginTop: 16}}>
                        보낸 제안
                    </Text>
                    {proposals.sent_proposals.length > 0 ? (
                        proposals.sent_proposals.map(item => (
                            <View key={item.id}>
                                {renderProposalItem({ item, type: 'sent' })}
                            </View>
                        ))
                    ) : (
                        <Text style={{fontSize: 16, color: currentColors.textSecondary, textAlign: 'center', marginTop: 50, paddingHorizontal: 16}}>보낸 제안이 없습니다.</Text>
                    )}
                </View>
                
                <View style={{marginBottom: 24}}>
                    <Text style={{fontSize: 20, fontWeight: 'bold', marginBottom: 12, color: currentColors.primary, paddingHorizontal: 16, marginTop: 16}}>
                        받은 제안
                    </Text>
                    {proposals.received_proposals.length > 0 ? (
                        proposals.received_proposals.map(item => (
                            <View key={item.id}>
                                {renderProposalItem({ item, type: 'received' })}
                            </View>
                        ))
                    ) : (
                        <Text style={{fontSize: 16, color: currentColors.textSecondary, textAlign: 'center', marginTop: 50, paddingHorizontal: 16}}>받은 제안이 없습니다.</Text>
                    )}
                </View>
            </ScrollView>
        </SafeAreaView>
    );
}
// 식당 아이템 컴포넌트
function RestaurantItem({ restaurant, navigation, activeTab, currentColors, onAddVisit }) {
    const [restaurantData, setRestaurantData] = useState({
        reviews: [],
        averageRating: 0,
        reviewCount: 0,
        mostSelectedFoodTypes: [],
        topKeywords: [],
        latestImage: null
    });
    const [distance, setDistance] = useState(null);
    const [isFavorite, setIsFavorite] = useState(false);
    const [favoriteId, setFavoriteId] = useState(null);

    // 거리 계산 함수
    const calculateDistance = (lat1, lon1, lat2, lon2) => {
        const R = 6371; // 지구의 반지름 (km)
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                  Math.sin(dLon/2) * Math.sin(dLon/2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
        const distance = R * c;
        return distance;
    };

    // 즐겨찾기 상태 확인
    const checkFavoriteStatus = async () => {
        try {
            const currentUser = await AsyncStorage.getItem('currentUser');
            if (currentUser) {
                const user = JSON.parse(currentUser);
                const response = await fetch(`${RENDER_SERVER_URL}/restaurants/favorites/check`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_id: user.employee_id,
                        restaurant_id: restaurant.id
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    setIsFavorite(result.is_favorite);
                    setFavoriteId(result.favorite_id);
                }
            }
        } catch (error) {
            console.error('즐겨찾기 상태 확인 오류:', error);
        }
    };

    // 즐겨찾기 토글
    const toggleFavorite = async () => {
        try {
            const currentUser = await AsyncStorage.getItem('currentUser');
            if (!currentUser) {
                Alert.alert('로그인 필요', '즐겨찾기를 사용하려면 로그인이 필요합니다.');
                return;
            }

            const user = JSON.parse(currentUser);
            
            if (isFavorite) {
                // 즐겨찾기 제거
                if (favoriteId) {
                    const response = await fetch(`${RENDER_SERVER_URL}/restaurants/favorites/${favoriteId}`, {
                        method: 'DELETE'
                    });
                    
                    if (response.ok) {
                        setIsFavorite(false);
                        setFavoriteId(null);
                        console.log('즐겨찾기 제거됨');
                    }
                }
            } else {
                // 즐겨찾기 추가
                const response = await fetch(`${RENDER_SERVER_URL}/restaurants/favorites`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        user_id: user.employee_id,
                        restaurant_id: restaurant.id
                    })
                });
                
                if (response.ok) {
                    const result = await response.json();
                    setIsFavorite(true);
                    setFavoriteId(result.favorite.id);
                    console.log('즐겨찾기 추가됨');
                }
            }
        } catch (error) {
            console.error('즐겨찾기 토글 오류:', error);
            Alert.alert('오류', '즐겨찾기 처리 중 오류가 발생했습니다.');
        }
    };

    useEffect(() => {
        const fetchRestaurantData = async () => {
            try {
                console.log('식당 ID:', restaurant.id);
                // 리뷰 데이터 가져오기
                const storedReviews = await AsyncStorage.getItem(`reviews_${restaurant.id}`);
                console.log('저장된 리뷰:', storedReviews);
                
                if (storedReviews) {
                    const parsedReviews = JSON.parse(storedReviews);
                    console.log('파싱된 리뷰:', parsedReviews);
                    
                    // 평균 평점 계산
                    const averageRating = parsedReviews.length > 0 
                        ? (parsedReviews.reduce((sum, review) => sum + review.rating, 0) / parsedReviews.length).toFixed(1)
                        : 0;
                    
                    console.log('평균 평점:', averageRating);
                    
                    // 가장 많이 선택된 음식 종류 계산
                    const foodTypeCount = {};
                    parsedReviews.forEach(review => {
                        if (review.food_types && review.food_types.length > 0) {
                            review.food_types.forEach(foodType => {
                                foodTypeCount[foodType] = (foodTypeCount[foodType] || 0) + 1;
                            });
                        }
                    });
                    
                    let maxCount = 0;
                    const mostSelectedTypes = [];
                    Object.keys(foodTypeCount).forEach(foodType => {
                        if (foodTypeCount[foodType] > maxCount) {
                            maxCount = foodTypeCount[foodType];
                        }
                    });
                    Object.keys(foodTypeCount).forEach(foodType => {
                        if (foodTypeCount[foodType] === maxCount && maxCount > 0) {
                            mostSelectedTypes.push(foodType);
                        }
                    });
                    
                    console.log('가장 많이 선택된 음식 종류:', mostSelectedTypes);
                    
                    // 키워드 계산
                    const keywordCount = {};
                    parsedReviews.forEach(review => {
                        if (review.atmosphere && review.atmosphere.length > 0) {
                            review.atmosphere.forEach(keyword => {
                                keywordCount[keyword] = (keywordCount[keyword] || 0) + 1;
                            });
                        }
                        if (review.features && review.features.length > 0) {
                            review.features.forEach(keyword => {
                                keywordCount[keyword] = (keywordCount[keyword] || 0) + 1;
                            });
                        }
                    });
                    
                    const topKeywords = Object.keys(keywordCount)
                        .sort((a, b) => keywordCount[b] - keywordCount[a])
                        .slice(0, 3);
                    
                    console.log('상위 키워드:', topKeywords);
                    
                    // 최신 이미지 찾기
                    let latestImage = null;
                    if (parsedReviews.length > 0) {
                        const sortedReviews = [...parsedReviews].sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
                        for (let review of sortedReviews) {
                            if (review.images && review.images.length > 0) {
                                latestImage = review.images[0];
                                break;
                            }
                        }
                    }
                    
                    console.log('최신 이미지:', latestImage);
                    
                    setRestaurantData({
                        reviews: parsedReviews,
                        averageRating: parseFloat(averageRating),
                        reviewCount: parsedReviews.length,
                        mostSelectedFoodTypes: mostSelectedTypes,
                        topKeywords: topKeywords,
                        latestImage: latestImage
                    });
                } else {
                    console.log('리뷰 데이터가 없습니다.');
                    // 리뷰가 없을 때는 기본값으로 설정
                    setRestaurantData({
                        reviews: [],
                        averageRating: 0,
                        reviewCount: 0,
                        mostSelectedFoodTypes: [],
                        topKeywords: [],
                        latestImage: null
                    });
                }

                // 거리 계산
                if (restaurant.latitude && restaurant.longitude) {
                    // 현재 위치는 서울시청으로 가정 (실제로는 GPS에서 가져와야 함)
                    const currentLat = 37.5665;
                    const currentLon = 126.9780;
                    const calculatedDistance = calculateDistance(
                        currentLat, currentLon,
                        restaurant.latitude, restaurant.longitude
                    );
                    setDistance(calculatedDistance);
                }
            } catch (error) {
                console.error('식당 데이터 로드 오류:', error);
            }
        };

        fetchRestaurantData();
        checkFavoriteStatus(); // 즐겨찾기 상태 확인
    }, [restaurant.id]);

    return (
        <TouchableOpacity 
            style={{
                backgroundColor: currentColors.surface,
                borderRadius: 16,
                marginHorizontal: 16,
                marginBottom: 12,
                padding: 16,
                elevation: 2,
                shadowColor: currentColors.primary,
                shadowOffset: { width: 0, height: 2 },
                shadowOpacity: 0.1,
                shadowRadius: 4,
                borderWidth: 1,
                borderColor: 'rgba(99, 102, 241, 0.2)'
            }}
            onPress={() => safeNavigateToTab(navigation, '맛집', 'RestaurantDetail', { restaurant })}
        >
            <View style={{ flexDirection: 'row' }}>
                {/* 최신 이미지 */}
                <View style={{ marginRight: 12 }}>
                    {restaurantData.latestImage ? (
                        <Image 
                            source={{ uri: restaurantData.latestImage }} 
                            style={{ width: 80, height: 80, borderRadius: 8 }}
                        />
                    ) : (
                        <View style={{ 
                            width: 80, 
                            height: 80, 
                            borderRadius: 8, 
                            backgroundColor: '#f8f9fa',
                            justifyContent: 'center',
                            alignItems: 'center'
                        }}>
                            <Ionicons name="image-outline" size={32} color="#adb5bd" />
                        </View>
                    )}
                </View>
                
                {/* 식당 정보 */}
                <View style={{ flex: 1 }}>
                    <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 8 }}>
                        <Text style={{ fontSize: 18, fontWeight: 'bold', color: currentColors.text, flex: 1 }}>
                            {restaurant.name}
                        </Text>
                        {/* 방문 기록 버튼 */}
                        <TouchableOpacity
                            onPress={(e) => {
                                e.stopPropagation(); // 상세보기 화면 이동 방지
                                if (onAddVisit) {
                                    onAddVisit(restaurant);
                                }
                            }}
                            style={{
                                marginRight: 8,
                                padding: 4
                            }}
                        >
                            <Ionicons 
                                name="calendar-outline" 
                                size={24} 
                                color={currentColors.primary} 
                            />
                        </TouchableOpacity>
                        
                        {/* 즐겨찾기 버튼 */}
                        <TouchableOpacity
                            onPress={(e) => {
                                e.stopPropagation(); // 상세보기 화면 이동 방지
                                toggleFavorite();
                            }}
                            style={{
                                marginRight: 8,
                                padding: 4
                            }}
                        >
                            <Ionicons 
                                name={isFavorite ? "heart" : "heart-outline"} 
                                size={24} 
                                color={isFavorite ? "#ff4757" : currentColors.textSecondary} 
                            />
                        </TouchableOpacity>
                        {restaurantData.mostSelectedFoodTypes.length > 0 && (
                            <View style={{
                                backgroundColor: currentColors.primary,
                                borderRadius: 16,
                                paddingHorizontal: 12,
                                paddingVertical: 6,
                                marginLeft: 8
                            }}>
                                <Text style={{ color: '#fff', fontWeight: 'bold', fontSize: 12 }}>
                                    {restaurantData.mostSelectedFoodTypes[0]}
                                </Text>
                            </View>
                        )}
                    </View>
                    
                    {/* 별점, 리뷰 수, 오찬 추천 하트 */}
                    <View style={{ flexDirection: 'row', justifyContent: 'space-between', marginBottom: 8 }}>
                        <Text style={{ fontSize: 14, color: currentColors.textSecondary }}>
                            ⭐ {restaurantData.reviewCount > 0 ? restaurantData.averageRating.toFixed(1) : '0.0'}
                        </Text>
                        <Text style={{ fontSize: 14, color: currentColors.textSecondary }}>
                            💬 {restaurantData.reviewCount}개
                        </Text>
                        {(restaurant.recommend_count && restaurant.recommend_count > 0) && (
                            <Text style={{ fontSize: 14, color: currentColors.textSecondary }}>
                                ❤️ {restaurant.recommend_count}개
                            </Text>
                        )}
                    </View>
                    

                    
                    {/* 키워드 */}
                    {restaurantData.topKeywords.length > 0 && (
                        <View style={{ flexDirection: 'row', flexWrap: 'wrap' }}>
                            {restaurantData.topKeywords.slice(0, 3).map((keyword, index) => (
                                <Text key={index} style={{ 
                                    color: currentColors.textSecondary, 
                                    fontSize: 12, 
                                    marginRight: 8,
                                    marginBottom: 4
                                }}>
                                    #{keyword}
                                </Text>
                            ))}
                        </View>
                    )}
                    
                    {/* 추천 태그 */}
                    {activeTab !== 'all' && (
                        <View style={{
                            backgroundColor: activeTab === 'personal' ? currentColors.primaryLight : currentColors.secondary + '20',
                            borderRadius: 12,
                            paddingVertical: 4,
                            paddingHorizontal: 8,
                            alignSelf: 'flex-start',
                            marginTop: 8
                        }}>
                            <Text style={{
                                color: activeTab === 'personal' ? currentColors.primary : currentColors.secondary,
                                fontWeight: 'bold',
                                fontSize: 12
                            }}>
                                {activeTab === 'personal' ? '개인 추천' : '친구 추천'}
                            </Text>
                        </View>
                    )}
                </View>
            </View>
        </TouchableOpacity>
    );
}

function RestaurantsScreen({ navigation }) {
    const { user } = useAuth();
    const { handleActionCompletion } = useMission();
    const [restaurants, setRestaurants] = useState([]);
    const [recommendations, setRecommendations] = useState({ personal: [], friend: [] });
    const [isLoading, setIsLoading] = useState(true);
    const [searchQuery, setSearchQuery] = useState('');
    const [activeTab, setActiveTab] = useState('all'); // 'all', 'personal', 'friend'
    const [sortBy, setSortBy] = useState('name');
    const [categoryFilter, setCategoryFilter] = useState(null);
    const [isCategoryModalVisible, setCategoryModalVisible] = useState(false);
    const [paginationInfo, setPaginationInfo] = useState({ total: 0, pages: 0, currentPage: 1 });
    const [showVisitModal, setShowVisitModal] = useState(false);
    const [selectedRestaurantForVisit, setSelectedRestaurantForVisit] = useState(null);
    const [currentUser, setCurrentUser] = useState(null);
    const CATEGORY_OPTIONS = ['한식', '중식', '일식', '양식', '분식', '카페', '아시안', '퓨전', '기타'];

    // 사용자 정보 초기화
    useEffect(() => {
        const initUser = async () => {
            try {
                await userManager.initialize();
                setCurrentUser(userManager.getCurrentUser());
            } catch (error) {
                console.error('사용자 정보 초기화 실패:', error);
            }
        };
        initUser();
    }, []);
    
    useFocusEffect(useCallback(() => {
        setIsLoading(true);
        let url = `${RENDER_SERVER_URL}/restaurants?query=${searchQuery}&sort_by=${sortBy}`;
        if (categoryFilter) url += `&category=${categoryFilter}`;
        fetch(url).then(res => res.json()).then(data => { 
            if(data && data.restaurants) {
                setRestaurants(data.restaurants);
                setPaginationInfo({
                    total: data.total || 0,
                    pages: data.pages || 0,
                    currentPage: data.current_page || 1
                });
                console.log(`식당 데이터 로드: ${data.restaurants.length}개, 전체: ${data.total}개, 페이지: ${data.pages}개`);
                
                // 검색 마스터 미션 완료 처리 (검색어가 있을 때만)
                if (searchQuery.trim()) {
                    handleActionCompletion('restaurant_search');
                }
            } else if(Array.isArray(data)) {
                setRestaurants(data);
                setPaginationInfo({ total: data.length, pages: 1, currentPage: 1 });
            }
        }).catch(err => console.error(err)).finally(() => setIsLoading(false));
        
        // 추천 식당도 함께 가져오기
        fetchRecommendations();
    }, [searchQuery, sortBy, categoryFilter]));

    const fetchRecommendations = async () => {
        try {
            // currentUser가 없으면 기본값 사용
            const userId = currentUser?.employee_id || 'default_user';
            const response = await fetch(`${RENDER_SERVER_URL}/restaurants/recommend?employee_id=${userId}`);
            if (response.ok) {
                const data = await response.json();
                setRecommendations({
                    personal: data.personal_recommendations || [],
                    friend: data.friend_recommendations || []
                });
            }
        } catch (error) {
            console.error('추천 식당 조회 실패:', error);
        }
    };

    // 방문 기록 추가
    const addRestaurantVisit = async (restaurantId, visitDate, visitTime, partySize) => {
        try {
            const userId = 'KOICA001'; // 임시 사용자 ID
            const response = await fetch(`${RENDER_SERVER_URL}/restaurants/visits`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    user_id: userId,
                    restaurant_id: restaurantId,
                    visit_date: visitDate,
                    visit_time: visitTime,
                    party_size: partySize
                })
            });

            if (response.ok) {
                const result = await response.json();
                Alert.alert('방문 기록 추가', '방문 기록이 성공적으로 추가되었습니다.');
                
                // 맛집 탐험 미션 완료 처리 (임시 비활성화)
                // handleActionCompletion('restaurant_visit');
                
                // 모달 닫기
                setShowVisitModal(false);
                setSelectedRestaurantForVisit(null);
                
                // 추천 식당 다시 로드 (방문 기록이 변경되었으므로)
                fetchRecommendations();
            } else {
                const errorData = await response.json();
                Alert.alert('오류', errorData.error || '방문 기록 추가에 실패했습니다.');
            }
        } catch (error) {
            console.error('방문 기록 추가 오류:', error);
            Alert.alert('오류', '네트워크 오류가 발생했습니다.');
        }
    };

    return (
        <SafeAreaView style={styles.safeArea}>
            {/* 검색 및 필터 */}
            <View style={{paddingHorizontal: 16, paddingVertical: 12, backgroundColor: currentColors.background}}>
                <TextInput 
                    style={{
                        backgroundColor: currentColors.surface,
                        borderRadius: 16,
                        padding: 14,
                        fontSize: 16,
                        marginBottom: 12,
                        borderWidth: 1,
                        borderColor: currentColors.lightGray
                    }} 
                    placeholder="맛집 이름 검색..." 
                    placeholderTextColor={currentColors.gray} 
                    value={searchQuery} 
                    onChangeText={setSearchQuery} 
                />
                <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                    <TouchableOpacity
                        style={{
                            backgroundColor: sortBy === 'name' ? currentColors.primary : currentColors.surface,
                            borderRadius: 20,
                            paddingVertical: 8,
                            paddingHorizontal: 16,
                            marginRight: 8,
                            elevation: sortBy === 'name' ? 2 : 1,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: sortBy === 'name' ? 0.2 : 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: sortBy === 'name' ? currentColors.primary : currentColors.lightGray
                        }}
                        onPress={() => setSortBy('name')}
                    >
                        <Text style={{
                            color: sortBy === 'name' ? '#FFFFFF' : currentColors.text,
                            fontWeight: sortBy === 'name' ? 'bold' : '600',
                            fontSize: 14
                        }}>
                            이름순
                        </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                        style={{
                            backgroundColor: sortBy === 'rating_desc' ? currentColors.primary : currentColors.surface,
                            borderRadius: 20,
                            paddingVertical: 8,
                            paddingHorizontal: 16,
                            marginRight: 8,
                            elevation: sortBy === 'rating_desc' ? 2 : 1,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: sortBy === 'rating_desc' ? 0.2 : 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: sortBy === 'rating_desc' ? currentColors.primary : currentColors.lightGray
                        }}
                        onPress={() => setSortBy('rating_desc')}
                    >
                        <Text style={{
                            color: sortBy === 'rating_desc' ? '#FFFFFF' : currentColors.text,
                            fontWeight: sortBy === 'rating_desc' ? 'bold' : '600',
                            fontSize: 14
                        }}>
                            ⭐별점순
                        </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                        style={{
                            backgroundColor: sortBy === 'reviews_desc' ? currentColors.primary : currentColors.surface,
                            borderRadius: 20,
                            paddingVertical: 8,
                            paddingHorizontal: 16,
                            marginRight: 8,
                            elevation: sortBy === 'reviews_desc' ? 2 : 1,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: sortBy === 'reviews_desc' ? 0.2 : 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: sortBy === 'reviews_desc' ? currentColors.primary : currentColors.lightGray
                        }}
                        onPress={() => setSortBy('reviews_desc')}
                    >
                        <Text style={{
                            color: sortBy === 'reviews_desc' ? '#FFFFFF' : currentColors.text,
                            fontWeight: sortBy === 'reviews_desc' ? 'bold' : '600',
                            fontSize: 14
                        }}>
                            💬리뷰순
                        </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                        style={{
                            backgroundColor: sortBy === 'recommend_desc' ? currentColors.primary : currentColors.surface,
                            borderRadius: 20,
                            paddingVertical: 8,
                            paddingHorizontal: 16,
                            marginRight: 8,
                            elevation: sortBy === 'recommend_desc' ? 2 : 1,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: sortBy === 'recommend_desc' ? 0.2 : 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: sortBy === 'recommend_desc' ? currentColors.primary : currentColors.lightGray
                        }}
                        onPress={() => setSortBy('recommend_desc')}
                    >
                        <Text style={{
                            color: sortBy === 'recommend_desc' ? '#FFFFFF' : currentColors.text,
                            fontWeight: sortBy === 'recommend_desc' ? 'bold' : '600',
                            fontSize: 14
                        }}>
                            ❤️오찬추천순
                        </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                        style={{
                            backgroundColor: categoryFilter ? currentColors.primary : currentColors.surface,
                            borderRadius: 20,
                            paddingVertical: 8,
                            paddingHorizontal: 16,
                            marginRight: 8,
                            elevation: categoryFilter ? 2 : 1,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: categoryFilter ? 0.2 : 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: categoryFilter ? currentColors.primary : currentColors.lightGray,
                            flexDirection: 'row',
                            alignItems: 'center'
                        }}
                        onPress={() => setCategoryModalVisible(true)}
                    >
                        <Ionicons name="filter" size={16} color={categoryFilter ? '#FFFFFF' : currentColors.gray} />
                        <Text style={{
                            color: categoryFilter ? '#FFFFFF' : currentColors.text,
                            fontWeight: categoryFilter ? 'bold' : '600',
                            fontSize: 14,
                            marginLeft: 4
                        }}>
                            {categoryFilter || '카테고리'}
                        </Text>
                        {categoryFilter && (
                            <TouchableOpacity onPress={() => setCategoryFilter(null)} style={{marginLeft: 4}}>
                                <Ionicons name="close-circle" size={16} color="#FFFFFF" />
                            </TouchableOpacity>
                        )}
                    </TouchableOpacity>
                </ScrollView>
            </View>

            <SelectionModal visible={isCategoryModalVisible} title="카테고리 필터" options={CATEGORY_OPTIONS} selected={categoryFilter} onSelect={setCategoryFilter} onClose={() => setCategoryModalVisible(false)} styles={styles} colors={currentColors} />
            
            {/* 탭 네비게이션 */}
            <View style={{paddingHorizontal: 16, paddingVertical: 12, backgroundColor: currentColors.background}}>
                <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                    <TouchableOpacity
                        style={{
                            backgroundColor: activeTab === 'all' ? currentColors.primary : currentColors.surface,
                            borderRadius: 20,
                            paddingVertical: 8,
                            paddingHorizontal: 16,
                            marginRight: 8,
                            elevation: activeTab === 'all' ? 2 : 1,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: activeTab === 'all' ? 0.2 : 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: activeTab === 'all' ? currentColors.primary : currentColors.lightGray
                        }}
                        onPress={() => setActiveTab('all')}
                    >
                        <Text style={{
                            color: activeTab === 'all' ? '#FFFFFF' : currentColors.text,
                            fontWeight: activeTab === 'all' ? 'bold' : '600',
                            fontSize: 14
                        }}>
                            전체
                        </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                        style={{
                            backgroundColor: activeTab === 'personal' ? currentColors.primary : currentColors.surface,
                            borderRadius: 20,
                            paddingVertical: 8,
                            paddingHorizontal: 16,
                            marginRight: 8,
                            elevation: activeTab === 'personal' ? 2 : 1,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: activeTab === 'personal' ? 0.2 : 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: activeTab === 'personal' ? currentColors.primary : currentColors.lightGray
                        }}
                        onPress={() => setActiveTab('personal')}
                    >
                        <Text style={{
                            color: activeTab === 'personal' ? '#FFFFFF' : currentColors.text,
                            fontWeight: activeTab === 'personal' ? 'bold' : '600',
                            fontSize: 14
                        }}>
                            개인 추천
                        </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                        style={{
                            backgroundColor: activeTab === 'friend' ? currentColors.primary : currentColors.surface,
                            borderRadius: 20,
                            paddingVertical: 8,
                            paddingHorizontal: 16,
                            marginRight: 8,
                            elevation: activeTab === 'friend' ? 2 : 1,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: activeTab === 'friend' ? 0.2 : 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: activeTab === 'friend' ? currentColors.primary : currentColors.lightGray
                        }}
                        onPress={() => setActiveTab('friend')}
                    >
                        <Text style={{
                            color: activeTab === 'friend' ? '#FFFFFF' : currentColors.text,
                            fontWeight: activeTab === 'friend' ? 'bold' : '600',
                            fontSize: 14
                        }}>
                            친구 추천
                        </Text>
                    </TouchableOpacity>
                </ScrollView>
            </View>
            
            {isLoading ? (
                <ActivityIndicator size="large" style={{marginTop: 20}} color={currentColors.primary} />
            ) : (
                <FlatList 
                    data={
                        activeTab === 'all' ? restaurants :
                        activeTab === 'personal' ? recommendations.personal :
                        activeTab === 'friend' ? recommendations.friend : []
                    }
                    keyExtractor={item => item.id.toString()} 
                    renderItem={({ item }) => (
                        <RestaurantItem 
                            restaurant={item} 
                            navigation={navigation} 
                            activeTab={activeTab}
                            currentColors={currentColors}
                            onAddVisit={(restaurant) => {
                                setSelectedRestaurantForVisit(restaurant);
                                setShowVisitModal(true);
                            }}
                        />
                    )} 
                    ListEmptyComponent={
                        <Text style={{fontSize: 16, color: currentColors.textSecondary, textAlign: 'center', marginTop: 50, paddingHorizontal: 16}}>
                            {activeTab === 'all' ? '검색 결과가 없습니다.' :
                             activeTab === 'personal' ? '개인 추천 식당이 없습니다.' :
                             '친구 추천 식당이 없습니다.'}
                        </Text>
                    } 
                    ListFooterComponent={
                        activeTab === 'all' && paginationInfo.total > 0 ? (
                            <View style={{
                                paddingHorizontal: 16,
                                paddingVertical: 20,
                                alignItems: 'center',
                                borderTopWidth: 1,
                                borderTopColor: currentColors.border
                            }}>
                                <Text style={{
                                    fontSize: 14,
                                    color: currentColors.textSecondary,
                                    marginBottom: 8
                                }}>
                                    전체 {paginationInfo.total}개 중 {restaurants.length}개 표시
                                </Text>
                                {paginationInfo.pages > 1 && (
                                    <Text style={{
                                        fontSize: 12,
                                        color: currentColors.gray
                                    }}>
                                        {paginationInfo.currentPage} / {paginationInfo.pages} 페이지
                                    </Text>
                                )}
                            </View>
                        ) : null
                    }
                    contentContainerStyle={{paddingTop: 16, paddingBottom: 200}}  
                />
            )}
            
            {/* 방문 기록 모달 */}
            {showVisitModal && selectedRestaurantForVisit && (
                <VisitRecordModal
                    visible={showVisitModal}
                    restaurant={selectedRestaurantForVisit}
                    onClose={() => {
                        setShowVisitModal(false);
                        setSelectedRestaurantForVisit(null);
                    }}
                    onSubmit={(restaurantId, visitDate, visitTime, partySize) => {
                        // 방문 기록 추가 API 호출
                        addRestaurantVisit(restaurantId, visitDate, visitTime, partySize);
                    }}
                />
            )}
            
            {/* 플로팅 추가 버튼 */}
            <TouchableOpacity
                style={{
                    position: 'absolute',
                    right: 24,
                    bottom: 32,
                    width: 56,
                    height: 56,
                    borderRadius: 28,
                    backgroundColor: currentColors.primary,
                    justifyContent: 'center',
                    alignItems: 'center',
                    zIndex: 10,
                    elevation: 8,
                    shadowColor: currentColors.primary,
                    shadowOffset: { width: 0, height: 4 },
                    shadowOpacity: 0.3,
                    shadowRadius: 8
                }}
                activeOpacity={0.85}
                onPress={() => navigation.navigate('AddRestaurant')}
            >
                <Ionicons name="add" size={32} color="#fff" />
            </TouchableOpacity>
        </SafeAreaView>
    );
}

function AddRestaurantScreen({ navigation }) {
    const [name, setName] = useState('');
    const [category, setCategory] = useState('');
    const [address, setAddress] = useState('');
    const [isCategoryModalVisible, setCategoryModalVisible] = useState(false);
    const CATEGORY_OPTIONS = ['한식', '중식', '일식', '양식', '분식', '카페', '아시안', '퓨전', '기타'];

    const handleSubmit = async () => {
        if (!name.trim() || !category || !address.trim()) {
            Alert.alert('입력 오류', '맛집 이름, 카테고리, 주소를 모두 입력해주세요.');
            return;
        }

        try {
            const response = await fetch(`${RENDER_SERVER_URL}/restaurants`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    name: name.trim(),
                    category: category,
                    address: address.trim()
                })
            });
            const data = await response.json();
            if (response.ok) {
                Alert.alert('성공', '새로운 맛집이 추가되었습니다.');
                navigation.goBack();
            } else {
                Alert.alert('오류', data.message || '맛집 추가에 실패했습니다.');
            }
        } catch (error) {
            Alert.alert('오류', '네트워크 요청 중 문제가 발생했습니다.');
        }
    };

    return (
        <SafeAreaView style={styles.safeArea}>
            <ScrollView contentContainerStyle={styles.formContainer}>
                <Text style={styles.inputLabel}>맛집 이름 *</Text>
                <TextInput 
                    style={styles.input} 
                    placeholder="예: 판교역 맛집" 
                    value={name} 
                    onChangeText={setName}
                    returnKeyType="done"
                    onSubmitEditing={() => {
                        Keyboard.dismiss();
                    }}
                    blurOnSubmit={true}
                />
                
                <Text style={styles.inputLabel}>카테고리 *</Text>
                <TouchableOpacity style={styles.input} onPress={() => setCategoryModalVisible(true)}>
                    <Text style={category ? {color: currentColors.black} : {color: currentColors.gray}}>
                        {category || '카테고리를 선택하세요'}
                    </Text>
                </TouchableOpacity>
                
                <Text style={styles.inputLabel}>주소 *</Text>
                <TextInput 
                    style={styles.input} 
                    placeholder="예: 경기도 성남시 분당구 판교역로 146" 
                    value={address} 
                    onChangeText={setAddress}
                    returnKeyType="done"
                    onSubmitEditing={() => {
                        Keyboard.dismiss();
                    }}
                    blurOnSubmit={true}
                />
                
                <TouchableOpacity style={styles.submitButton} onPress={handleSubmit}>
                    <Text style={styles.submitButtonText}>맛집 추가하기</Text>
                </TouchableOpacity>
                
                <TouchableOpacity style={[styles.submitButton, { backgroundColor: currentColors.gray, marginTop: 10 }]} onPress={() => navigation.navigate('맛집')}>
                    <Text style={styles.submitButtonText}>취소하기</Text>
                </TouchableOpacity>
            </ScrollView>
            
            <SelectionModal 
                visible={isCategoryModalVisible} 
                title="카테고리 선택" 
                options={CATEGORY_OPTIONS} 
                selected={category} 
                onSelect={setCategory} 
                onClose={() => setCategoryModalVisible(false)} 
                styles={styles} colors={currentColors} 
            />
        </SafeAreaView>
    );
}
// --- 파티 탭 ---
function PartyListScreen({ navigation }) {
    const [myParties, setMyParties] = useState([]);
    const [allParties, setAllParties] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    
    // MissionContext 사용
    const { handleActionCompletion } = useMission();
    
    // 🚨 중요: 전역 변수 새 파티 데이터 즉시 감지 (useFocusEffect와 별도로)
    useEffect(() => {
        if (global.newPartyData) {
                            // console.log('🔍 [일반파티] useEffect에서 새 파티 데이터 감지:', global.newPartyData);
            
            // 새 파티를 내 파티 목록과 전체 파티 목록에 추가
            const newParty = {
                id: global.newPartyData.id || Date.now(), // 서버에서 반환된 실제 ID 사용
                title: global.newPartyData.title,
                party_date: global.newPartyData.date,
                party_time: global.newPartyData.time,
                restaurant_name: global.newPartyData.restaurant,
                current_members: 1, // 생성자가 첫 번째 멤버
                max_members: global.newPartyData.maxMembers,
                location: global.newPartyData.location,
                description: global.newPartyData.description,
                members: global.newPartyData.attendees || [], // 참여자 목록 추가
                host_employee_id: global.newPartyData.host_employee_id || global.myEmployeeId || '1' // 호스트 ID 추가
            };
            

            
            setMyParties(prev => {

                // 🚨 중요: 중복 ID 제거 후 새 파티 추가
                const filtered = (prev || []).filter(party => party.id !== newParty.id);
                const updated = [newParty, ...filtered];

                
                // 🚨 중요: AsyncStorage에 영구 저장
                AsyncStorage.setItem('@my_parties', JSON.stringify(updated));
                // myParties AsyncStorage 저장 완료
                
                return updated;
            });
            
            setAllParties(prev => {

                // 🚨 중요: 중복 ID 제거 후 새 파티 추가
                const filtered = (prev || []).filter(party => party.id !== newParty.id);
                const updated = [newParty, ...filtered];

                
                // 🚨 중요: AsyncStorage에 영구 저장
                AsyncStorage.setItem('@all_parties', JSON.stringify(updated));
                // allParties AsyncStorage 저장 완료
                
                return updated;
            });
            
            // 전역 변수 초기화
            global.newPartyData = undefined;
            

        }
    }, [global.newPartyData]);

    useFocusEffect(useCallback(() => {

        
        setIsLoading(true);
        
        // 🚨 중요: 새 파티 생성 감지 및 추가
        if (global.newPartyData) {

            
            // 새 파티를 내 파티 목록과 전체 파티 목록에 추가
            const newParty = {
                id: global.newPartyData.id || Date.now(), // 서버에서 반환된 실제 ID 사용
                title: global.newPartyData.title,
                party_date: global.newPartyData.date,
                party_time: global.newPartyData.time,
                restaurant_name: global.newPartyData.restaurant,
                current_members: 1, // 생성자가 첫 번째 멤버
                max_members: global.newPartyData.maxMembers,
                location: global.newPartyData.location,
                description: global.newPartyData.description,
                members: global.newPartyData.attendees || [], // 참여자 목록 추가
                host_employee_id: global.newPartyData.host_employee_id || global.myEmployeeId || '1' // 호스트 ID 추가
            };
            

            
            setMyParties(prev => {

                // 🚨 중요: 중복 ID 제거 후 새 파티 추가
                const filtered = prev.filter(party => party.id !== newParty.id);
                const updated = [newParty, ...filtered];

                return updated;
            });
            
            setAllParties(prev => {

                // 🚨 중요: 중복 ID 제거 후 새 파티 추가
                const filtered = prev.filter(party => party.id !== newParty.id);
                const updated = [newParty, ...filtered];

                return updated;
            });
            
            // 전역 변수 초기화
            global.newPartyData = undefined;
            

            setIsLoading(false);
            return;
        }
        
                        // console.log('🔍 [일반파티] 새 파티 데이터 없음, AsyncStorage에서 복원 시도');
        
        // 🚨 중요: AsyncStorage에서 파티 목록 복원
        Promise.all([
            AsyncStorage.getItem('@my_parties').then(data => data ? JSON.parse(data) : []),
            AsyncStorage.getItem('@all_parties').then(data => data ? JSON.parse(data) : [])
        ]).then(([myPartiesData, allPartiesData]) => {
                            // console.log('🔍 [일반파티] AsyncStorage에서 복원된 myParties:', myPartiesData);
                // console.log('🔍 [일반파티] AsyncStorage에서 복원된 allParties:', allPartiesData);
            
            // 🚨 중요: 안전한 상태 설정
            setMyParties(Array.isArray(myPartiesData) ? myPartiesData : []);
            setAllParties(Array.isArray(allPartiesData) ? allPartiesData : []);
            
            if(Array.isArray(myPartiesData) && myPartiesData.length > 0) {
                // console.log('🔍 [일반파티] AsyncStorage에서 myParties 복원 완료');
            }
            if(Array.isArray(allPartiesData) && allPartiesData.length > 0) {
                // console.log('🔍 [일반파티] AsyncStorage에서 allParties 복원 완료');
            }
            
            // 🚨 중요: AsyncStorage에 데이터가 있으면 API 호출 건너뛰기
            if((myPartiesData && myPartiesData.length > 0) || (allPartiesData && allPartiesData.length > 0)) {
                // console.log('🔍 [일반파티] AsyncStorage 데이터로 복원 완료, API 호출 건너뛰기');
                setIsLoading(false);
                return;
            }
            
                            // console.log('🔍 [일반파티] AsyncStorage에 데이터 없음, API 호출 시작');
            
            // 기존 API 호출
        Promise.all([
            fetch(`${RENDER_SERVER_URL}/my_regular_parties/${global.myEmployeeId || '1'}`).then(res => res.json()),
            fetch(`${RENDER_SERVER_URL}/parties`).then(res => res.json())
        ]).then(([myPartiesData, allPartiesData]) => {
                // 🚨 중요: 안전한 배열 설정
                setMyParties(Array.isArray(myPartiesData) ? myPartiesData : []);
                setAllParties(Array.isArray(allPartiesData) ? allPartiesData : []);
        }).catch(console.error).finally(() => setIsLoading(false));
        }).catch(error => {
            console.error('🔍 [일반파티] AsyncStorage 복원 실패:', error);
            
            // API 호출로 폴백
            Promise.all([
                fetch(`${RENDER_SERVER_URL}/my_regular_parties/${global.myEmployeeId || '1'}`).then(res => res.json()),
                fetch(`${RENDER_SERVER_URL}/parties`).then(res => res.json())
            ]).then(([myPartiesData, allPartiesData]) => {
                // 🚨 중요: 안전한 배열 설정
                setMyParties(Array.isArray(myPartiesData) ? myPartiesData : []);
                setAllParties(Array.isArray(allPartiesData) ? allPartiesData : []);
            }).catch(console.error).finally(() => setIsLoading(false));
        });
    }, [global.newPartyData])); // 🚨 중요: global.newPartyData 변경 감지

    const renderPartyItem = ({ item }) => {
        // 🚨 중요: item이 유효한지 확인
        if (!item || typeof item !== 'object') {
                            // console.log('🔍 [일반파티] renderPartyItem: 유효하지 않은 item:', item);
            return null;
        }
        
        return (
        <TouchableOpacity style={{
            backgroundColor: currentColors.surface,
            borderRadius: 20,
            padding: 20,
            marginHorizontal: 16,
            marginBottom: 16,
            elevation: 3,
            shadowColor: currentColors.primary,
            shadowOffset: { width: 0, height: 4 },
            shadowOpacity: 0.1,
            shadowRadius: 8,
            borderWidth: 1,
            borderColor: 'rgba(59, 130, 246, 0.1)'
            }} onPress={() => navigation.navigate('PartyDetail', { partyId: item.id, partyData: item })}>
                <Text style={{fontSize: 18, fontWeight: 'bold', color: currentColors.text, marginBottom: 8}}>{item.title || '제목 없음'}</Text>
                <Text style={{fontSize: 14, color: currentColors.textSecondary, marginBottom: 4}}>🗓️ {item.party_date || '날짜 없음'} {item.party_time || '시간 없음'}</Text>
                <Text style={{fontSize: 14, color: currentColors.textSecondary}}>👥 {item.current_members || 0} / {item.max_members || 0}명 @ {item.restaurant_name || '식당 없음'}</Text>
        </TouchableOpacity>
    );
    };

    const renderMyPartyItem = ({ item }) => {
        // 🚨 중요: item이 유효한지 확인
        if (!item || typeof item !== 'object') {
                            // console.log('🔍 [일반파티] renderMyPartyItem: 유효하지 않은 item:', item);
            return null;
        }
        
        return (
        <TouchableOpacity style={{
            backgroundColor: currentColors.surface,
            borderRadius: 20,
            padding: 20,
            marginHorizontal: 6,
            width: SCREEN_WIDTH * 0.5,
            height: 160,
            borderWidth: 1,
            borderColor: 'rgba(59, 130, 246, 0.1)',
            justifyContent: 'flex-start',
            elevation: 3,
            shadowColor: currentColors.primary,
            shadowOffset: { width: 0, height: 4 },
            shadowOpacity: 0.1,
            shadowRadius: 8
            }} onPress={() => navigation.navigate('PartyDetail', { partyId: item.id, partyData: item })}>
                <Text style={{fontSize: 16, fontWeight: 'bold', color: currentColors.text, marginBottom: 6, numberOfLines: 1}}>{item.title || '제목 없음'}</Text>
                <Text style={{fontSize: 13, color: currentColors.textSecondary, marginBottom: 6}}>🗓️ {item.party_date || '날짜 없음'} {item.party_time || '시간 없음'}</Text>
            <View style={{flexDirection: 'row', justifyContent: 'space-between', marginTop: 6, alignItems: 'center'}}>
                    <Text style={{fontSize: 12, color: currentColors.textSecondary}}>👥 {item.current_members || 0}/{item.max_members || 0}명</Text>
                    <Text style={{fontSize: 12, color: currentColors.textSecondary, numberOfLines: 1}}>📍 {item.restaurant_name || '식당 없음'}</Text>
            </View>
        </TouchableOpacity>
    );
    };

    if (isLoading) return <ActivityIndicator style={{flex: 1}} size="large" color={currentColors.primary} />;

    // 🚨 중요: 안전한 배열 접근을 위한 기본값 설정 및 추가 검증
    const safeMyParties = Array.isArray(myParties) ? myParties : [];
    const safeAllParties = Array.isArray(allParties) ? allParties : [];
    
    // 🚨 중요: 디버깅을 위한 상태 로깅
                    // console.log('🔍 [일반파티] 렌더링 시 상태:', { myParties, allParties, safeMyParties, safeAllParties });

    return (
        <ScrollView style={styles.safeArea}>
            <Text style={{fontSize: 20, fontWeight: 'bold', marginBottom: 12, color: currentColors.primary, paddingHorizontal: 16, marginTop: 16}}>내 일반파티</Text>
            {safeMyParties.length > 0 ? (
                <FlatList 
                    data={safeMyParties.filter(item => item && typeof item === 'object')} 
                    renderItem={renderMyPartyItem} 
                    keyExtractor={item => `my-${item?.id || 'unknown'}`} 
                    horizontal 
                    showsHorizontalScrollIndicator={false}
                    contentContainerStyle={{ paddingHorizontal: 16, paddingVertical: 5 }}
                />
            ) : <Text style={{fontSize: 16, color: currentColors.textSecondary, textAlign: 'center', marginTop: 50, paddingHorizontal: 16}}>참여한 일반파티가 없습니다.</Text>}
            
            <Text style={{fontSize: 20, fontWeight: 'bold', marginBottom: 12, color: currentColors.primary, paddingHorizontal: 16, marginTop: 16}}>전체 파티</Text>
            {safeAllParties.length > 0 ? (
                <FlatList 
                    data={safeAllParties.filter(item => item && typeof item === 'object')} 
                    renderItem={renderPartyItem} 
                    keyExtractor={item => `all-${item?.id || 'unknown'}`} 
                    scrollEnabled={false} 
                />
            ) : <Text style={{fontSize: 16, color: currentColors.textSecondary, textAlign: 'center', marginTop: 50, paddingHorizontal: 16}}>등록된 파티가 없습니다.</Text>}
        </ScrollView>
    );
}
function DangolPotContainerScreen({ navigation }) {
    const [myPots, setMyPots] = useState([]);
    const [allPots, setAllPots] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    
    // MissionContext 사용
    const { handleActionCompletion } = useMission();

    useFocusEffect(useCallback(() => {
        setIsLoading(true);
        Promise.all([
            fetch(`${RENDER_SERVER_URL}/my_dangolpots/${global.myEmployeeId || '1'}`).then(res => res.json()),
            fetch(`${RENDER_SERVER_URL}/dangolpots`).then(res => res.json())
        ]).then(([myPotsData, allPotsData]) => {
            if(Array.isArray(myPotsData)) setMyPots(myPotsData);
            if(Array.isArray(allPotsData)) setAllPots(allPotsData);
        }).catch(console.error).finally(() => setIsLoading(false));
    }, []));

    const renderPotItem = ({ item }) => (
        <TouchableOpacity style={{
            backgroundColor: currentColors.surface,
            borderRadius: 20,
            marginHorizontal: 16,
            marginBottom: 16,
            padding: 20,
            elevation: 3,
            shadowColor: currentColors.primary,
            shadowOffset: { width: 0, height: 4 },
            shadowOpacity: 0.1,
            shadowRadius: 8,
            borderWidth: 1,
            borderColor: 'rgba(59, 130, 246, 0.1)'
        }} onPress={() => navigation.navigate('DangolPotDetail', { potId: item.id })}>
            <View style={{flexDirection: 'row', justifyContent: 'space-between', marginBottom: 8}}>
                <Text style={{fontSize: 18, fontWeight: 'bold', color: currentColors.text}}>{item.name}</Text>
                <View style={{
                    backgroundColor: currentColors.primaryLight,
                    borderRadius: 20,
                    paddingVertical: 6,
                    paddingHorizontal: 12,
                    alignSelf: 'flex-start'
                }}>
                    <Text style={{color: currentColors.primary, fontWeight: 'bold', fontSize: 12}}>{item.category}</Text>
                </View>
            </View>
            <Text style={{fontSize: 14, color: currentColors.textSecondary, marginBottom: 4, numberOfLines: 1}}>{item.description}</Text>
            <Text style={{fontSize: 14, color: currentColors.textSecondary, marginBottom: 8}}>{item.tags}</Text>
            <View style={{flexDirection: 'row', justifyContent: 'space-between', marginTop: 10, alignItems: 'center'}}>
                <Text style={{fontSize: 14, color: currentColors.textSecondary}}>👥 {item.member_count}명</Text>
                <Text style={{fontSize: 14, color: currentColors.textSecondary}}>개설일: {item.created_at}</Text>
            </View>
        </TouchableOpacity>
    );

    const renderMyPotItem = ({ item }) => (
        <TouchableOpacity style={{
            backgroundColor: currentColors.surface,
            borderRadius: 20,
            padding: 20,
            marginHorizontal: 6,
            width: SCREEN_WIDTH * 0.5,
            height: 160,
            borderWidth: 1,
            borderColor: 'rgba(59, 130, 246, 0.1)',
            justifyContent: 'flex-start',
            elevation: 3,
            shadowColor: currentColors.primary,
            shadowOffset: { width: 0, height: 4 },
            shadowOpacity: 0.1,
            shadowRadius: 8
        }} onPress={() => navigation.navigate('DangolPotDetail', { potId: item.id })}>
            <Text style={{fontSize: 16, fontWeight: 'bold', color: currentColors.text, marginBottom: 6, numberOfLines: 1}}>{item.name}</Text>
            <View style={{marginBottom: 6}}>
                <View style={{
                    backgroundColor: currentColors.primaryLight,
                    borderRadius: 20,
                    paddingVertical: 6,
                    paddingHorizontal: 12,
                    alignSelf: 'flex-start'
                }}>
                    <Text style={{color: currentColors.primary, fontWeight: 'bold', fontSize: 12}}>{item.category}</Text>
                </View>
            </View>
            <Text style={{fontSize: 13, color: currentColors.textSecondary, marginBottom: 6, numberOfLines: 2}}>{item.description}</Text>
            <View style={{flexDirection: 'row', justifyContent: 'space-between', marginTop: 6, alignItems: 'center'}}>
                <Text style={{fontSize: 12, color: currentColors.textSecondary}}>👥 {item.member_count}명</Text>
                <Text style={{fontSize: 12, color: currentColors.textSecondary}}>{item.created_at}</Text>
            </View>
        </TouchableOpacity>
    );

    if (isLoading) return <ActivityIndicator style={{flex: 1}} size="large" color={currentColors.primary} />;

    return (
        <ScrollView style={styles.safeArea}>
            <Text style={{fontSize: 20, fontWeight: 'bold', marginBottom: 12, color: currentColors.primary, paddingHorizontal: 16, marginTop: 16}}>내 단골파티</Text>
            {myPots.length > 0 ? (
                <FlatList 
                    data={myPots} 
                    renderItem={renderMyPotItem} 
                    keyExtractor={item => `my-${item.id}`} 
                    horizontal 
                    showsHorizontalScrollIndicator={false}
                    contentContainerStyle={{ paddingHorizontal: 16, paddingVertical: 5 }}
                />
            ) : <Text style={{fontSize: 16, color: currentColors.textSecondary, textAlign: 'center', marginTop: 50, paddingHorizontal: 16}}>가입한 단골파티가 없습니다.</Text>}
            
            <Text style={{fontSize: 20, fontWeight: 'bold', marginBottom: 12, color: currentColors.primary, paddingHorizontal: 16, marginTop: 16}}>전체 단골파티</Text>
            <FlatList data={allPots} renderItem={renderPotItem} keyExtractor={item => `all-${item.id}`} scrollEnabled={false} />
        </ScrollView>
    );
}

function PartiesContainerScreen({ navigation, route }) {
    const { user } = useAuth();
    const [tabIndex, setTabIndex] = useState(0);
    const currentTabIndexRef = useRef(0);
    const isProcessingSwitchToTab = useRef(false);
    
    // useNavigationState 제거하고 useState만 사용
    // const currentTabIndex = useNavigationState(state => { ... });
    
    // currentTabIndexRef 업데이트
    useEffect(() => {
        currentTabIndexRef.current = tabIndex;
    }, [tabIndex]);
    
    // route.params에서 switchToTab 확인하여 특정 탭으로 이동
    useEffect(() => {
                    // console.log('🔍 PartiesContainerScreen - route.params 변경 감지:', route.params);
        if (route.params?.switchToTab !== undefined) {
            const targetTabIndex = route.params.switchToTab;
            // console.log('🔍 PartiesContainerScreen - switchToTab 파라미터 받음:', targetTabIndex);
            
            // switchToTab 처리 중임을 표시
            isProcessingSwitchToTab.current = true;
            // console.log('🔍 PartiesContainerScreen - isProcessingSwitchToTab = true');
            
            setTabIndex(targetTabIndex);
            currentTabIndexRef.current = targetTabIndex;
            // console.log('🔍 PartiesContainerScreen - tabIndex 상태 업데이트됨:', targetTabIndex);
            
            // 파라미터 초기화
            navigation.setParams({ switchToTab: undefined });
            
            // 500ms 후에 처리 완료 표시
            setTimeout(() => {
                isProcessingSwitchToTab.current = false;
                // console.log('🔍 PartiesContainerScreen - isProcessingSwitchToTab = false');
            }, 500);
        }
    }, [route.params?.switchToTab, navigation]);
    
    // tabIndex가 변경될 때 TopTab.Navigator가 자동으로 해당 탭으로 이동
    // key={tabIndex}를 사용하여 Navigator를 다시 렌더링하므로 별도 로직 불필요
    useEffect(() => {
                    // console.log('🔍 PartiesContainerScreen - tabIndex 변경 감지:', tabIndex);
            // console.log('🔍 PartiesContainerScreen - currentTabIndexRef.current:', currentTabIndexRef.current);
    }, [tabIndex]);
    
    // 🚨 중요: 새 파티 생성 감지하여 파티 탭 새로고침
    useEffect(() => {
        if (global.refreshPartyTab && global.newPartyData) {
            // console.log('🔍 [파티탭] 새 파티 생성 감지, 탭 새로고침 시작');
            
            // 🚨 중요: 전역 변수는 유지 (PartyListScreen에서 사용할 수 있도록)
            global.refreshPartyTab = false;
            // global.newPartyData는 PartyListScreen에서 처리 후 초기화
            
            // 일반파티 탭으로 이동하여 새로고침
            setTabIndex(1);
            currentTabIndexRef.current = 1;
            
            // console.log('🔍 [파티탭] 일반파티 탭으로 이동 완료');
        }
    }, []);
    
    const handleAddPress = () => {
        const currentIndex = currentTabIndexRef.current;
        
        if (currentIndex === 0) {
            // 랜덤런치 탭에서는 제안 기반 시스템으로 이동
            navigation.navigate('RandomLunch');
        } else if (currentIndex === 1) {
            // 일반파티 탭에서는 새 파티 만들기 화면으로 이동
            navigation.navigate('CreateParty');
        } else if (currentIndex === 2) {
            // 단골파티 탭에서는 새 단골파티 만들기 화면으로 이동
            navigation.navigate('CreateDangolPot');
        }
    };
    
    return (
        <SafeAreaView style={{flex: 1, backgroundColor: currentColors.background}}>
            <TopTab.Navigator
                key={tabIndex} // tabIndex가 변경될 때마다 Navigator를 다시 렌더링
                initialRouteName={tabIndex === 0 ? "랜덤런치" : tabIndex === 1 ? "일반파티" : "단골파티"}
                // 디버깅을 위한 로그 추가
                onStateChange={(state) => {
                    // console.log('🔍 TopTab.Navigator - 상태 변경:', state);
                }}
                screenOptions={{
                    tabBarActiveTintColor: currentColors.primary,
                    tabBarInactiveTintColor: currentColors.gray,
                    tabBarIndicatorStyle: { backgroundColor: currentColors.primary },
                    tabBarLabelStyle: { fontWeight: '600', fontSize: 16, marginTop: 2 },
                    tabBarIconStyle: { marginBottom: 4 }
                }}
                screenListeners={{
                    tabPress: (e) => {
                        const routeName = e.target.split('-')[0];
                        // console.log('🔍 TopTab.Navigator - 탭 클릭 감지:', routeName);
                        
                        // switchToTab 처리 중인 경우 tabPress 이벤트를 무시
                        if (isProcessingSwitchToTab.current) {
                            // console.log('🔍 TopTab.Navigator - switchToTab 처리 중이어서 tabPress 이벤트 무시');
                            return;
                        }
                        
                        if (routeName === '랜덤런치') {
                            setTabIndex(0);
                            currentTabIndexRef.current = 0;
                        } else if (routeName === '일반파티') {
                            setTabIndex(1);
                            currentTabIndexRef.current = 1;
                        } else if (routeName === '단골파티') {
                            setTabIndex(2);
                            currentTabIndexRef.current = 2;
                        }
                    },
                    focus: (e) => {
                        const routeName = e.target.split('-')[0];
                        // 탭 포커스 감지 (로그 간소화)
                        
                        // switchToTab 처리 중인 경우 focus 이벤트를 무시
                        if (isProcessingSwitchToTab.current) {
                            return;
                        }
                        
                        if (routeName === '랜덤런치') {
                            setTabIndex(0);
                            currentTabIndexRef.current = 0;
                        } else if (routeName === '일반파티') {
                            setTabIndex(1);
                            currentTabIndexRef.current = 1;
                        } else if (routeName === '단골파티') {
                            setTabIndex(2);
                            currentTabIndexRef.current = 2;
                        }
                    }
                }}
            >
                <TopTab.Screen name="랜덤런치" component={MyProposalsScreen} />
                <TopTab.Screen name="일반파티" component={PartyListScreen} />
                <TopTab.Screen name="단골파티" component={DangolPotContainerScreen} />
            </TopTab.Navigator>
            <TouchableOpacity
                style={{
                    position: 'absolute',
                    right: 24,
                    bottom: 32,
                    width: 56,
                    height: 56,
                    borderRadius: 28,
                    backgroundColor: currentColors.primary,
                    justifyContent: 'center',
                    alignItems: 'center',
                    zIndex: 10,
                    elevation: 8,
                    shadowColor: currentColors.primary,
                    shadowOffset: { width: 0, height: 4 },
                    shadowOpacity: 0.3,
                    shadowRadius: 8
                }}
                activeOpacity={0.85}
                onPress={handleAddPress}
            >
                <Ionicons name="add" size={32} color="#fff" />
            </TouchableOpacity>
        </SafeAreaView>
    );
}



// PartyDetailScreen 관련 함수들은 별도 파일로 이동됨



function DangolPotDetailScreen({ route, navigation }) {
    const { user } = useAuth();
    const { potId } = route.params;
    const [pot, setPot] = useState(null);
    const [isMember, setIsMember] = useState(false);
    
    // MissionContext 사용
    const { handleActionCompletion } = useMission();

    const fetchDetails = useCallback(() => {
        fetch(`${RENDER_SERVER_URL}/dangolpots/${potId}`).then(res => res.json()).then(data => {
            setPot(data);
            setIsMember(data.members.some(m => m.employee_id === global.myEmployeeId || '1'));
        }).catch(console.error);
    }, [potId]);

    useFocusEffect(useCallback(() => {
        fetchDetails();
    }, [fetchDetails]));

    const handleJoin = async () => {
        const response = await fetch(`${RENDER_SERVER_URL}/dangolpots/${pot.id}/join`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ employee_id: global.myEmployeeId || '1' }) });
        if (response.ok) { 
            Alert.alert("성공", "단골파티에 가입했습니다!");
            
            // 미션 달성 체크: 단골파티 참여
            handleActionCompletion('dangol_party_join');
                            // console.log('🔍 DangolPotDetailScreen - 단골파티 참여 미션 달성');
            
            fetchDetails(); 
        } else { 
            Alert.alert("오류", "가입에 실패했습니다."); 
        }
    };

    const handleDeletePot = async () => {
        Alert.alert(
            '단골파티 삭제',
            '정말로 이 단골파티를 삭제하시겠습니까?',
            [
                { text: '취소', style: 'cancel' },
                { text: '삭제', style: 'destructive', onPress: async () => {
                    try {
                        const response = await fetch(`${RENDER_SERVER_URL}/dangolpots/${pot.id}?employee_id=${global.myEmployeeId || '1'}`, { method: 'DELETE' });
                        const data = await response.json();
                        if (response.ok) {
                            Alert.alert('성공', '단골파티가 삭제되었습니다.');
                            navigation.goBack();
                        } else {
                            Alert.alert('오류', data.message || '단골파티 삭제에 실패했습니다.');
                        }
                    } catch (e) {
                        Alert.alert('오류', '단골파티 삭제에 실패했습니다.');
                    }
                }}
            ]
        );
    };
    
    if (!pot) return <View style={styles.centerView}><ActivityIndicator size="large" color={currentColors.primary} /></View>;

    const isHost = pot.host_id === (global.myEmployeeId || '1');

    const renderActionButtons = () => {
        if (isMember) {
            return (
                <View>
                    <TouchableOpacity style={styles.submitButton} onPress={() => safeNavigateToTab(navigation, '소통', 'ChatRoom', { chatId: pot.id, chatType: 'dangolpot', chatTitle: pot.name })}>
                        <Text style={styles.textStyle}>채팅방으로 이동</Text>
                    </TouchableOpacity>
                    {isHost && (
                        <>
                            <TouchableOpacity style={[styles.submitButton, {marginTop: 10, backgroundColor: currentColors.gray}]} onPress={() => navigation.navigate('EditDangolPot', { potData: pot })}>
                                <Text style={[styles.submitButtonText, {color: currentColors.white}]}>단골파티 정보 수정</Text>
                            </TouchableOpacity>
                            <TouchableOpacity style={[styles.submitButton, {marginTop: 10, backgroundColor: currentColors.red}]} onPress={handleDeletePot}>
                                <Text style={[styles.submitButtonText, {color: currentColors.white}]}>단골파티 삭제</Text>
                            </TouchableOpacity>
                        </>
                    )}
                </View>
            );
        }
        return (
            <TouchableOpacity style={styles.submitButton} onPress={handleJoin}>
                <Text style={styles.submitButtonText}>가입하기</Text>
            </TouchableOpacity>
        );
    };

    return (
        <SafeAreaView style={styles.safeArea}>
            <ScrollView contentContainerStyle={styles.detailContainer}>
                {/* 단골파티 제목 카드 */}
                <View style={styles.partyDetailCard}>
                    <View style={styles.titleRow}>
                        <Text style={styles.title}>{pot.name}</Text>
                        <View style={styles.categoryChip}>
                            <Text style={styles.categoryChipText}>{pot.category}</Text>
                        </View>
                    </View>
                </View>

                {/* 단골파티 정보 카드 */}
                <View style={styles.partyDetailCard}>
                    <Text style={styles.cardTitle}>📋 단골파티 정보</Text>
                    <Text style={styles.descriptionText}>{pot.description}</Text>
                    <View style={styles.tagsContainer}>
                        <Text style={styles.tagsText}>#️⃣ {pot.tags}</Text>
                    </View>
                </View>

                {/* 멤버 목록 카드 */}
                <View style={styles.partyDetailCard}>
                    <Text style={styles.cardTitle}>👥 멤버 목록 ({pot.members.length}명)</Text>
                    
                    {/* 팟장(호스트) 표시 */}
                    {(() => {
                        const leader = pot.members.find(m => m.is_host);
                        if (!leader) return null;
                        return (
                            <TouchableOpacity 
                                style={styles.memberCard}
                                onPress={() => safeNavigateToTab(navigation, '친구', 'UserProfile', { employeeId: leader.employee_id })}
                            >
                                <View style={styles.memberContent}>
                                    {/* 아바타 */}
                                    <View style={[styles.memberAvatar, { backgroundColor: COLORS.yellow }]}>
                                        <Text style={[styles.avatarText, { color: COLORS.deepBlue }]}>
                                            {leader.nickname ? leader.nickname.charAt(0) : '?'}
                                        </Text>
                                    </View>
                                    
                                    {/* 멤버 정보 */}
                                    <View style={styles.memberInfo}>
                                        <View style={styles.memberHeader}>
                                            <Text style={styles.memberName}>
                                                {leader.nickname || '알 수 없음'} 👑
                                            </Text>
                                            <View style={styles.hostBadge}>
                                                <Text style={styles.hostBadgeText}>팟장</Text>
                                            </View>
                                        </View>
                                    </View>
                                </View>
                            </TouchableOpacity>
                        );
                    })()}

                    {/* 일반 멤버들 표시 */}
                    {pot.members.filter(m => {
                        const leader = pot.members.find(x => x.is_host);
                        return !leader || m.employee_id !== leader.employee_id;
                    }).map((item, index) => (
                        <TouchableOpacity 
                            key={`member-${item.employee_id}-${index}`} 
                            style={styles.memberCard}
                            onPress={() => safeNavigateToTab(navigation, '친구', 'UserProfile', { employeeId: item.employee_id })}
                        >
                            <View style={styles.memberContent}>
                                {/* 아바타 */}
                                <View style={styles.memberAvatar}>
                                    <Text style={styles.avatarText}>
                                        {item.nickname ? item.nickname.charAt(0) : '?'}
                                    </Text>
                                </View>
                                
                                {/* 멤버 정보 */}
                                <View style={styles.memberInfo}>
                                    <View style={styles.memberHeader}>
                                        <Text style={styles.memberName}>
                                            {item.nickname || '알 수 없음'}
                                        </Text>
                                    </View>
                                </View>
                            </View>
                        </TouchableOpacity>
                    ))}
                </View>

                {/* 액션 버튼들 */}
                <View style={styles.actionContainer}>
                    {renderActionButtons()}
                </View>
            </ScrollView>
        </SafeAreaView>
    );
}

// CreatePartyScreen은 별도 파일로 이동됨


function CreateDangolPotScreen({ navigation }) {
    const { user } = useAuth();
    const [name, setName] = useState('');
    const [description, setDescription] = useState('');
    const [tags, setTags] = useState('');
    const [category, setCategory] = useState('');
    const [isCategoryModalVisible, setCategoryModalVisible] = useState(false);
    const CATEGORY_OPTIONS = ['한식', '중식', '일식', '양식', '분식', '카페', '아시안', '퓨전', '기타'];
    
    // MissionContext 사용
    const { handleActionCompletion } = useMission();

    const handleSubmit = async () => {
        if (!name || !category) { Alert.alert("입력 오류", "단골파티 이름과 카테고리는 필수입니다."); return; }
        const response = await fetch(`${RENDER_SERVER_URL}/dangolpots`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ name, description, tags, category, host_id: global.myEmployeeId || '1' }) });
        if (response.ok) { 
            Alert.alert("성공", "단골파티가 생성되었습니다!");
            
            // 미션 달성 체크: 단골파티 참여
            handleActionCompletion('dangol_party_join');
                            // console.log('🔍 CreateDangolPotScreen - 단골파티 참여 미션 달성');
            
            navigation.goBack(); 
        } else { 
            Alert.alert("오류", "단골파티 생성에 실패했습니다."); 
        }
    };
    return (
        <SafeAreaView style={styles.safeArea}>
            <ScrollView contentContainerStyle={styles.formContainer}>
                <Text style={styles.inputLabel}>단골파티 이름</Text>
                <TextInput 
                    style={styles.input} 
                    value={name} 
                    onChangeText={setName}
                    returnKeyType="done"
                    onSubmitEditing={() => {
                        Keyboard.dismiss();
                    }}
                    blurOnSubmit={true}
                />
                <Text style={styles.inputLabel}>음식 카테고리</Text>
                <TouchableOpacity style={styles.input} onPress={() => setCategoryModalVisible(true)}><Text style={category ? styles.inputText : styles.placeholderText}>{category || "카테고리 선택"}</Text></TouchableOpacity>
                <Text style={styles.inputLabel}>소개</Text>
                <TextInput 
                    style={[styles.input, {height: 100, textAlignVertical: 'top'}]} 
                    placeholder="어떤 모임인지 소개해주세요" 
                    value={description} 
                    onChangeText={setDescription} 
                    multiline
                    returnKeyType="done"
                    onSubmitEditing={() => {
                        Keyboard.dismiss();
                    }}
                    blurOnSubmit={true}
                />
                <Text style={styles.inputLabel}>관심사 태그</Text>
                <TextInput 
                    style={styles.input} 
                    placeholder="예: #매운맛 #맛집탐방" 
                    value={tags} 
                    onChangeText={setTags}
                    returnKeyType="done"
                    onSubmitEditing={() => {
                        Keyboard.dismiss();
                    }}
                    blurOnSubmit={true}
                />
                <TouchableOpacity style={styles.submitButton} onPress={handleSubmit}><Text style={[styles.submitButtonText, {color: currentColors.white}]}>만들기</Text></TouchableOpacity>
                <SelectionModal visible={isCategoryModalVisible} title="카테고리 선택" options={CATEGORY_OPTIONS} selected={category} onSelect={setCategory} onClose={() => setCategoryModalVisible(false)} styles={styles} colors={currentColors} />
            </ScrollView>
        </SafeAreaView>
    );
}

function EditDangolPotScreen({ route, navigation }) {
    const { potData } = route.params;
    const [name, setName] = useState(potData.name);
    const [description, setDescription] = useState(potData.description);
    const [tags, setTags] = useState(potData.tags);
    const [category, setCategory] = useState(potData.category);
    const [isCategoryModalVisible, setCategoryModalVisible] = useState(false);
    const CATEGORY_OPTIONS = ['한식', '중식', '일식', '양식', '분식', '카페', '아시안', '퓨전', '기타'];

    const handleUpdate = async () => {
        if (!name || !category) { Alert.alert("입력 오류", "단골파티 이름과 카테고리는 필수입니다."); return; }
        const response = await fetch(`${RENDER_SERVER_URL}/dangolpots/${potData.id}`, { 
            method: 'PUT', 
            headers: { 'Content-Type': 'application/json' }, 
            body: JSON.stringify({ name, description, tags, category, employee_id: global.myEmployeeId || '1' }) 
        });
        if (response.ok) { Alert.alert("성공", "단골파티 정보가 수정되었습니다!"); navigation.goBack(); } 
        else { Alert.alert("오류", "단골파티 수정에 실패했습니다."); }
    };

    return (
        <SafeAreaView style={styles.safeArea}>
            <ScrollView contentContainerStyle={styles.formContainer}>
                    <Text style={styles.inputLabel}>단골파티 이름</Text>
                    <TextInput 
                        style={styles.input} 
                        value={name} 
                        onChangeText={setName}
                        returnKeyType="done"
                        onSubmitEditing={() => {
                            Keyboard.dismiss();
                        }}
                        blurOnSubmit={true}
                    />
                <Text style={styles.inputLabel}>음식 카테고리</Text>
                <TouchableOpacity style={styles.input} onPress={() => setCategoryModalVisible(true)}><Text style={category ? styles.inputText : styles.placeholderText}>{category || "카테고리 선택"}</Text></TouchableOpacity>
                    <Text style={styles.inputLabel}>소개</Text>
                    <TextInput 
                        style={[styles.input, {height: 100, textAlignVertical: 'top'}]} 
                        placeholder="어떤 모임인지 소개해주세요" 
                        value={description} 
                        onChangeText={setDescription} 
                        multiline
                        returnKeyType="done"
                        onSubmitEditing={() => {
                            Keyboard.dismiss();
                        }}
                        blurOnSubmit={true}
                    />
                    <Text style={styles.inputLabel}>관심사 태그</Text>
                    <TextInput 
                        style={styles.input} 
                        placeholder="예: #매운맛 #맛집탐방" 
                        value={tags} 
                        onChangeText={setTags}
                        returnKeyType="done"
                        onSubmitEditing={() => {
                            Keyboard.dismiss();
                        }}
                        blurOnSubmit={true}
                    />
                <TouchableOpacity style={styles.submitButton} onPress={handleUpdate}><Text style={[styles.submitButtonText, {color: currentColors.white}]}>수정하기</Text></TouchableOpacity>
                <SelectionModal visible={isCategoryModalVisible} title="카테고리 선택" options={CATEGORY_OPTIONS} selected={category} onSelect={setCategory} onClose={() => setCategoryModalVisible(false)} styles={styles} colors={currentColors} />
            </ScrollView>
        </SafeAreaView>
    );
}
// --- 소통 탭 ---
function ChatListScreen({ navigation }) {
    const { user } = useAuth();
    const [chats, setChats] = useState([]);
    const [filteredChats, setFilteredChats] = useState([]);
    const [isLoading, setIsLoading] = useState(true);
    const [activeFilter, setActiveFilter] = useState('all');
    const [refreshing, setRefreshing] = useState(false);

    const fetchChats = async () => {
        try {
            const employeeId = user.employee_id;
            
            if (!employeeId) {
                console.log('⚠️ 사용자 ID가 없어서 채팅 목록을 가져올 수 없습니다');
                return;
            }
            
            console.log('💬 채팅 목록 조회 시작:', employeeId);
            const response = await fetch(`${RENDER_SERVER_URL}/chats/${employeeId}`);
            const data = await response.json();
            if(Array.isArray(data)) {
                setChats(data);
                setFilteredChats(data);
                console.log('✅ 채팅 목록 로드 완료:', data.length + '개');
            }
        } catch (error) {
            console.error('채팅 목록 조회 오류:', error);
        }
    };

    useFocusEffect(useCallback(() => {
        setIsLoading(true);
        fetchChats().finally(() => setIsLoading(false));
    }, []));

    const onRefresh = async () => {
        setRefreshing(true);
        await fetchChats();
        setRefreshing(false);
    };

    const handleFilterChange = (filter) => {
        setActiveFilter(filter);
        if (filter === 'all') {
            setFilteredChats(chats);
        } else if (filter === 'party') {
            setFilteredChats(chats.filter(chat => chat.type === 'party'));
        } else if (filter === 'dangolpot') {
            setFilteredChats(chats.filter(chat => chat.type === 'dangolpot'));
        } else if (filter === 'custom') {
            setFilteredChats(chats.filter(chat => chat.type === 'custom'));
        }
    };

    if (isLoading) return <ActivityIndicator style={{flex: 1}} size="large" color={currentColors.primary} />;
    
    return (
        <SafeAreaView style={styles.safeArea}>
            {/* 채팅 필터 */}
            <View style={{paddingHorizontal: 16, paddingVertical: 12, backgroundColor: currentColors.background}}>
                <ScrollView horizontal showsHorizontalScrollIndicator={false}>
                    <TouchableOpacity
                        style={{
                            backgroundColor: activeFilter === 'all' ? currentColors.primary : currentColors.surface,
                            borderRadius: 20,
                            paddingVertical: 8,
                            paddingHorizontal: 16,
                            marginRight: 8,
                            elevation: activeFilter === 'all' ? 2 : 1,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: activeFilter === 'all' ? 0.2 : 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: activeFilter === 'all' ? currentColors.primary : currentColors.lightGray
                        }}
                        onPress={() => handleFilterChange('all')}
                    >
                        <Text style={{
                            color: activeFilter === 'all' ? '#FFFFFF' : currentColors.text,
                            fontWeight: activeFilter === 'all' ? 'bold' : '600',
                            fontSize: 14
                        }}>
                            전체
                        </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                        style={{
                            backgroundColor: activeFilter === 'party' ? currentColors.primary : currentColors.surface,
                            borderRadius: 20,
                            paddingVertical: 8,
                            paddingHorizontal: 16,
                            marginRight: 8,
                            elevation: activeFilter === 'party' ? 2 : 1,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: activeFilter === 'party' ? 0.2 : 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: activeFilter === 'party' ? currentColors.primary : currentColors.lightGray
                        }}
                        onPress={() => handleFilterChange('party')}
                    >
                        <Text style={{
                            color: activeFilter === 'party' ? '#FFFFFF' : currentColors.text,
                            fontWeight: activeFilter === 'party' ? 'bold' : '600',
                            fontSize: 14
                        }}>
                            파티
                        </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                        style={{
                            backgroundColor: activeFilter === 'dangolpot' ? currentColors.primary : currentColors.surface,
                            borderRadius: 20,
                            paddingVertical: 8,
                            paddingHorizontal: 16,
                            marginRight: 8,
                            elevation: activeFilter === 'dangolpot' ? 2 : 1,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: activeFilter === 'dangolpot' ? 0.2 : 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: activeFilter === 'dangolpot' ? currentColors.primary : currentColors.lightGray
                        }}
                        onPress={() => handleFilterChange('dangolpot')}
                    >
                        <Text style={{
                            color: activeFilter === 'dangolpot' ? '#FFFFFF' : currentColors.text,
                            fontWeight: activeFilter === 'dangolpot' ? 'bold' : '600',
                            fontSize: 14
                        }}>
                            단골파티
                        </Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                        style={{
                            backgroundColor: activeFilter === 'custom' ? currentColors.primary : currentColors.surface,
                            borderRadius: 20,
                            paddingVertical: 8,
                            paddingHorizontal: 16,
                            marginRight: 8,
                            elevation: activeFilter === 'custom' ? 2 : 1,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: activeFilter === 'custom' ? 0.2 : 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: activeFilter === 'custom' ? currentColors.primary : currentColors.lightGray
                        }}
                        onPress={() => handleFilterChange('custom')}
                    >
                        <Text style={{
                            color: activeFilter === 'custom' ? '#FFFFFF' : currentColors.text,
                            fontWeight: activeFilter === 'custom' ? 'bold' : '600',
                            fontSize: 14
                        }}>
                            개인채팅
                        </Text>
                    </TouchableOpacity>
                </ScrollView>
            </View>

            <FlatList 
                data={filteredChats} 
                keyExtractor={item => `${item.type}-${item.id}`} 
                refreshing={refreshing}
                onRefresh={onRefresh}
                ListEmptyComponent={<Text style={{fontSize: 16, color: currentColors.textSecondary, textAlign: 'center', marginTop: 50, paddingHorizontal: 16}}>참여 중인 채팅방이 없습니다.</Text>} 
                renderItem={({ item }) => (
                    <TouchableOpacity 
                        style={{
                            backgroundColor: currentColors.surface,
                            borderRadius: 16,
                            marginHorizontal: 16,
                            marginBottom: 12,
                            padding: 16,
                            flexDirection: 'row',
                            alignItems: 'center',
                            elevation: 2,
                            shadowColor: currentColors.primary,
                            shadowOffset: { width: 0, height: 2 },
                            shadowOpacity: 0.1,
                            shadowRadius: 4,
                            borderWidth: 1,
                            borderColor: 'rgba(99, 102, 241, 0.2)'
                        }} 
                        onPress={() => navigation.navigate('ChatRoom', { chatId: item.id, chatType: item.type, chatTitle: item.title })}
                    >
                        <View style={{
                            backgroundColor: currentColors.primary,
                            borderRadius: 12,
                            width: 48,
                            height: 48,
                            justifyContent: 'center',
                            alignItems: 'center',
                            marginRight: 12
                        }}>
                            <Ionicons 
                                name={item.type === 'dangolpot' ? 'heart-circle' : (item.is_from_match ? 'shuffle' : 'restaurant')} 
                                size={24} 
                                color="white" 
                            />
                        </View>
                        <View style={{flex: 1}}>
                            <Text style={{fontSize: 16, fontWeight: 'bold', color: currentColors.text, marginBottom: 4}}>{item.title}</Text>
                            <Text style={{fontSize: 14, color: currentColors.textSecondary}}>{item.subtitle}</Text>
                            {item.last_message && (
                                <Text style={{fontSize: 12, color: currentColors.textSecondary, marginTop: 2}} numberOfLines={1}>
                                    {item.last_message}
                                </Text>
                            )}
                        </View>
                        <Ionicons name="chevron-forward" size={24} color={currentColors.textSecondary} />
                    </TouchableOpacity>
                )} 
                contentContainerStyle={{paddingTop: 16}} 
            />
            
            {/* 플로팅 채팅방 생성 버튼 */}
            <TouchableOpacity
                style={{
                    position: 'absolute',
                    right: 24,
                    bottom: 32,
                    width: 56,
                    height: 56,
                    borderRadius: 28,
                    backgroundColor: currentColors.primary,
                    justifyContent: 'center',
                    alignItems: 'center',
                    zIndex: 10,
                    elevation: 8,
                    shadowColor: currentColors.primary,
                    shadowOffset: { width: 0, height: 4 },
                    shadowOpacity: 0.3,
                    shadowRadius: 8
                }}
                activeOpacity={0.85}
                onPress={() => navigation.navigate('CreateChatRoom')}
            >
                <Ionicons name="chatbubbles" size={28} color="#fff" />
            </TouchableOpacity>
        </SafeAreaView>
    );
}
function ChatRoomScreen({ route, navigation }) {
    const { chatId, chatType, chatTitle: initialChatTitle } = route.params;
    const { handleActionCompletion } = useMission();
    const [chatDetails, setChatDetails] = useState(null);
    const [messages, setMessages] = useState([]);
    const [newMessage, setNewMessage] = useState('');
    const [socket, setSocket] = useState(null);
    const [isConnected, setIsConnected] = useState(false);
    const [isSearchVisible, setIsSearchVisible] = useState(false);
    const [searchQuery, setSearchQuery] = useState('');
    const [searchResults, setSearchResults] = useState([]);
    const [isSearching, setIsSearching] = useState(false);
    const [isImagePickerVisible, setIsImagePickerVisible] = useState(false);
    const [chatMembers, setChatMembers] = useState([]);
    const [isTitleEditVisible, setIsTitleEditVisible] = useState(false);
    const [isMembersVisible, setIsMembersVisible] = useState(false);
    const [newTitle, setNewTitle] = useState('');
    const [chatTitle, setChatTitle] = useState(initialChatTitle);
    const flatListRef = useRef(null);
    const [isMenuVisible, setIsMenuVisible] = useState(false);
    useEffect(() => {
        navigation.setOptions({
          headerRight: () => (
            <View style={{ flexDirection: 'row', marginRight: 10 }}>
              <TouchableOpacity onPress={() => setIsSearchVisible(!isSearchVisible)} style={{ marginRight: 16 }}>
                <Ionicons name="search" size={24} color={currentColors.text} />
              </TouchableOpacity>
              <TouchableOpacity onPress={() => setIsMenuVisible(true)}>
                <Ionicons name="menu" size={28} color={currentColors.text} />
              </TouchableOpacity>
            </View>
          ),
        });
      }, [navigation, setIsSearchVisible, setIsMenuVisible, currentColors.text]);

    // WebSocket 연결 및 실시간 읽음 처리 (임시로 비활성화)
    useEffect(() => {
        // WebSocket 연결이 설정되지 않은 경우를 대비해 임시로 연결된 것으로 처리
        setIsConnected(true);
        
        // 실제 WebSocket 연결은 백엔드 구현 후 활성화
        /*
        // WebSocket URL 생성
        let wsUrl = RENDER_SERVER_URL;
        if (wsUrl.startsWith('https://')) {
            wsUrl = wsUrl.replace('https://', 'wss://');
        } else if (wsUrl.startsWith('http://')) {
            wsUrl = wsUrl.replace('http://', 'ws://');
        }
        
        console.log('Attempting to connect to WebSocket:', wsUrl);
        
        const newSocket = io(wsUrl, {
            transports: ['polling', 'websocket'],
            timeout: 30000,
            forceNew: true,
            reconnection: true,
            reconnectionAttempts: 5,
            reconnectionDelay: 1000,
            reconnectionDelayMax: 5000
        });
        
        newSocket.on('connect', () => {
            console.log('Connected to WebSocket');
            setIsConnected(true);
            
            // 채팅방에 참여
            newSocket.emit('join_chat', {
                chat_type: chatType,
                chat_id: chatId
            });
        });

        newSocket.on('disconnect', (reason) => {
            console.log('Disconnected from WebSocket:', reason);
            setIsConnected(false);
        });

        newSocket.on('connect_error', (error) => {
            console.log('WebSocket connection error:', error);
            setIsConnected(false);
        });

        newSocket.on('reconnect', (attemptNumber) => {
            console.log('Reconnected to WebSocket after', attemptNumber, 'attempts');
            setIsConnected(true);
            
            // 재연결 시 채팅방에 다시 참여
            newSocket.emit('join_chat', {
                chat_type: chatType,
                chat_id: chatId
            });
        });

        newSocket.on('reconnect_error', (error) => {
            console.log('WebSocket reconnection error:', error);
            setIsConnected(false);
        });

        newSocket.on('new_message', (message) => {
            console.log('New message received:', message);
            setMessages(prev => [...prev, message]);
        });

        // 실시간 읽음 처리 이벤트
        newSocket.on('message_read', (data) => {
            console.log('Message read event received:', data);
            setMessages(prev => 
                prev.map(msg => 
                    msg.id === data.message_id 
                        ? { ...msg, unread_count: data.unread_count }
                        : msg
                )
            );
        });

        setSocket(newSocket);

        return () => {
            if (newSocket) {
                newSocket.emit('leave_chat', {
                    chat_type: chatType,
                    chat_id: chatId
                });
                newSocket.disconnect();
            }
        };
        */
    }, [chatId, chatType]);

    // 채팅방 정보 및 메시지 로드
    useFocusEffect(useCallback(() => { 
        const loadChatData = async () => {
            try {
                // 채팅방 정보 로드
                if (chatType === 'party') {
                    const response = await fetch(`${RENDER_SERVER_URL}/parties/${chatId}`);
                    const data = await response.json();
                    setChatDetails(data);
                    
                    // 파티 참가자 목록 가져오기
                    const membersResponse = await fetch(`${RENDER_SERVER_URL}/parties/${chatId}/members`);
                    if (membersResponse.ok) {
                        const membersData = await membersResponse.json();
                        setChatMembers(membersData);
                    }
                } else if (chatType === 'dangolpot') {
                    const response = await fetch(`${RENDER_SERVER_URL}/dangolpots/${chatId}`);
                    const data = await response.json();
                    setChatDetails(data);
                    
                    // 단골파티 참가자 목록 가져오기
                    const membersResponse = await fetch(`${RENDER_SERVER_URL}/dangolpots/${chatId}/members`);
                    if (membersResponse.ok) {
                        const membersData = await membersResponse.json();
                        setChatMembers(membersData);
                    }
                } else if (chatType === 'custom') {
                    // 개인 채팅의 경우 기본 채팅방 정보 설정
                    setChatDetails({
                        id: chatId,
                        title: chatTitle,
                        type: 'custom',
                        created_at: new Date().toISOString()
                    });
                    
                    // 개인 채팅의 경우 친구 목록에서 참가자 가져오기
                    const membersResponse = await fetch(`${RENDER_SERVER_URL}/friends?employee_id=${myEmployeeId}`);
                    if (membersResponse.ok) {
                        const friendsData = await membersResponse.json();
                        // 채팅방 제목에서 친구 이름 추출 (예: "홍길동님과의 채팅" -> "홍길동")
                        const friendName = chatTitle.replace('님과의 채팅', '');
                        const friend = friendsData.find(f => f.nickname === friendName);
                        if (friend) {
                            setChatMembers([friend]);
                        }
                    }
                }

                // 메시지 로드
                const messagesResponse = await fetch(`${RENDER_SERVER_URL}/chat/messages/${chatType}/${chatId}`);
                const messagesData = await messagesResponse.json();
                setMessages(messagesData);
                
                // 메시지가 로드된 후 가장 아래로 스크롤
                setTimeout(() => {
                    if (flatListRef.current && messagesData.length > 0) {
                        flatListRef.current.scrollToEnd({ animated: false });
                    }
                }, 200);
            } catch (error) {
                console.error('Error loading chat data:', error);
        }
        };

        loadChatData();
        
        // 실시간 메시지 업데이트를 위한 인터벌 설정 (3초마다)
        const messageInterval = setInterval(async () => {
            try {
                const messagesResponse = await fetch(`${RENDER_SERVER_URL}/chat/messages/${chatType}/${chatId}`);
                const messagesData = await messagesResponse.json();
                
                // 메시지 개수나 내용이 다르면 업데이트
                const currentMessageIds = messages.map(m => m.id).join(',');
                const newMessageIds = messagesData.map(m => m.id).join(',');
                
                if (currentMessageIds !== newMessageIds) {
                    // 새로운 메시지가 있는지 확인
                    const newMessages = messagesData.filter(newMsg => 
                        !messages.some(oldMsg => oldMsg.id === newMsg.id)
                    );
                    
                    // 투표 알림 메시지가 있는지 확인
                    const votingNotifications = newMessages.filter(msg => msg.message_type === 'voting_notification');
                    if (votingNotifications.length > 0) {
                        console.log('새로운 투표 알림 감지:', votingNotifications);
                        // 사용자에게 투표 알림
                        Alert.alert(
                            '📊 새로운 투표',
                            '새로운 투표가 시작되었습니다! 채팅창의 투표 메시지를 터치하여 참여하세요.',
                            [{ text: '확인' }]
                        );
                    }
                    
                    // 투표 삭제 알림 메시지가 있는지 확인
                    const votingCancellations = newMessages.filter(msg => msg.message_type === 'voting_cancelled');
                    if (votingCancellations.length > 0) {
                        console.log('투표 삭제 알림 감지:', votingCancellations);
                        // 사용자에게 투표 삭제 알림
                        Alert.alert(
                            '🚫 투표 삭제',
                            '투표가 삭제되었습니다.',
                            [{ text: '확인' }]
                        );
                    }
                    
                    // 투표 완료 알림 메시지가 있는지 확인
                    const votingCompletions = newMessages.filter(msg => msg.message_type === 'voting_completed');
                    if (votingCompletions.length > 0) {
                        console.log('투표 완료 알림 감지:', votingCompletions);
                        // 사용자에게 투표 완료 알림
                        Alert.alert(
                            '🎉 투표 완료',
                            '투표가 완료되어 일정이 확정되었습니다! 일정에 자동으로 저장되었습니다.',
                            [{ text: '확인' }]
                        );
                    }
                    
                    setMessages(messagesData);
                    
                    // 새로운 메시지가 있을 때 스크롤
                    setTimeout(() => {
                        if (flatListRef.current) {
                            flatListRef.current.scrollToEnd({ animated: true });
                        }
                    }, 100);
                }
            } catch (error) {
                console.error('실시간 메시지 업데이트 오류:', error);
            }
        }, 3000);
        
        // 클린업 함수
        return () => {
            if (messageInterval) {
                clearInterval(messageInterval);
            }
        };
    }, [chatId, chatType, messages.length]));

    // 메시지 목록이 변경될 때마다 자동 스크롤
    useEffect(() => {
        if (messages.length > 0) {
            setTimeout(() => {
                if (flatListRef.current) {
                    flatListRef.current.scrollToEnd({ animated: true });
                }
            }, 100);
        }
    }, [messages.length]);

    // 메시지 전송
    const sendMessage = async () => {
        if (!newMessage.trim()) return;

        const messageText = newMessage.trim();
        setNewMessage(''); // 즉시 입력창 비우기

        try {
            console.log('Sending message:', messageText);
            
            // HTTP API로 메시지 전송 (WebSocket 연결 문제로 인해 HTTP만 사용)
            console.log('Sending via HTTP API');
            const response = await fetch(`${RENDER_SERVER_URL}/chat/messages`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
            chat_type: chatType,
            chat_id: chatId,
            sender_employee_id: myEmployeeId,
                    message: messageText
                })
            });

            if (response.ok) {
                const responseData = await response.json();
                console.log('Message sent via HTTP:', responseData);
                
                // 서버에서 받은 메시지 데이터로 로컬에 추가
                const newMsg = {
                    id: responseData.id || Date.now(),
                    sender_employee_id: myEmployeeId,
                    sender_nickname: myNickname,
                    message: messageText,
                    created_at: responseData.created_at || new Date().toISOString(),
                    chat_type: chatType,
                    chat_id: chatId,
                    unread_count: 0
                };
                setMessages(prev => [...prev, newMsg]);
                
                // 소통의 시작 미션 완료 처리
                handleActionCompletion('chat_with_friend');
                
                // 메시지를 보낸 후 스크롤
                setTimeout(() => {
                    if (flatListRef.current) {
                        flatListRef.current.scrollToEnd({ animated: true });
                    }
                }, 100);
            } else {
                const errorData = await response.json();
                console.error('Message send failed:', errorData);
                Alert.alert('오류', errorData.message || '메시지 전송에 실패했습니다.');
                setNewMessage(messageText); // 실패 시 다시 입력창에 복원
            }
        } catch (error) {
            console.error('메시지 전송 오류:', error);
            Alert.alert('오류', '네트워크에 문제가 발생했습니다.');
            setNewMessage(messageText); // 실패 시 다시 입력창에 복원
        }
    };

    // 메시지 검색
    const searchMessages = async () => {
        if (!searchQuery.trim()) {
            setSearchResults([]);
            return;
        }

        try {
            setIsSearching(true);
            const response = await fetch(`${RENDER_SERVER_URL}/chat/messages/search?employee_id=${myEmployeeId}&chat_type=${chatType}&chat_id=${chatId}&query=${encodeURIComponent(searchQuery.trim())}`);
            
            // 응답 상태 확인
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            
            // 응답 타입 확인
            const contentType = response.headers.get('content-type');
            if (!contentType || !contentType.includes('application/json')) {
                throw new Error('서버에서 JSON이 아닌 응답을 받았습니다.');
            }
            
            const data = await response.json();
                setSearchResults(data);
        } catch (error) {
            console.error('메시지 검색 오류:', error);
            
            // 사용자에게 더 명확한 오류 메시지 표시
            if (error.message.includes('JSON')) {
                Alert.alert('오류', '서버 응답 오류가 발생했습니다. 잠시 후 다시 시도해주세요.');
            } else if (error.message.includes('HTTP')) {
                Alert.alert('오류', '서버에 연결할 수 없습니다. 네트워크를 확인해주세요.');
            } else {
                Alert.alert('오류', '메시지 검색 중 문제가 발생했습니다.');
            }
            
            setSearchResults([]);
        } finally {
            setIsSearching(false);
        }
    };

    // 채팅방 나가기
    const leaveChat = async () => {
        Alert.alert('채팅방 나가기', '정말로 이 채팅방을 나가시겠습니까?', [
            { text: '취소', style: 'cancel' },
            { 
                text: '나가기', 
                style: 'destructive', 
                onPress: async () => {
                    try {
                        const response = await fetch(`${RENDER_SERVER_URL}/chat/leave`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                employee_id: myEmployeeId,
                                chat_type: chatType,
                                chat_id: chatId
                            })
                        });
                        const data = await response.json();
                        if (response.ok) {
                            Alert.alert('성공', data.message);
                            navigation.goBack();
                        } else {
                            Alert.alert('오류', data.message || '채팅방을 나가는데 실패했습니다.');
                        }
                    } catch (error) {
                        console.error('채팅방 나가기 오류:', error);
                        Alert.alert('오류', '네트워크에 문제가 발생했습니다.');
                    }
                }
            }
        ]);
    };
    // 점심 약속 잡기
    const handleLunchScheduling = async () => {
        if (chatMembers.length === 0) {
            // 참가자 정보가 없으면 먼저 가져오기
            try {
                const response = await fetch(`${RENDER_SERVER_URL}/chat/room/members/${chatType}/${chatId}`);
                const data = await response.json();
                if (response.ok) {
                    setChatMembers(data);
                    // 참가자 정보를 가져온 후 지능형 스케줄링 화면으로 이동
                    navigation.navigate('IntelligentScheduling', { 
                        chatMembers: data,
                        chatType: chatType,
                        chatId: chatId
                    });
                } else {
                    Alert.alert('오류', data.message || '참가자 목록 조회에 실패했습니다.');
                }
            } catch (error) {
                console.error('참가자 목록 조회 오류:', error);
                Alert.alert('오류', '네트워크에 문제가 발생했습니다.');
            }
        } else {
            // 참가자 정보가 이미 있으면 바로 이동
        navigation.navigate('IntelligentScheduling', { 
            chatMembers: chatMembers,
            chatType: chatType,
            chatId: chatId
        });
        }
    };

    // 채팅방 제목 변경
    const handleTitleChange = async () => {
        if (!newTitle.trim()) {
            Alert.alert('오류', '새 제목을 입력해주세요.');
            return;
        }

        try {
            const response = await fetch(`${RENDER_SERVER_URL}/chat/room/title`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    chat_type: chatType,
                    chat_id: chatId,
                    title: newTitle.trim(),
                    user_id: myEmployeeId
                })
            });

            const data = await response.json();
            if (response.ok) {
                Alert.alert('성공', data.message);
                setChatTitle(newTitle.trim());
                setIsTitleEditVisible(false);
                setNewTitle('');
            } else {
                Alert.alert('오류', data.message || '제목 변경에 실패했습니다.');
            }
        } catch (error) {
            console.error('제목 변경 오류:', error);
            Alert.alert('오류', '네트워크에 문제가 발생했습니다.');
        }
    };

    // 참가자 목록 조회
    const fetchMembers = async () => {
        try {
            const response = await fetch(`${RENDER_SERVER_URL}/chat/room/members/${chatType}/${chatId}`);
            const data = await response.json();
            if (response.ok) {
                setChatMembers(data);
                setIsMembersVisible(true);
            } else {
                Alert.alert('오류', data.message || '참가자 목록 조회에 실패했습니다.');
            }
        } catch (error) {
            console.error('참가자 목록 조회 오류:', error);
            Alert.alert('오류', '네트워크에 문제가 발생했습니다.');
        }
    };

    // 이미지 전송
    const sendImage = async (imageUri) => {
        try {
            // 이미지를 base64로 변환
            const response = await fetch(imageUri);
            const blob = await response.blob();
            const reader = new FileReader();
            
            reader.onload = async () => {
                const base64Data = reader.result;
                
                // 서버에 이미지 업로드
                const uploadResponse = await fetch(`${RENDER_SERVER_URL}/chat/upload-image`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        image_data: base64Data,
                        chat_type: chatType,
                        chat_id: chatId,
                        sender_employee_id: myEmployeeId
                    })
                });
                
                const uploadData = await uploadResponse.json();
                if (uploadResponse.ok) {
                    // WebSocket으로 이미지 메시지 전송
                    socket.emit('send_message', {
                        chat_type: chatType,
                        chat_id: chatId,
                        sender_employee_id: myEmployeeId,
                        message: '[이미지]',
                        message_type: 'image',
                        file_url: uploadData.file_url
                    });
                } else {
                    Alert.alert('오류', uploadData.message || '이미지 업로드에 실패했습니다.');
                }
            };
            
            reader.readAsDataURL(blob);
        } catch (error) {
            console.error('이미지 전송 오류:', error);
            Alert.alert('오류', '이미지 전송에 실패했습니다.');
        }
    };
    // 메시지 렌더링
    const renderMessage = ({ item }) => {
        const isMyMessage = item.sender_employee_id === myEmployeeId;
        
        // 식당 공유 메시지인지 확인
        const isRestaurantShareMessage = item.message && item.message.includes('[식당정보:');
        let restaurantData = null;
        
        if (isRestaurantShareMessage) {
            try {
                // [식당정보:로 시작하고 ]로 끝나는 부분을 찾기
                const startIndex = item.message.indexOf('[식당정보:');
                const endIndex = item.message.lastIndexOf(']');
                
                if (startIndex !== -1 && endIndex !== -1 && endIndex > startIndex) {
                    const jsonString = item.message.substring(startIndex + 6, endIndex);
                    console.log('파싱할 JSON 문자열:', jsonString);
                    restaurantData = JSON.parse(jsonString);
                    console.log('파싱된 식당 데이터:', restaurantData);
                }
            } catch (error) {
                console.error('식당 정보 파싱 오류:', error);
                // 파싱 실패 시 기본 데이터로 대체
                restaurantData = {
                    id: 1,
                    name: '맛있는 한식당',
                    rating: '4.5',
                    address: '',
                    tags: ['한식', '오찬하기 좋아요'],
                    image: '',
                    shared_at: new Date().toISOString()
                };
            }
        }
        
        // 내가 보낸 메시지가 아니고 아직 읽지 않은 메시지인 경우 읽음 처리
        if (!isMyMessage && item.unread_count > 0) {
            // HTTP API를 사용하여 읽음 처리
            fetch(`${RENDER_SERVER_URL}/chat/messages/read`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    message_id: item.id,
                    user_id: myEmployeeId,
                    chat_type: chatType,
                    chat_id: chatId
                })
            }).catch(error => {
                console.error('읽음 처리 오류:', error);
            });
        }
        
        return (
            <View style={[styles.messageContainer, isMyMessage ? styles.myMessage : styles.otherMessage]}>
                {!isMyMessage && item.sender_nickname && (
                    <Text style={styles.messageSender}>{item.sender_nickname}</Text>
                )}
                <View style={[
                    styles.messageBubble,
                    isMyMessage ? styles.myMessageBubble : styles.otherMessageBubble,
                    { backgroundColor: isMyMessage ? currentColors.primary : currentColors.surface }
                ]}>
                    {item.message_type === 'voting_notification' ? (
                        <TouchableOpacity
                            style={{
                                backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                borderColor: currentColors.primary,
                                borderWidth: 2,
                                borderRadius: 16,
                                padding: 12,
                                margin: 0,
                                maxWidth: '95%',
                                width: '100%'
                            }}
                            onPress={() => {
                                console.log('투표 메시지 터치됨:', {
                                    voting_session_id: item.voting_session_id,
                                    chatRoomId: chatId,
                                    item: item
                                });
                                
                                // 투표 화면으로 이동
                                if (item.voting_session_id) {
                                    navigation.navigate('VotingParticipateScreen', {
                                        votingSessionId: item.voting_session_id,
                                        chatRoomId: chatId
                                    });
                                } else {
                                    Alert.alert('오류', '투표 정보를 찾을 수 없습니다.');
                                }
                            }}
                            activeOpacity={0.7}
                        >
                            <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 8 }}>
                                <Text style={{ fontSize: 24, marginRight: 8 }}>📊</Text>
                                <Text style={{
                                    fontSize: 16,
                                    fontWeight: 'bold',
                                    color: currentColors.primary,
                                    flex: 1
                                }}>
                                    새로운 투표
                                </Text>
                                <View style={{
                                    backgroundColor: currentColors.primary,
                                    borderRadius: 12,
                                    paddingHorizontal: 8,
                                    paddingVertical: 4
                                }}>
                                    <Text style={{
                                        color: 'white',
                                        fontSize: 12,
                                        fontWeight: 'bold'
                                    }}>
                                        터치하여 참여
                                    </Text>
                                </View>
                            </View>
                            <Text style={{
                                fontSize: 14,
                                color: currentColors.text,
                                lineHeight: 20
                            }}>
                                {item.message}
                            </Text>
                        </TouchableOpacity>
                    ) : item.message_type === 'voting_cancelled' ? (
                        <View
                            style={{
                                backgroundColor: 'rgba(239, 68, 68, 0.1)',
                                borderColor: '#EF4444',
                                borderWidth: 2,
                                borderRadius: 16,
                                padding: 12,
                                margin: 0,
                                maxWidth: '95%',
                                width: '100%'
                            }}
                        >
                            <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 8 }}>
                                <Text style={{ fontSize: 24, marginRight: 8 }}>🚫</Text>
                                <Text style={{
                                    fontSize: 16,
                                    fontWeight: 'bold',
                                    color: '#EF4444',
                                    flex: 1
                                }}>
                                    투표 삭제됨
                                </Text>
                                <View style={{
                                    backgroundColor: '#EF4444',
                                    borderRadius: 12,
                                    paddingHorizontal: 8,
                                    paddingVertical: 4
                                }}>
                                    <Text style={{
                                        color: 'white',
                                        fontSize: 12,
                                        fontWeight: 'bold'
                                    }}>
                                        삭제됨
                                    </Text>
                                </View>
                            </View>
                            <Text style={{
                                fontSize: 14,
                                color: currentColors.text,
                                lineHeight: 20
                            }}>
                                {item.message}
                            </Text>
                                                 </View>
                     ) : item.message_type === 'voting_completed' ? (
                        <TouchableOpacity
                            style={{
                                backgroundColor: 'rgba(46, 213, 115, 0.1)',
                                borderColor: '#2ed573',
                                borderWidth: 2,
                                borderRadius: 16,
                                padding: 12,
                                margin: 0,
                                maxWidth: '95%',
                                width: '100%'
                            }}
                            onPress={() => {
                                // 투표 화면으로 이동 (완료된 투표도 볼 수 있도록)
                                if (item.voting_session_id) {
                                    navigation.navigate('VotingParticipateScreen', {
                                        votingSessionId: item.voting_session_id,
                                        chatRoomId: chatId
                                    });
                                } else {
                                    Alert.alert('오류', '투표 정보를 찾을 수 없습니다.');
                                }
                            }}
                            activeOpacity={0.7}
                        >
                            <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 8 }}>
                                <Text style={{ fontSize: 24, marginRight: 8 }}>🎉</Text>
                                <Text style={{
                                    fontSize: 16,
                                    fontWeight: 'bold',
                                    color: '#2ed573',
                                    flex: 1
                                }}>
                                    투표 완료
                                </Text>
                                <View style={{
                                    backgroundColor: '#2ed573',
                                    borderRadius: 12,
                                    paddingHorizontal: 8,
                                    paddingVertical: 4
                                }}>
                                    <Text style={{
                                        color: 'white',
                                        fontSize: 12,
                                        fontWeight: 'bold'
                                    }}>
                                        확정됨
                                    </Text>
                                </View>
                            </View>
                            <Text style={{
                                fontSize: 14,
                                color: currentColors.text,
                                lineHeight: 20
                            }}>
                                {item.message}
                            </Text>
                        </TouchableOpacity>
                     ) : isRestaurantShareMessage ? (
                        <TouchableOpacity
                            style={{
                                backgroundColor: '#fff',
                                shadowColor: '#000',
                                shadowOffset: { width: 0, height: 2 },
                                shadowOpacity: 0.06,
                                shadowRadius: 8,
                                elevation: 2,
                                borderRadius: 16,
                                padding: 12,
                                margin: 0,
                                maxWidth: '95%',
                                width: '100%'
                            }}
                            onPress={() => {
                                if (restaurantData) {
                                    // 식당 상세 페이지로 이동
                                    navigation.navigate('RestaurantDetail', {
                                        restaurant: restaurantData
                                    });
                                } else {
                                    Alert.alert('오류', '식당 정보를 찾을 수 없습니다.');
                                }
                            }}
                            activeOpacity={0.7}
                        >
                            <View style={{ flexDirection: 'row', alignItems: 'center', marginBottom: 8 }}>
                                <Text style={{ fontSize: 24, marginRight: 8 }}>🍽️</Text>
                                <Text style={{
                                    fontSize: 16,
                                    fontWeight: 'bold',
                                    color: '#1E293B',
                                    flex: 1
                                }}>
                                    맛집 공유
                                </Text>
                                <View style={{
                                    backgroundColor: '#3B82F6',
                                    borderRadius: 12,
                                    paddingHorizontal: 8,
                                    paddingVertical: 4
                                }}>
                                    <Text style={{
                                        color: 'white',
                                        fontSize: 12,
                                        fontWeight: 'bold'
                                    }}>
                                        터치하여 보기
                                    </Text>
                                </View>
                            </View>
                            <Text style={{
                                fontSize: 14,
                                color: currentColors.text,
                                lineHeight: 20
                            }}>
                                {item.message.replace(/\[식당정보:.*?\]/, '').replace(/🍽️ 맛집 공유\n\n/, '')}
                            </Text>
                        </TouchableOpacity>
                     ) : item.message_type === 'image' && item.file_url ? (
                        <TouchableOpacity
                            onPress={() => {
                                Alert.alert('이미지 보기', '이미지 확대 보기 기능은 추후 구현 예정입니다.');
                            }}
                        >
                            <Image
                                source={{ uri: `${RENDER_SERVER_URL}${item.file_url}` }}
                                style={{ width: 200, height: 150, borderRadius: 12, marginBottom: 4 }}
                                resizeMode="cover"
                            />
                        </TouchableOpacity>
                    ) : (
                        <TouchableOpacity
                            onPress={() => {
                                // 일반 메시지도 클릭 시 식당 상세 페이지로 이동
                                const defaultRestaurantData = {
                                    id: 1,
                                    name: '맛있는 한식당',
                                    rating: '4.5',
                                    address: '',
                                    tags: ['한식', '오찬하기 좋아요'],
                                    image: '',
                                    shared_at: new Date().toISOString()
                                };
                                navigation.navigate('RestaurantDetail', {
                                    restaurant: defaultRestaurantData
                                });
                            }}
                            activeOpacity={0.7}
                        >
                            <Text style={[
                                styles.messageText,
                                isMyMessage ? styles.myMessageText : styles.otherMessageText,
                                isMyMessage ? { color: '#FFFFFF' } : null
                            ]}>
                                {item.message}
                            </Text>
                        </TouchableOpacity>
                    )}
                </View>
                <View style={{ flexDirection: 'row', alignItems: 'center', marginTop: 2 }}>
                    <Text style={styles.messageTime}>{item.created_at}</Text>
                    {isMyMessage && item.unread_count > 0 && (
                        <Text style={{ fontSize: 12, color: '#4FC3F7', marginLeft: 4 }}>{item.unread_count}</Text>
                    )}
                </View>
            </View>
        );
    };

    if (!chatDetails) {
    return (
        <SafeAreaView style={styles.safeArea}>
                <View style={{flex: 1, justifyContent: 'center', alignItems: 'center'}}>
                    <ActivityIndicator size="large" color={currentColors.primary}/>
            </View>
            </SafeAreaView>
        );
    }
    return (
        <SafeAreaView style={styles.safeArea}>
            <KeyboardAvoidingView 
                style={{flex: 1, backgroundColor: currentColors.background}}
                behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
                keyboardVerticalOffset={Platform.OS === 'ios' ? 90 : 0}
            >
                {/* 헤더 액션 버튼들 */}

                {/* 삼선(메뉴) 아이콘을 누르면 열리는 메뉴 모달 추가 */}
                <Modal
                    visible={isMenuVisible}
                    transparent={true}
                    animationType="fade"
                    onRequestClose={() => setIsMenuVisible(false)}
                >
                    <TouchableOpacity style={{ flex: 1, backgroundColor: 'rgba(0,0,0,0.3)' }} activeOpacity={1} onPress={() => setIsMenuVisible(false)}>
                        <View style={{ position: 'absolute', top: 60, right: 16, backgroundColor: currentColors.surface, borderRadius: 12, padding: 12, minWidth: 160, elevation: 8 }}>
                            <TouchableOpacity style={{ paddingVertical: 12 }} onPress={async () => { 
                                setIsMenuVisible(false);
                                
                                let membersToPass = chatMembers;
                                
                                // chatMembers가 비어있으면 먼저 로드
                                if (chatMembers.length === 0) {
                                    try {
                                        const response = await fetch(`${RENDER_SERVER_URL}/chat/room/members/${chatType}/${chatId}`);
                                        const data = await response.json();
                                        if (response.ok) {
                                            setChatMembers(data);
                                            membersToPass = data;
                                        } else {
                                            Alert.alert('오류', data.message || '참가자 목록 조회에 실패했습니다.');
                                            return;
                                        }
                                    } catch (error) {
                                        console.error('참가자 목록 조회 오류:', error);
                                        Alert.alert('오류', '네트워크에 문제가 발생했습니다.');
                                        return;
                                    }
                                }
                                
                                navigation.navigate('VotingScreen', { 
                                    chatRoomId: chatId,
                                    chatTitle: chatTitle, // 채팅방 제목 추가
                                    participants: membersToPass.map(member => ({
                                        employee_id: member.employee_id,
                                        nickname: member.nickname
                                    }))
                                }); 
                            }}>
                                <Text style={{ fontSize: 16, color: currentColors.primary, fontWeight: 'bold' }}>🗳️ 새로운 약속 잡기</Text>
                            </TouchableOpacity>
                            <View style={{ height: 1, backgroundColor: currentColors.lightGray, marginVertical: 4 }} />
                            <TouchableOpacity style={{ paddingVertical: 12 }} onPress={() => { setIsMenuVisible(false); setIsTitleEditVisible(true); }}>
                                <Text style={{ fontSize: 16, color: currentColors.text }}>채팅방 제목 변경</Text>
                            </TouchableOpacity>
                            <View style={{ height: 1, backgroundColor: currentColors.lightGray, marginVertical: 4 }} />
                            <TouchableOpacity style={{ paddingVertical: 12 }} onPress={() => { setIsMenuVisible(false); fetchMembers(); }}>
                                <Text style={{ fontSize: 16, color: currentColors.text }}>참가자 목록</Text>
                            </TouchableOpacity>
                            <View style={{ height: 1, backgroundColor: currentColors.lightGray, marginVertical: 4 }} />
                            <TouchableOpacity style={{ paddingVertical: 12 }} onPress={() => { 
                                setIsMenuVisible(false); 
                                Alert.alert(
                                    '채팅방 나가기',
                                    '정말로 이 채팅방을 나가시겠습니까?',
                                    [
                                        {
                                            text: '취소',
                                            style: 'cancel'
                                        },
                                        {
                                            text: '나가기',
                                            style: 'destructive',
                                            onPress: async () => {
                                                try {
                                                    const response = await fetch(`${API_BASE_URL}/chat/leave`, {
                                                        method: 'POST',
                                                        headers: { 'Content-Type': 'application/json' },
                                                        body: JSON.stringify({
                                                            chat_type: chatType,
                                                            chat_id: chatId,
                                                            employee_id: myEmployeeId
                                                        })
                                                    });
                                                    
                                                    if (response.ok) {
                                                        Alert.alert('완료', '채팅방을 나갔습니다.', [
                                                            { text: '확인', onPress: () => navigation.goBack() }
                                                        ]);
                                                    } else {
                                                        const errorData = await response.json();
                                                        Alert.alert('오류', errorData.error || '채팅방 나가기에 실패했습니다.');
                                                    }
                                                } catch (error) {
                                                    console.error('채팅방 나가기 오류:', error);
                                                    Alert.alert('오류', '네트워크 오류가 발생했습니다.');
                                                }
                                            }
                                        }
                                    ]
                                );
                            }}>
                                <Text style={{ fontSize: 16, color: currentColors.red }}>🚪 채팅방 나가기</Text>
                    </TouchableOpacity>
                </View>
                    </TouchableOpacity>
                </Modal>

                {/* 검색 영역 */}
                {isSearchVisible && (
                    <View style={{
                        backgroundColor: currentColors.surface,
                        paddingHorizontal: 16,
                        paddingVertical: 12,
                        borderBottomWidth: 1,
                        borderBottomColor: currentColors.lightGray
                    }}>
                        <View style={{
                            flexDirection: 'row',
                            alignItems: 'center'
                        }}>
                            <TextInput
                                style={{
                                    flex: 1,
                                    backgroundColor: currentColors.background,
                                    borderRadius: 20,
                                    paddingHorizontal: 16,
                                    paddingVertical: 8,
                                    marginRight: 8,
                                    fontSize: 14,
                                    color: currentColors.text,
                                    borderWidth: 1,
                                    borderColor: currentColors.lightGray
                                }}
                                value={searchQuery}
                                onChangeText={setSearchQuery}
                                placeholder="메시지 검색..."
                                placeholderTextColor={currentColors.textSecondary}
                                onSubmitEditing={searchMessages}
                            />
                            <TouchableOpacity
                                style={{
                                    backgroundColor: currentColors.primary,
                                    borderRadius: 20,
                                    paddingHorizontal: 12,
                                    paddingVertical: 8
                                }}
                                onPress={searchMessages}
                                disabled={isSearching}
                            >
                                {isSearching ? (
                                    <ActivityIndicator size="small" color="#FFFFFF" />
                                ) : (
                                    <Ionicons name="search" size={16} color="#FFFFFF" />
                                )}
                            </TouchableOpacity>
                            <TouchableOpacity
                                style={{
                                    backgroundColor: currentColors.lightGray,
                                    borderRadius: 20,
                                    paddingHorizontal: 12,
                                    paddingVertical: 8,
                                    marginLeft: 8
                                }}
                                onPress={() => {
                                    setIsSearchVisible(false);
                                    setSearchQuery('');
                                    setSearchResults([]);
                                }}
                            >
                                <Ionicons name="close" size={16} color={currentColors.text} />
                            </TouchableOpacity>
                        </View>
                        
                        {/* 검색 결과 */}
                        {searchResults.length > 0 && (
                            <View style={{marginTop: 8}}>
                                <Text style={{fontSize: 12, color: currentColors.textSecondary, marginBottom: 4}}>
                                    검색 결과: {searchResults.length}개
                                </Text>
                                <FlatList
                                    data={searchResults}
                                    keyExtractor={(item, index) => `search-${item.id}-${index}`}
                                    renderItem={renderMessage}
                                    style={{maxHeight: 200}}
                                    showsVerticalScrollIndicator={false}
                                />
                            </View>
                        )}
                    </View>
                )}

                {/* 메시지 목록 */}
                <FlatList
                    ref={flatListRef}
                    data={messages}
                    keyExtractor={(item, index) => `${item.id}-${index}`}
                    renderItem={renderMessage}
                    style={{flex: 1, backgroundColor: currentColors.background}}
                    contentContainerStyle={{paddingHorizontal: 16, paddingVertical: 8}}
                    onContentSizeChange={() => {
                        if (messages.length > 0) {
                            flatListRef.current?.scrollToEnd({ animated: true });
                        }
                    }}
                    onLayout={() => {
                        if (messages.length > 0) {
                            flatListRef.current?.scrollToEnd({ animated: true });
                        }
                    }}
                    onViewableItemsChanged={({ viewableItems }) => {
                        // 화면에 보이는 메시지들 중 내가 보낸 메시지가 아닌 것들을 읽음 처리
                        const unreadMessages = viewableItems
                            .map(item => item.item)
                            .filter(msg => msg.sender_employee_id !== myEmployeeId && msg.unread_count > 0);
                        
                        unreadMessages.forEach(msg => {
                            // HTTP API를 사용하여 읽음 처리
                            fetch(`${RENDER_SERVER_URL}/chat/messages/read`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    message_id: msg.id,
                                    user_id: myEmployeeId,
                                    chat_type: chatType,
                                    chat_id: chatId
                                })
                            }).catch(error => {
                                console.error('읽음 처리 오류:', error);
                            });
                        });
                    }}
                    viewabilityConfig={{
                        itemVisiblePercentThreshold: 50
                    }}
                />

                {/* 제목 변경 모달 */}
                <Modal
                    visible={isTitleEditVisible}
                    transparent={true}
                    animationType="slide"
                    onRequestClose={() => setIsTitleEditVisible(false)}
                >
                    <View style={{
                        flex: 1,
                        backgroundColor: 'rgba(0, 0, 0, 0.5)',
                        justifyContent: 'center',
                        alignItems: 'center',
                        paddingHorizontal: 20
                    }}>
                        <View style={{
                            backgroundColor: currentColors.surface,
                            borderRadius: 12,
                            padding: 20,
                            width: '100%',
                            maxWidth: 300
                        }}>
                            <Text style={{
                                fontSize: 18,
                                fontWeight: 'bold',
                                color: currentColors.text,
                                marginBottom: 16,
                                textAlign: 'center'
                            }}>
                                채팅방 제목 변경
                            </Text>
                            
                            <TextInput
                                style={{
                                    backgroundColor: currentColors.background,
                                    borderRadius: 8,
                                    paddingHorizontal: 12,
                                    paddingVertical: 8,
                                    fontSize: 16,
                                    color: currentColors.text,
                                    borderWidth: 1,
                                    borderColor: currentColors.lightGray,
                                    marginBottom: 16
                                }}
                                value={newTitle}
                                onChangeText={setNewTitle}
                                placeholder="새 제목을 입력하세요"
                                placeholderTextColor={currentColors.textSecondary}
                            />
                            
                            <View style={{
                                flexDirection: 'row',
                                justifyContent: 'space-between'
                            }}>
                                <TouchableOpacity
                                    style={{
                                        backgroundColor: currentColors.lightGray,
                                        borderRadius: 8,
                                        paddingHorizontal: 16,
                                        paddingVertical: 8,
                                        flex: 1,
                                        marginRight: 8
                                    }}
                                    onPress={() => {
                                        setIsTitleEditVisible(false);
                                        setNewTitle('');
                                    }}
                                >
                                    <Text style={{
                                        color: currentColors.text,
                                        fontSize: 14,
                                        fontWeight: '600',
                                        textAlign: 'center'
                                    }}>
                                        취소
                                    </Text>
                                </TouchableOpacity>
                                
                                <TouchableOpacity
                                    style={{
                                        backgroundColor: currentColors.primary,
                                        borderRadius: 8,
                                        paddingHorizontal: 16,
                                        paddingVertical: 8,
                                        flex: 1,
                                        marginLeft: 8
                                    }}
                                    onPress={handleTitleChange}
                                >
                                    <Text style={{
                                        color: '#FFFFFF',
                                        fontSize: 14,
                                        fontWeight: '600',
                                        textAlign: 'center'
                                    }}>
                                        변경
                                    </Text>
                                </TouchableOpacity>
                            </View>
                        </View>
                    </View>
                </Modal>

                {/* 참가자 목록 모달 */}
                <Modal
                    visible={isMembersVisible}
                    transparent={true}
                    animationType="slide"
                    onRequestClose={() => setIsMembersVisible(false)}
                >
                    <View style={{
                        flex: 1,
                        backgroundColor: 'rgba(0, 0, 0, 0.5)',
                        justifyContent: 'center',
                        alignItems: 'center',
                        paddingHorizontal: 20
                    }}>
                        <View style={{
                            backgroundColor: currentColors.surface,
                            borderRadius: 12,
                            padding: 20,
                            width: '100%',
                            maxWidth: 350,
                            maxHeight: '80%'
                        }}>
                            {/* 참가자 목록 타이틀 인원수 계산 */}
                            {(() => {
                                const leader = chatMembers.find(m => m.is_host);
                                const memberCount = (leader ? 1 : 0) + chatMembers.filter(m => !leader || m.employee_id !== leader.employee_id).length;
                                return (
                                    <Text style={{
                                        fontSize: 18,
                                        fontWeight: 'bold',
                                        color: currentColors.text,
                                        marginBottom: 16,
                                        textAlign: 'center'
                                    }}>
                                        참가자 목록 ({memberCount}명)
                                    </Text>
                                );
                            })()}
                            
                            {/* 팟장(호스트)만 맨 위에 한 번 표시 */}
                            {(() => {
                                const leader = chatMembers.find(m => m.is_host);
                                if (!leader) return null;
                                return (
                                    <View style={{
                                        flexDirection: 'row',
                                        alignItems: 'center',
                                        paddingVertical: 8,
                                        paddingHorizontal: 12,
                                        backgroundColor: currentColors.background,
                                        borderRadius: 8,
                                        marginBottom: 8
                                    }}>
                                        <View style={{
                                            width: 40,
                                            height: 40,
                                            borderRadius: 20,
                                            backgroundColor: currentColors.yellow,
                                            justifyContent: 'center',
                                            alignItems: 'center',
                                            marginRight: 12
                                        }}>
                                            <Text style={{
                                                color: currentColors.deepBlue,
                                                fontSize: 16,
                                                fontWeight: 'bold'
                                            }}>
                                                {leader.nickname ? leader.nickname.charAt(0) : '?'}
                                            </Text>
                                        </View>
                                        <View style={{ flex: 1 }}>
                                            <Text style={{
                                                fontSize: 16,
                                                fontWeight: '600',
                                                color: currentColors.text
                                            }}>
                                                {leader.nickname || '알 수 없음'}
                                            </Text>
                                        </View>
                                        <View style={{
                                            backgroundColor: currentColors.yellow,
                                            borderRadius: 12,
                                            paddingHorizontal: 8,
                                            paddingVertical: 4
                                        }}>
                                            <Text style={{
                                                fontSize: 10,
                                                fontWeight: 'bold',
                                                color: currentColors.deepBlue
                                            }}>
                                                팟장
                                            </Text>
                                        </View>
                                    </View>
                                );
                            })()}
                            {/* 일반 멤버만 리스트로 표시 (팟장 employee_id와 다른 멤버만) */}
                            <FlatList
                                data={chatMembers.filter(m => {
                                    const leader = chatMembers.find(x => x.is_host);
                                    return !leader || m.employee_id !== leader.employee_id;
                                })}
                                keyExtractor={(item, index) => `member-${item.employee_id}-${index}`}
                                renderItem={({ item }) => (
                                    <View style={{
                                        flexDirection: 'row',
                                        alignItems: 'center',
                                        paddingVertical: 8,
                                        paddingHorizontal: 12,
                                        backgroundColor: currentColors.background,
                                        borderRadius: 8,
                                        marginBottom: 8
                                    }}>
                                        <View style={{
                                            width: 40,
                                            height: 40,
                                            borderRadius: 20,
                                            backgroundColor: currentColors.primary,
                                            justifyContent: 'center',
                                            alignItems: 'center',
                                            marginRight: 12
                                        }}>
                                            <Text style={{
                                                color: '#FFFFFF',
                                                fontSize: 16,
                                                fontWeight: 'bold'
                                            }}>
                                                {item.nickname ? item.nickname.charAt(0) : '?'}
                                            </Text>
                                        </View>
                                        <View style={{ flex: 1 }}>
                                            <Text style={{
                                                fontSize: 16,
                                                fontWeight: '600',
                                                color: currentColors.text
                                            }}>
                                                {item.nickname || '알 수 없음'}
                                            </Text>
                                        </View>
                                    </View>
                                )}
                                showsVerticalScrollIndicator={false}
                            />
                            
                            <TouchableOpacity
                                style={{
                                    backgroundColor: currentColors.primary,
                                    borderRadius: 8,
                                    paddingHorizontal: 16,
                                    paddingVertical: 12,
                                    marginTop: 16
                                }}
                                onPress={() => setIsMembersVisible(false)}
                            >
                                <Text style={{
                                    color: '#FFFFFF',
                                    fontSize: 16,
                                    fontWeight: '600',
                                    textAlign: 'center'
                                }}>
                                    닫기
                                </Text>
                            </TouchableOpacity>
                        </View>
                    </View>
                </Modal>

                {/* 메시지 입력 영역 */}
                <View style={{
                    backgroundColor: currentColors.surface,
                    borderTopWidth: 1,
                    borderTopColor: currentColors.lightGray,
                    paddingHorizontal: 16,
                    paddingVertical: 12,
                    flexDirection: 'row',
                    alignItems: 'flex-end'
                }}>
                    <TouchableOpacity
                        style={{
                            backgroundColor: currentColors.primary,
                            borderRadius: 20,
                            width: 40,
                            height: 40,
                            justifyContent: 'center',
                            alignItems: 'center',
                            marginRight: 8
                        }}
                        onPress={() => setIsImagePickerVisible(true)}
                    >
                        <Ionicons 
                            name="camera" 
                            size={20} 
                            color="#FFFFFF" 
                        />
                    </TouchableOpacity>
                    
                    <TextInput
                        style={{
                            flex: 1,
                            backgroundColor: currentColors.background,
                            borderRadius: 20,
                            paddingHorizontal: 16,
                            paddingVertical: 10,
                            marginRight: 8,
                            fontSize: 16,
                            color: currentColors.text,
                            maxHeight: 100,
                            borderWidth: 1,
                            borderColor: currentColors.lightGray
                        }}
                        value={newMessage}
                        onChangeText={setNewMessage}
                        placeholder="메시지를 입력하세요..."
                        placeholderTextColor={currentColors.textSecondary}
                        multiline
                        maxLength={500}
                    />
                    <TouchableOpacity
                        style={{
                            backgroundColor: !newMessage.trim() ? currentColors.lightGray : currentColors.primary,
                            borderRadius: 20,
                            width: 40,
                            height: 40,
                            justifyContent: 'center',
                            alignItems: 'center'
                        }}
                        onPress={sendMessage}
                        disabled={!newMessage.trim()}
                    >
                        <Ionicons 
                            name="send" 
                            size={20} 
                            color={!newMessage.trim() ? currentColors.textSecondary : '#FFFFFF'} 
                        />
                    </TouchableOpacity>
                </View>

                {/* 연결 상태 표시 (임시로 비활성화) */}
                {false && !isConnected && (
                    <View style={{
                        backgroundColor: currentColors.warning,
                        paddingVertical: 8,
                        paddingHorizontal: 16,
                        alignItems: 'center'
                    }}>
                        <Text style={{color: '#FFFFFF', fontSize: 14, fontWeight: '600'}}>연결 중...</Text>
                    </View>
                )}

                {/* 이미지 선택 모달 */}
                <Modal
                    visible={isImagePickerVisible}
                    transparent={true}
                    animationType="slide"
                    onRequestClose={() => setIsImagePickerVisible(false)}
                >
                    <View style={{
                        flex: 1,
                        backgroundColor: 'rgba(0, 0, 0, 0.5)',
                        justifyContent: 'flex-end'
                    }}>
                        <View style={{
                            backgroundColor: currentColors.surface,
                            borderTopLeftRadius: 20,
                            borderTopRightRadius: 20,
                            padding: 20
                        }}>
                            <Text style={{
                                fontSize: 18,
                                fontWeight: 'bold',
                                color: currentColors.text,
                                marginBottom: 20,
                                textAlign: 'center'
                            }}>
                                이미지 선택
                            </Text>
                            
                            <View style={{
                                flexDirection: 'row',
                                justifyContent: 'space-around',
                                marginBottom: 20
                            }}>
                                <TouchableOpacity
                                    style={{
                                        backgroundColor: currentColors.primary,
                                        borderRadius: 12,
                                        paddingVertical: 12,
                                        paddingHorizontal: 20,
                                        alignItems: 'center',
                                        flex: 1,
                                        marginRight: 10
                                    }}
                                    onPress={() => {
                                        setIsImagePickerVisible(false);
                                        // 카메라로 촬영 (구현 예정)
                                        Alert.alert('카메라', '카메라 기능은 추후 구현 예정입니다.');
                                    }}
                                >
                                    <Ionicons name="camera" size={24} color="#FFFFFF" />
                                    <Text style={{color: '#FFFFFF', marginTop: 4, fontSize: 12}}>카메라</Text>
                                </TouchableOpacity>
                                
                                <TouchableOpacity
                                    style={{
                                        backgroundColor: currentColors.primary,
                                        borderRadius: 12,
                                        paddingVertical: 12,
                                        paddingHorizontal: 20,
                                        alignItems: 'center',
                                        flex: 1,
                                        marginLeft: 10
                                    }}
                                    onPress={() => {
                                        setIsImagePickerVisible(false);
                                        // 갤러리에서 선택 (구현 예정)
                                        Alert.alert('갤러리', '갤러리 선택 기능은 추후 구현 예정입니다.');
                                    }}
                                >
                                    <Ionicons name="images" size={24} color="#FFFFFF" />
                                    <Text style={{color: '#FFFFFF', marginTop: 4, fontSize: 12}}>갤러리</Text>
                                </TouchableOpacity>
                            </View>
                            
                            <TouchableOpacity
                                style={{
                                    backgroundColor: currentColors.gray,
                                    borderRadius: 12,
                                    paddingVertical: 12,
                                    alignItems: 'center'
                                }}
                                onPress={() => setIsImagePickerVisible(false)}
                            >
                                <Text style={{color: currentColors.white, fontSize: 16, fontWeight: '600'}}>취소</Text>
                            </TouchableOpacity>
                        </View>
                    </View>
                </Modal>
            </KeyboardAvoidingView>
        </SafeAreaView>
    );
}

// --- 온보딩 화면 ---
function OnboardingScreen() {
    const { user } = useAuth();
    const [currentStep, setCurrentStep] = useState(0);
    const [userPreferences, setUserPreferences] = useState({
        nickname: '',
        foodPreferences: [],
        lunchStyle: [],
        allergies: [],
        preferredTime: ''
    });
    const [nicknameError, setNicknameError] = useState('');
    const [checkingNickname, setCheckingNickname] = useState(false);
    const onboardingSteps = [
        {
            title: '닉네임 설정',
            description: '앱에서 사용할 닉네임을 입력해주세요',
            type: 'input',
            key: 'nickname'
        },
        {
            title: '점심 선호도 설정',
            description: '좋아하는 음식 종류를 선택해주세요',
            type: 'multiSelect',
            options: ['한식', '중식', '일식', '양식', '분식', '카페', '패스트푸드'],
            key: 'foodPreferences'
        },
        {
            title: '점심 성향',
            description: '당신의 점심 스타일을 선택해주세요',
            type: 'multiSelect',
            options: ['가성비 좋은 곳', '맛집 탐방', '건강한 식사', '빠른 식사', '새로운 메뉴 도전', '친구들과 함께', '혼자 조용히', '분위기 좋은 곳'],
            key: 'lunchStyle'
        },
        {
            title: '알레르기 정보',
            description: '알레르기가 있는 음식을 선택해주세요',
            type: 'multiSelect',
            options: ['없음', '갑각류', '견과류', '우유', '계란', '밀', '대두', '생선'],
            key: 'allergies'
        },
        {
            title: '선호 시간대',
            description: '주로 점심을 먹는 시간대를 선택해주세요',
            type: 'singleSelect',
            options: ['11:30', '11:45', '12:00', '12:15', '12:30'],
            key: 'preferredTime'
        }
    ];
    const handleNext = async () => {
        if (onboardingSteps[currentStep].key === 'nickname') {
            // 닉네임 중복 체크
            setCheckingNickname(true);
            setNicknameError('');
            const nickname = userPreferences.nickname.trim();
            if (!nickname) {
                setNicknameError('닉네임을 입력해주세요.');
                setCheckingNickname(false);
                return;
            }
            try {
                const res = await fetch(`${RENDER_SERVER_URL}/users/check-nickname?nickname=${encodeURIComponent(nickname)}`);
                const data = await res.json();
                if (data.exists) {
                    setNicknameError('이미 사용 중인 닉네임입니다. 다른 닉네임을 입력해주세요.');
                    setCheckingNickname(false);
                    return;
                }
            } catch (e) {
                setNicknameError('닉네임 중복 확인 중 오류가 발생했습니다.');
                setCheckingNickname(false);
                return;
            }
            setCheckingNickname(false);
        }
        if (currentStep < onboardingSteps.length - 1) {
            setCurrentStep(currentStep + 1);
        } else {
            // 온보딩 완료, 사용자 설정 저장
            await saveUserPreferences();
            // AsyncStorage에 온보딩 완료 상태 저장
            await AsyncStorage.setItem('onboardingCompleted', 'true');
            global.hasCompletedOnboarding = true;
            
            // 온보딩 완료 후 메인 앱으로 이동
            // AsyncStorage에 온보딩 완료 상태가 저장되었으므로 
            // MainApp의 useEffect에서 자동으로 hasCompletedOnboarding이 true로 설정됨
        }
    };
    const handleBack = () => {
        if (currentStep > 0) {
            setCurrentStep(currentStep - 1);
        }
    };
    const handleOptionSelect = (option) => {
        const currentKey = onboardingSteps[currentStep].key;
        const currentStepData = onboardingSteps[currentStep];
        if (currentStepData.type === 'multiSelect') {
            setUserPreferences(prev => ({
                ...prev,
                [currentKey]: prev[currentKey].includes(option)
                    ? prev[currentKey].filter(item => item !== option)
                    : [...prev[currentKey], option]
            }));
        } else {
            setUserPreferences(prev => ({
                ...prev,
                [currentKey]: option
            }));
        }
    };
    const saveUserPreferences = async () => {
        try {
            // 사용자 기본 정보 저장
            const userData = {
                nickname: userPreferences.nickname,
                lunch_preference: userPreferences.lunchStyle?.join(', ') || '',
                main_dish_genre: userPreferences.foodPreferences?.join(', ') || '',
                main_dish: userPreferences.foodPreferences?.join(', ') || '', // 주종목으로 음식 선호도 저장
            };
            await fetch(`${RENDER_SERVER_URL}/users/${user.employee_id}`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(userData)
            });
            // 사용자 선호도 정보 저장
            const preferencesData = {
                foodPreferences: userPreferences.foodPreferences || [],
                allergies: userPreferences.allergies || [],
                preferredTime: userPreferences.preferredTime || '',
                frequentAreas: []
            };
            await fetch(`${RENDER_SERVER_URL}/users/${user.employee_id}/preferences`, {
                method: 'PUT',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(preferencesData)
            });
            
            // AsyncStorage에 온보딩 완료 상태 저장
            await AsyncStorage.setItem('onboardingCompleted', 'true');
            global.hasCompletedOnboarding = true;
        } catch (error) {
            console.error('사용자 설정 저장 실패:', error);
        }
    };
    const currentStepData = onboardingSteps[currentStep];
    const selectedOptions = userPreferences[currentStepData.key] || [];
    return (
        <SafeAreaView style={{flex: 1, backgroundColor: COLORS.light.background}}>
            <View style={{padding: 20, alignItems: 'center'}}>
                <View style={{flexDirection: 'row', marginBottom: 20}}>
                    {onboardingSteps.map((_, index) => (
                        <View
                            key={index}
                            style={{
                                width: 8,
                                height: 8,
                                borderRadius: 4,
                                backgroundColor: index <= currentStep ? COLORS.light.primary : COLORS.light.lightGray,
                                marginHorizontal: 4
                            }}
                        />
                    ))}
                </View>
                <Text style={{color: COLORS.light.textSecondary, fontSize: 14}}>
                    {currentStep + 1} / {onboardingSteps.length}
                </Text>
            </View>
            <View style={{flex: 1, padding: 20}}>
                <Text style={{fontSize: 24, fontWeight: 'bold', color: COLORS.light.text, marginBottom: 10, textAlign: 'center'}}>{currentStepData.title}</Text>
                <Text style={{fontSize: 16, color: COLORS.light.textSecondary, marginBottom: 30, textAlign: 'center'}}>{currentStepData.description}</Text>
                {currentStepData.type === 'input' ? (
                    <View style={{alignItems: 'center'}}>
                        <TextInput
                            style={{
                                width: '100%',
                                borderWidth: 1,
                                borderColor: nicknameError ? COLORS.red : COLORS.light.border,
                                borderRadius: 12,
                                padding: 16,
                                fontSize: 18,
                                marginBottom: 8,
                                color: COLORS.light.text,
                                backgroundColor: '#FFFFFF'
                            }}
                            placeholder="닉네임을 입력하세요"
                            placeholderTextColor={COLORS.light.textSecondary}
                            value={userPreferences.nickname}
                            onChangeText={text => setUserPreferences(prev => ({ ...prev, nickname: text }))}
                            editable={!checkingNickname}
                        />
                        {nicknameError ? <Text style={{color: COLORS.red, marginBottom: 8}}>{nicknameError}</Text> : null}
                    </View>
                ) : (
                    <ScrollView style={{flex: 1}} showsVerticalScrollIndicator={false}>
                        {currentStepData.options.map((option) => (
                            <TouchableOpacity
                                key={option}
                                style={{
                                    backgroundColor: selectedOptions.includes(option) ? COLORS.light.primary : COLORS.light.surface,
                                    padding: 16,
                                    borderRadius: 12,
                                    marginBottom: 10,
                                    flexDirection: 'row',
                                    justifyContent: 'space-between',
                                    alignItems: 'center',
                                    borderWidth: 1,
                                    borderColor: selectedOptions.includes(option) ? COLORS.light.primary : COLORS.light.border
                                }}
                                onPress={() => handleOptionSelect(option)}
                            >
                                <Text style={{
                                    fontSize: 16,
                                    color: selectedOptions.includes(option) ? COLORS.light.surface : COLORS.light.text
                                }}>
                                    {option}
                                </Text>
                                {selectedOptions.includes(option) && (
                                    <Ionicons name="checkmark-circle" size={20} color={COLORS.light.surface} />
                                )}
                            </TouchableOpacity>
                        ))}
                    </ScrollView>
                )}
            </View>
            <View style={{flexDirection: 'row', justifyContent: 'space-between', padding: 20, backgroundColor: COLORS.light.surface}}>
                {currentStep > 0 && (
                    <TouchableOpacity style={{padding: 12, borderRadius: 8, borderWidth: 1, borderColor: COLORS.light.border}} onPress={handleBack}>
                        <Text style={{fontSize: 16, color: COLORS.light.textSecondary}}>이전</Text>
                    </TouchableOpacity>
                )}
                <TouchableOpacity style={{padding: 12, borderRadius: 8, backgroundColor: COLORS.light.primary, flex: 1, marginLeft: currentStep > 0 ? 12 : 0, alignItems: 'center'}} onPress={handleNext} disabled={checkingNickname}>
                    <Text style={{fontSize: 16, color: COLORS.light.surface, fontWeight: 'bold'}}>{currentStep === onboardingSteps.length - 1 ? '완료' : '다음'}</Text>
                </TouchableOpacity>
            </View>
        </SafeAreaView>
    );
}

// Stack Navigator들 정의
const commonScreenOptions = {
    headerStyle: { backgroundColor: COLORS.light.primary },
    headerTintColor: '#fff',
    headerTitleStyle: { fontWeight: 'bold' }
};

const HomeStack = () => (
    <Stack.Navigator screenOptions={commonScreenOptions}>
        <Stack.Screen 
            name="HomeScreen" 
            component={HomeScreen} 
            options={({ navigation, route }) => ({
                title: '밥플떼기',
                headerLeft: () => (
                    <TouchableOpacity 
                        style={{ marginLeft: 15, position: 'relative' }} 
                        onPress={() => {
                            // 홈 화면으로 이동하여 미션 모달을 열기
                            navigation.navigate('HomeScreen', { openMissionModal: true });
                        }}
                    >
                        <Ionicons name="trophy-outline" size={24} color={'#fff'} />
                        {/* 미션 완료 후 수령하지 않은 미션이 있을 때 빨간 점 표시 */}
                        {route.params?.hasUnclaimedMissions && (
                            <View style={{
                                position: 'absolute',
                                top: -2,
                                right: -2,
                                width: 8,
                                height: 8,
                                borderRadius: 4,
                                backgroundColor: '#EF4444'
                            }} />
                        )}
                    </TouchableOpacity>
                ),
                headerRight: () => (
                    <View style={{ flexDirection: 'row', marginRight: 15 }}>
                        <TouchableOpacity 
                            style={{ marginRight: 15 }} 
                            onPress={() => {
                                // 마이페이지로 이동
                                safeNavigateToTab(navigation, '친구', 'MyPageMain');
                            }}
                        >
                            <Ionicons name="person-circle-outline" size={24} color={'#fff'} />
                        </TouchableOpacity>
                        <TouchableOpacity 
                            onPress={() => safeNavigateToTab(navigation, '소통', 'Notifications')}
                            style={{ position: 'relative' }}
                        >
                            <Ionicons name="notifications-outline" size={24} color={'#fff'} />
                            {route.params?.unreadCount > 0 && (
                                <View style={{
                                    position: 'absolute',
                                    top: -5,
                                    right: -5,
                                    backgroundColor: '#EF4444',
                                    borderRadius: 10,
                                    minWidth: 20,
                                    height: 20,
                                    justifyContent: 'center',
                                    alignItems: 'center',
                                    paddingHorizontal: 4,
                                }}>
                                    <Text style={{
                                        color: '#fff',
                                        fontSize: 12,
                                        fontWeight: 'bold',
                                    }}>
                                        {route.params.unreadCount > 99 ? '99+' : route.params.unreadCount}
                                    </Text>
                                </View>
                            )}
                        </TouchableOpacity>
                    </View>
                )
            })}
        />
    </Stack.Navigator>
);

const RestaurantStack = () => (
    <Stack.Navigator screenOptions={commonScreenOptions}>
        <Stack.Screen name="RestaurantsList" component={RestaurantTab} options={{ headerShown: false }}/>
        
        <Stack.Screen name="WriteReview" component={WriteReview} options={{ title: '리뷰 작성' }} />
        <Stack.Screen name="PhotoGallery" component={PhotoGallery} options={{ headerShown: false }} />
    </Stack.Navigator>
);

const PartiesStack = () => (
    <Stack.Navigator screenOptions={commonScreenOptions}>
        <Stack.Screen name="PartiesScreen" component={PartiesContainerScreen} options={{ title: '파티' }}/>
        <Stack.Screen name="PartyDetail" component={PartyDetailScreen} options={{ title: '파티 정보' }}/>
        <Stack.Screen name="CreateParty" component={CreatePartyScreen} options={{ title: '새 파티 만들기' }}/>
        <Stack.Screen name="CreatePersonalSchedule" component={CreatePersonalScheduleScreen} options={{ title: '기타 일정 추가' }} />
        <Stack.Screen name="SearchUsers" component={SearchUsersScreen} options={{ title: '친구 찾기' }} />
                
        <Stack.Screen name="EditPersonalSchedule" component={EditPersonalScheduleScreen} options={{ title: '기타 일정 수정' }} />
        <Stack.Screen name="EditParty" component={EditPartyScreen} options={{ title: '파티 정보 수정' }} />
        <Stack.Screen name="RandomLunch" component={RandomLunchScreen} options={{ title: '랜덤 런치' }} />
        <Stack.Screen name="IntelligentScheduling" component={IntelligentSchedulingScreen} options={{ title: '지능형 스케줄링' }} />
        <Stack.Screen name="SuggestedDatesScreen" component={SuggestedDatesScreen} options={{ title: '제안된 날짜' }} />
        <Stack.Screen name="RestaurantSelectionScreen" component={RestaurantSelectionScreen} options={{ title: '식당 선택' }} />
        <Stack.Screen name="TimeSelectionScreen" component={TimeSelectionScreen} options={{ title: '시간 선택' }} />
        <Stack.Screen name="PartyConfirmationScreen" component={PartyConfirmationScreen} options={{ title: '파티 확정' }} />
        <Stack.Screen name="VotingScreen" component={VotingScreen} options={{ title: '투표' }} />
        <Stack.Screen name="VotingParticipateScreen" component={VotingParticipateScreen} options={{ title: '투표 참여' }} />
        <Stack.Screen name="VotingEditScreen" component={VotingEditScreen} options={{ title: '투표 수정' }} />
        <Stack.Screen name="FriendProfile" component={FriendProfileScreen} options={{ title: '동료 프로필' }} />
        <Stack.Screen name="UserProfile" component={UserProfileScreen} options={{ title: '사용자 프로필' }} />
    </Stack.Navigator>
);

const CommunicationStack = () => (
    <Stack.Navigator screenOptions={commonScreenOptions}>
        <Stack.Screen name="ChatList" component={ChatListScreen} options={{ title: '소통' }}/>
        <Stack.Screen name="ChatRoom" component={ChatRoomScreen} options={({ route }) => ({ title: route.params?.chatTitle || '채팅' })} />
        <Stack.Screen name="CreateChatRoom" component={CreateChatRoomScreen} options={{ title: '채팅방 만들기' }} />
        <Stack.Screen name="Notifications" component={NotificationScreen} options={{ title: '알림' }}/>
        <Stack.Screen name="ReviewDetail" component={ReviewDetailScreen} options={{ title: '리뷰 상세' }}/>
    </Stack.Navigator>
);

const FriendStack = () => {
    const { colors } = useTheme();
    return (
        <Stack.Navigator screenOptions={commonScreenOptions}>
            <Stack.Screen 
                name="FriendMain" 
                component={FriendMainScreen} 
                options={({ navigation, route }) => ({
                    title: '친구',
                    headerRight: () => (
                        <View style={{ flexDirection: 'row', marginRight: 15 }}>
                            <TouchableOpacity 
                                style={{ marginRight: 15 }} 
                                onPress={() => {
                                    navigation.setParams({ toggleSearch: true });
                                }}
                            >
                                <Ionicons name="search" size={26} color={'#fff'} />
                            </TouchableOpacity>
                            <TouchableOpacity 
                                onPress={() => Alert.alert('설정', '설정 기능은 곧 출시됩니다!')}
                            >
                                <Ionicons name="settings-outline" size={26} color={'#fff'} />
                            </TouchableOpacity>
                        </View>
                    )
                })} 
            />
            <Stack.Screen name="FriendList" component={FriendListScreen} options={{ title: '친구 목록' }}/>
            <Stack.Screen name="SearchUsers" component={SearchUsersScreen} options={{ title: '친구 찾기' }}/>
            <Stack.Screen name="FriendProfile" component={FriendProfileScreen} options={{ title: '친구 프로필' }}/>
            <Stack.Screen name="UserProfile" component={UserProfileScreen} options={{ title: '사용자 프로필' }}/>
            <Stack.Screen name="MyProfile" component={MyProfileScreen} options={{ title: '내 프로필' }}/>
            <Stack.Screen name="ProfileSection" component={ProfileSection} options={{ title: '프로필' }}/>
            <Stack.Screen name="ProfileEdit" component={ProfileEditScreen} options={{ title: '프로필 수정' }}/>
            <Stack.Screen name="RankingScreen" component={RankingScreen} options={{ title: '랭킹' }}/>
            <Stack.Screen name="MyPageMain" component={MyPageMain} options={{ title: '마이페이지' }}/>
            <Stack.Screen name="LevelSystemScreen" component={LevelSystemScreen} options={{ title: '레벨 시스템' }}/>
            <Stack.Screen name="ChallengesScreen" component={ChallengesScreen} options={{ title: '도전과제' }}/>
            <Stack.Screen name="FriendInvite" component={FriendInviteScreen} options={{ title: '친구 초대' }}/>
        </Stack.Navigator>
    );
};

// 메인 탭 네비게이터 컴포넌트
function TabNavigator() {
    const { colors } = useTheme();
    const { hasUnclaimedMissions } = useMission();
    
    return (
        <Tab.Navigator screenOptions={({ route }) => ({
            tabBarIcon: ({ focused, color, size }) => {
                const icons = { '홈': 'home', '맛집': 'restaurant', '파티': 'people', '소통': 'chatbubbles', '친구': 'people-circle' };
                const iconName = focused ? icons[route.name] : `${icons[route.name]}-outline`;
                
                // 홈탭에 미션 알림 점 추가
                if (route.name === '홈' && hasUnclaimedMissions) {
                    return (
                        <View style={{ position: 'relative' }}>
                            <Ionicons name={iconName} size={size} color={color} />
                            <View style={{
                                position: 'absolute',
                                top: -2,
                                right: -2,
                                width: 8,
                                height: 8,
                                borderRadius: 4,
                                backgroundColor: '#EF4444',
                                borderWidth: 1,
                                borderColor: colors.surface
                            }} />
                        </View>
                    );
                }
                
                return <Ionicons name={iconName} size={size} color={color} />;
            },
            tabBarActiveTintColor: colors.primary,
            tabBarInactiveTintColor: colors.gray,
            headerShown: false,
            tabBarStyle: { 
                backgroundColor: colors.surface, 
                borderTopColor: colors.lightGray,
                height: 85,
                paddingBottom: 18,
                paddingTop: 10,
                elevation: 8,
                shadowColor: colors.primary,
                shadowOffset: { width: 0, height: -2 },
                shadowOpacity: 0.1,
                shadowRadius: 4
            },
            tabBarLabelStyle: { fontWeight: '600', fontSize: 12, marginTop: 2 },
            tabBarIconStyle: { marginBottom: 4 }
        })}>
            <Tab.Screen name="홈" component={HomeStack} />
            <Tab.Screen name="맛집" component={RestaurantStack} />
            <Tab.Screen name="파티" component={PartiesStack} />
            <Tab.Screen name="소통" component={CommunicationStack} />
            <Tab.Screen name="친구" component={FriendStack} />
        </Tab.Navigator>
    );
}

// 메인 앱 화면 컴포넌트
function MainApp() {
    const [hasCompletedOnboarding, setHasCompletedOnboarding] = useState(false);
    const { authState, user } = useAuth();

    useEffect(() => {
        checkOnboardingStatus();
        
        // 주기적으로 온보딩 상태 확인 (1초마다)
        const interval = setInterval(() => {
            checkOnboardingStatus();
        }, 1000);
        
        return () => {
            clearInterval(interval);
        };
    }, []);

    const checkOnboardingStatus = async () => {
        try {
            const onboardingCompleted = await AsyncStorage.getItem('onboardingCompleted');
            if (onboardingCompleted === 'true') {
                setHasCompletedOnboarding(true);
            }
        } catch (error) {
            console.error('온보딩 상태 확인 오류:', error);
        }
    };

    // 로딩 중
    if (authState === 'loading') {
    return (
            <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
                <ActivityIndicator size="large" color="#3B82F6" />
                <Text style={{ marginTop: 10 }}>로딩 중...</Text>
            </View>
        );
    }

    // 인증되지 않은 경우 로그인 화면
    if (authState === 'unauthenticated') {
        return <LoginScreen />;
    }

    // 온보딩이 완료되지 않은 경우 온보딩 화면
    if (!hasCompletedOnboarding) {
        return <OnboardingScreen />;
    }

    // 메인 앱 화면 - NavigationContainer로 감싸서 TabNavigator 사용
    return (
        <NavigationContainer>
            <TabNavigator />
        </NavigationContainer>
    );
}

// 메인 App 컴포넌트
export default function App() {
    return (
        <AuthProvider>
        <ThemeProvider>
            <UserProvider>
                <PointsProvider>
                    <MissionProvider>
                        <AppointmentProvider>
                            <ScheduleProvider>
                                    <MainApp />
                            </ScheduleProvider>
                        </AppointmentProvider>
                    </MissionProvider>
                </PointsProvider>
            </UserProvider>
        </ThemeProvider>
        </AuthProvider>
    );
}

// --- 전역 스타일 정의 ---
const styles = StyleSheet.create({
    safeArea: { flex: 1, backgroundColor: COLORS.light.background },
    centerView: { flex: 1, justifyContent: 'center', alignItems: 'center', padding: 20, backgroundColor: COLORS.light.background },
    homeContainer: { paddingTop: 10 },
    header: { flexDirection: 'row', justifyContent: 'space-between', alignItems: 'center', paddingHorizontal: 16, paddingTop: 10, paddingBottom: 10, backgroundColor: COLORS.light.background },
    headerTitle: { fontSize: 32, fontWeight: 'bold', color: COLORS.light.primary, textAlign: 'center', width: '100%', letterSpacing: 1 },
    card: { 
        backgroundColor: COLORS.light.surface, 
        borderRadius: 20, 
        padding: 20, 
        marginHorizontal: 16, 
        marginBottom: 16, 
        elevation: 3, 
        shadowColor: COLORS.light.primary,
        shadowOffset: { width: 0, height: 4 }, 
        shadowOpacity: 0.1, 
        shadowRadius: 8,
        borderWidth: 1,
        borderColor: 'rgba(59, 130, 246, 0.1)'
    },
    cardTitle: { fontSize: 18, fontWeight: 'bold', color: COLORS.light.text, marginBottom: 12 },
    menuText: { fontSize: 16, color: COLORS.light.textSecondary, lineHeight: 22 },
    appointmentCard: { 
        backgroundColor: COLORS.light.surface, 
        borderRadius: 12, 
        padding: 18, 
        paddingVertical: 40,
        marginRight: 12,
        marginBottom: 5, 
        width: 220,
        minHeight: 160,
        alignItems: 'flex-start',
        borderLeftWidth: 4, 
        borderLeftColor: COLORS.light.primary,
        elevation: 2,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 3
    },
    appointmentDate: { fontSize: 16, fontWeight: 'bold', color: COLORS.light.primary, marginBottom: 8 },
    appointmentHeader: { 
        alignSelf: 'flex-start', 
        marginBottom: 12,
        position: 'absolute',
        top: 20,
        left: 20
    },
    eventItem: { marginBottom: 8 },
    eventTitle: { fontSize: 14, fontWeight: '600', color: COLORS.light.text, marginBottom: 4 },
    eventDetail: { fontSize: 12, color: COLORS.light.textSecondary, marginBottom: 2 },
    noAppointmentText: { fontSize: 14, color: COLORS.light.textSecondary, textAlign: 'center', fontStyle: 'italic' },
    modalDetailCard: { 
        backgroundColor: COLORS.light.background, 
        borderRadius: 12, 
        padding: 16, 
        marginBottom: 12,
        borderWidth: 1,
        borderColor: COLORS.light.border
    },
    modalDetailText: { fontSize: 14, color: COLORS.light.text, marginBottom: 4, lineHeight: 20 },
    // 채팅 관련 스타일
    messageContainer: { marginVertical: 4, paddingHorizontal: 8 },
    myMessage: { alignItems: 'flex-end' },
    otherMessage: { alignItems: 'flex-start' },
    messageBubble: { 
        maxWidth: '80%', 
        padding: 12, 
        borderRadius: 16,
        elevation: 1,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 1 },
        shadowOpacity: 0.1,
        shadowRadius: 2
    },
    myMessageBubble: { 
        backgroundColor: COLORS.light.primary,
        borderBottomRightRadius: 4
    },
    otherMessageBubble: { 
        backgroundColor: COLORS.light.surface,
        borderBottomLeftRadius: 4
    },
    messageText: { fontSize: 16, lineHeight: 20 },
    myMessageText: { color: '#FFFFFF' },
    otherMessageText: { color: COLORS.light.text },
    messageSender: { fontSize: 12, color: COLORS.light.textSecondary, marginBottom: 4 },
    messageTime: { fontSize: 11, color: COLORS.light.gray, marginTop: 2 },
    // 입력 관련 스타일
    input: {
        backgroundColor: COLORS.light.surface,
        borderRadius: 12,
        paddingHorizontal: 16,
        paddingVertical: 12,
        fontSize: 16,
        color: COLORS.light.text,
        borderWidth: 1,
        borderColor: COLORS.light.border,
        marginBottom: 16
    },
    inputLabel: { fontSize: 16, fontWeight: '600', color: COLORS.light.text, marginBottom: 8 },
    submitButton: {
        backgroundColor: COLORS.light.primary,
        borderRadius: 12,
        paddingVertical: 16,
        alignItems: 'center',
        marginTop: 20
    },
    submitButtonText: { fontSize: 16, fontWeight: 'bold', color: '#FFFFFF' },
    // 점심 약속 옵션 모달 스타일
    appointmentOptionsContainer: {
        width: '100%',
        gap: 12
    },
    appointmentOptionButton: {
        flexDirection: 'row',
        alignItems: 'center',
        justifyContent: 'space-between',
        padding: 20,
        borderRadius: 16,
        elevation: 2,
        shadowColor: '#000',
        shadowOffset: { width: 0, height: 2 },
        shadowOpacity: 0.1,
        shadowRadius: 4
    },
    optionContent: {
        flex: 1,
        marginRight: 12
    },
    optionTitle: {
        fontSize: 18,
        fontWeight: 'bold',
        marginBottom: 4
    },
    optionSubtitle: {
        fontSize: 14,
        opacity: 0.8,
        lineHeight: 18
    },
    modalView: { 
        margin: 20, 
        backgroundColor: 'white', 
        borderRadius: 24, 
        padding: 30, 
        alignItems: 'center', 
        width: '90%', 
        maxWidth: 400, 
        shadowColor: '#000', 
        shadowOffset: { width: 0, height: 8 }, 
        shadowOpacity: 0.3, 
        shadowRadius: 12, 
        elevation: 8 
    },
    centeredView: {
        flex: 1,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: 'rgba(0, 0, 0, 0.5)',
    },
    modalTitle: {
        fontSize: 20,
        fontWeight: 'bold',
        marginBottom: 20,
        color: COLORS.light.text,
    },
});
